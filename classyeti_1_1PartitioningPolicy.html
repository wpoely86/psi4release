<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>PSI: yeti::PartitioningPolicy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PSI
   &#160;<span id="projectnumber">4.0.0-beta5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>yeti</b></li><li class="navelem"><a class="el" href="classyeti_1_1PartitioningPolicy.html">PartitioningPolicy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classyeti_1_1PartitioningPolicy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">yeti::PartitioningPolicy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for yeti::PartitioningPolicy:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classyeti_1_1PartitioningPolicy__inherit__graph.svg" width="163" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for yeti::PartitioningPolicy:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classyeti_1_1PartitioningPolicy__coll__graph.svg" width="163" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy_1_1LessThanComparator.html">LessThanComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd296ebbcf3a3f26cd755dd5ca1e4c68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd296ebbcf3a3f26cd755dd5ca1e4c68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#acd296ebbcf3a3f26cd755dd5ca1e4c68">PartitioningPolicy</a> ()</td></tr>
<tr class="memdesc:acd296ebbcf3a3f26cd755dd5ca1e4c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default constructor that uses some reasonable defaults. <br/></td></tr>
<tr class="separator:acd296ebbcf3a3f26cd755dd5ca1e4c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e767d351b09bb5e9e8f02f039f5e44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32e767d351b09bb5e9e8f02f039f5e44"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PartitioningPolicy</b> (std::vector&lt; int &gt; levels)</td></tr>
<tr class="separator:a32e767d351b09bb5e9e8f02f039f5e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbca2f6cc2c1aae1834e3a1316bad16e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbca2f6cc2c1aae1834e3a1316bad16e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PartitioningPolicy</b> (int d1, int d2=-1, int d3=-1, int d4=-1, int d5=-1, int d6=-1, int d7=-1, int d8=-1, int d9=-1)</td></tr>
<tr class="separator:acbca2f6cc2c1aae1834e3a1316bad16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3e6df5e719c2d951d278af6ca0f80f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d3e6df5e719c2d951d278af6ca0f80f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nlevels</b> () const </td></tr>
<tr class="separator:a2d3e6df5e719c2d951d278af6ca0f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79acedcabb6d5a03e8ac6233a48c9e2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79acedcabb6d5a03e8ac6233a48c9e2c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a79acedcabb6d5a03e8ac6233a48c9e2c">should_partition_at_level</a> (const ShellPtr &amp;sh1, const ShellPtr &amp;sh2, int level, uli numSoFar, std::vector&lt; uli &gt; fxnSoFar)</td></tr>
<tr class="memdesc:a79acedcabb6d5a03e8ac6233a48c9e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes into account sizecheck_traits_. <br/></td></tr>
<tr class="separator:a79acedcabb6d5a03e8ac6233a48c9e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fa6e340a6ce759c2c9a2807c517474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a14fa6e340a6ce759c2c9a2807c517474">sort_shells</a> (std::vector&lt; ShellPtr &gt; &amp;shells) const </td></tr>
<tr class="separator:a14fa6e340a6ce759c2c9a2807c517474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c053ab2bc1a1247e55bb6584efc67b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#ad5c053ab2bc1a1247e55bb6584efc67b">set_min_fxn_per_tile</a> (int n)</td></tr>
<tr class="separator:ad5c053ab2bc1a1247e55bb6584efc67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f87c750e8d0071a7c647722ac0e81e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30f87c750e8d0071a7c647722ac0e81e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a30f87c750e8d0071a7c647722ac0e81e">min_fxn_per_tile</a> () const </td></tr>
<tr class="memdesc:a30f87c750e8d0071a7c647722ac0e81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter function for <a class="el" href="classyeti_1_1PartitioningPolicy.html#ae5c5d275819cfd207b2502b9d2aa8bfd">PartitioningPolicy::nfxn_min_per_tile_</a>. <br/></td></tr>
<tr class="separator:a30f87c750e8d0071a7c647722ac0e81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9822160f9ab46476e93032695f4eacd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9822160f9ab46476e93032695f4eacd1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a9822160f9ab46476e93032695f4eacd1">set_min_idx_per_tile</a> (int n)</td></tr>
<tr class="memdesc:a9822160f9ab46476e93032695f4eacd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter function for <a class="el" href="classyeti_1_1PartitioningPolicy.html#a19f3771a1ca0970c2610bae1d21213bd">PartitioningPolicy::nidx_min_per_tile_</a>. <br/></td></tr>
<tr class="separator:a9822160f9ab46476e93032695f4eacd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d6de43ec17ace655529b9645ebe4b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37d6de43ec17ace655529b9645ebe4b0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a37d6de43ec17ace655529b9645ebe4b0">min_idx_per_tile</a> () const </td></tr>
<tr class="memdesc:a37d6de43ec17ace655529b9645ebe4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter function for <a class="el" href="classyeti_1_1PartitioningPolicy.html#a19f3771a1ca0970c2610bae1d21213bd">PartitioningPolicy::nidx_min_per_tile_</a>. <br/></td></tr>
<tr class="separator:a37d6de43ec17ace655529b9645ebe4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add708002a9365d16fa75f876fb736475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add708002a9365d16fa75f876fb736475"></a>
uli&#160;</td><td class="memItemRight" valign="bottom"><b>min_fxn_at_level</b> (int level) const </td></tr>
<tr class="separator:add708002a9365d16fa75f876fb736475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1174196370d930c9fff6b471a2521d53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1174196370d930c9fff6b471a2521d53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_min_fxn_at_level</b> (int level, uli minfxn)</td></tr>
<tr class="separator:a1174196370d930c9fff6b471a2521d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9f4edfe3f6a0e5c687ebe7d3e93897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd9f4edfe3f6a0e5c687ebe7d3e93897"></a>
uli&#160;</td><td class="memItemRight" valign="bottom"><b>max_fxn_per_tile</b> () const </td></tr>
<tr class="separator:acd9f4edfe3f6a0e5c687ebe7d3e93897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade35ed165508e6ab0271c61382426898"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade35ed165508e6ab0271c61382426898"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_max_fxn_per_tile</b> (uli n)</td></tr>
<tr class="separator:ade35ed165508e6ab0271c61382426898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc05112e7bcee084fd3bc40c95b65cb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#acc05112e7bcee084fd3bc40c95b65cb2">set_sizecheck_all</a> (bool szchk=true)</td></tr>
<tr class="separator:acc05112e7bcee084fd3bc40c95b65cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b58a337de3c3cb12339ed687d6e4da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a02b58a337de3c3cb12339ed687d6e4da">set_sizecheck</a> (int trait)</td></tr>
<tr class="separator:a02b58a337de3c3cb12339ed687d6e4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fd6193bc0ffe95a740b92cd367fa10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a71fd6193bc0ffe95a740b92cd367fa10">unset_sizecheck</a> (int trait)</td></tr>
<tr class="separator:a71fd6193bc0ffe95a740b92cd367fa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25154e007bf9ca00226f9bfa578c8f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a25154e007bf9ca00226f9bfa578c8f19">set_sort_priority</a> (std::vector&lt; PartitionableTrait &gt; sort_importance)</td></tr>
<tr class="separator:a25154e007bf9ca00226f9bfa578c8f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0162fffad50139fe34dd3b4f02bae3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#aca0162fffad50139fe34dd3b4f02bae3">set_sort_priority</a> (int item0, int item1=-1, int item2=-1, int item3=-1, int item4=-1, int item5=-1, int item6=-1, int item7=-1, int item8=-1, int item9=-1)</td></tr>
<tr class="separator:aca0162fffad50139fe34dd3b4f02bae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsmartptr_1_1Countable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsmartptr_1_1Countable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsmartptr_1_1Countable.html">smartptr::Countable</a></td></tr>
<tr class="memitem:a5a209cd39027761530fbe89b5f0e7ee3 inherit pub_methods_classsmartptr_1_1Countable"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmartptr_1_1Countable.html#a5a209cd39027761530fbe89b5f0e7ee3">incref</a> ()</td></tr>
<tr class="separator:a5a209cd39027761530fbe89b5f0e7ee3 inherit pub_methods_classsmartptr_1_1Countable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4898a3a0e450ff0b831f12107b89280a inherit pub_methods_classsmartptr_1_1Countable"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmartptr_1_1Countable.html#a4898a3a0e450ff0b831f12107b89280a">decref</a> ()</td></tr>
<tr class="separator:a4898a3a0e450ff0b831f12107b89280a inherit pub_methods_classsmartptr_1_1Countable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ee8a4bf56b76c50f587273e4758101 inherit pub_methods_classsmartptr_1_1Countable"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmartptr_1_1Countable.html#a34ee8a4bf56b76c50f587273e4758101">nref</a> () const </td></tr>
<tr class="separator:a34ee8a4bf56b76c50f587273e4758101 inherit pub_methods_classsmartptr_1_1Countable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab42f8286a638366f48018ce93073336c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab42f8286a638366f48018ce93073336c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>build_sort_importance</b> ()</td></tr>
<tr class="separator:ab42f8286a638366f48018ce93073336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1482f0cb5f032836c6321838d55f7b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1482f0cb5f032836c6321838d55f7b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_sort_importance</b> ()</td></tr>
<tr class="separator:aa1482f0cb5f032836c6321838d55f7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aec3be4f72ae9f88f13f9238b7a1a46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0aec3be4f72ae9f88f13f9238b7a1a46"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="separator:a0aec3be4f72ae9f88f13f9238b7a1a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a806e590265426a85376c482b89fe200f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a806e590265426a85376c482b89fe200f"></a>
static std::vector<br class="typebreak"/>
&lt; PartitionableTrait &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split_traits</b> (int item)</td></tr>
<tr class="separator:a806e590265426a85376c482b89fe200f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7a0929c2c07d0f817bfafc415e22ce9b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a7a0929c2c07d0f817bfafc415e22ce9b">levels_</a></td></tr>
<tr class="separator:a7a0929c2c07d0f817bfafc415e22ce9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7f51146586b8ee4cd69c54d6a1f5c1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PartitionableTrait &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#add7f51146586b8ee4cd69c54d6a1f5c1">sort_importance_</a></td></tr>
<tr class="separator:add7f51146586b8ee4cd69c54d6a1f5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11500d6e176d4b7e86d026a7a0677689"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a11500d6e176d4b7e86d026a7a0677689">sizecheck_traits_</a></td></tr>
<tr class="separator:a11500d6e176d4b7e86d026a7a0677689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf274b1dca0fd76942748fc85b03f2ed"><td class="memItemLeft" align="right" valign="top">uli *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#aaf274b1dca0fd76942748fc85b03f2ed">min_fxn_at_level_</a></td></tr>
<tr class="separator:aaf274b1dca0fd76942748fc85b03f2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb46e93641110351df59ccbce395618"><td class="memItemLeft" align="right" valign="top">uli&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a2fb46e93641110351df59ccbce395618">max_fxn_per_tile_</a></td></tr>
<tr class="separator:a2fb46e93641110351df59ccbce395618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c5d275819cfd207b2502b9d2aa8bfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#ae5c5d275819cfd207b2502b9d2aa8bfd">nfxn_min_per_tile_</a></td></tr>
<tr class="separator:ae5c5d275819cfd207b2502b9d2aa8bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f3771a1ca0970c2610bae1d21213bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyeti_1_1PartitioningPolicy.html#a19f3771a1ca0970c2610bae1d21213bd">nidx_min_per_tile_</a></td></tr>
<tr class="separator:a19f3771a1ca0970c2610bae1d21213bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad5c053ab2bc1a1247e55bb6584efc67b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PartitioningPolicy::set_min_fxn_per_tile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setter function for <a class="el" href="classyeti_1_1PartitioningPolicy.html#ae5c5d275819cfd207b2502b9d2aa8bfd">PartitioningPolicy::nfxn_min_per_tile_</a>. This function also sets min_fxn_at_level_[0] and min_fxn_at_level[i] if the previously specified value (or if unspecified) is less than the parameter given. </p>

</div>
</div>
<a class="anchor" id="a02b58a337de3c3cb12339ed687d6e4da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PartitioningPolicy::set_sizecheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the trait to be size-checked. Note that you can use bitwise OR'd values here, but only if the traits are on the same level. Make multiple to set multiple levels. </p>

</div>
</div>
<a class="anchor" id="acc05112e7bcee084fd3bc40c95b65cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PartitioningPolicy::set_sizecheck_all </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>szchk</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the parameter given is true or no parameter is given, all traits are set to be size-checked. If the parameter given is false, no parameters are size-checked. Either way, any previous size-checked settings are obliterated. </p>

</div>
</div>
<a class="anchor" id="a25154e007bf9ca00226f9bfa578c8f19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yeti::PartitioningPolicy::set_sort_priority </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PartitionableTrait &gt;&#160;</td>
          <td class="paramname"><em>sort_importance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="classyeti_1_1PartitioningPolicy.html#aca0162fffad50139fe34dd3b4f02bae3">set_sort_priority(int, int, int, int, int, int, int, int, int, int)</a> </p>

</div>
</div>
<a class="anchor" id="aca0162fffad50139fe34dd3b4f02bae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PartitioningPolicy::set_sort_priority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item1</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item2</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item3</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item4</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item5</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item6</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item7</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item8</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item9</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the contents of thesort priority of the traits. Traits not in the levels_ vector may be included and bitwise OR'd values are allowed, however the sort priority must at least include all traits from the levels_ vector, with the traits from higher levels coming <em>before</em> the traits from lower levels (failure to do so will result in a runtime error). If a bitwise OR'd value is given, the order of the OR'd values is not specified (though it is deterministic; see source code) and should not be relied upon (i. e. this ordering may change in the future). Only give bitwise OR'd values if it really does not matter what order the sorting is carried out in relative to these traits. The sort priority will cause the <a class="el" href="classyeti_1_1PartitioningPolicy_1_1LessThanComparator.html">PartitioningPolicy::LessThanComparator</a> functor to first compare based on item0, then item1, then item2, and so on (up to 9 traits may be specified here, which is more than the number of traits currently available in the enumerated type PartitionableTrait, so you should be okay; if you need more for whatever reason, there is also a version that takes a std::vector of PartitionableTrait values). </p>

</div>
</div>
<a class="anchor" id="a14fa6e340a6ce759c2c9a2807c517474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PartitioningPolicy::sort_shells </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ShellPtr &gt; &amp;&#160;</td>
          <td class="paramname"><em>shells</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the shells according to the specified sort priority associated with the <a class="el" href="classyeti_1_1PartitioningPolicy.html">PartitioningPolicy</a> instance for which the method is called. See also <a class="el" href="classyeti_1_1PartitioningPolicy.html#a25154e007bf9ca00226f9bfa578c8f19">PartitioningPolicy::set_sort_priority</a> and <a class="el" href="classyeti_1_1PartitioningPolicy.html#add7f51146586b8ee4cd69c54d6a1f5c1">PartitioningPolicy::sort_importance_</a> </p>

</div>
</div>
<a class="anchor" id="a71fd6193bc0ffe95a740b92cd367fa10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PartitioningPolicy::unset_sizecheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to set_sizecheck </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7a0929c2c07d0f817bfafc415e22ce9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; yeti::PartitioningPolicy::levels_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Describes the various levels of partitioning. levels_[0] corresponds to depth = 1 (so the tree structure is inverted, as in the rest of the Yeti suite) </p>

</div>
</div>
<a class="anchor" id="a2fb46e93641110351df59ccbce395618"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uli yeti::PartitioningPolicy::max_fxn_per_tile_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum number of functions per data tile. After the splitting [see AOBasis::configure(PartitioningPolicyPtr)] is completed, ranges at the data level (level = 0, a.k.a. depth = 1) are checked to see if they contain more than the maximum number of basis functions specified. If so, and if splitting would not cause the number to fall below min_fxn_at_level_[0], the data block is split into blocks as evenly sized as possible (with as few splits as possible to get the number below the max_fxn_per_tile_ value. </p>

</div>
</div>
<a class="anchor" id="aaf274b1dca0fd76942748fc85b03f2ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uli* yeti::PartitioningPolicy::min_fxn_at_level_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After the splitting [see AOBasis::configure(PartitioningPolicyPtr)] is completed, ranges at each level are checked to see if they contain the minimum number of functions specified for that level. If not, yeti will <em>try</em> to combine ranges at that level to get above the minimum. However, it will not combine ranges with different parents unless the parents' level's minimum function value is less that the functions (not indices or shells, basis functions) in that level, in which case the neighboring parents will be merged and the merge will be propagated down. The merge will also only take place if the merged data tile's size is less than max_fxn_per_tile_ (or if max_fxn_per_tile_ is &lt; 1, which turns off that particular feature) </p>

</div>
</div>
<a class="anchor" id="ae5c5d275819cfd207b2502b9d2aa8bfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int yeti::PartitioningPolicy::nfxn_min_per_tile_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This value affects the partitioning or lack there of with respect to the sizecheck_traits_ vector at the data level (level = 0, a.k.a. depth = 1). At this point it is exactly equivalent to min_fxn_at_level_[0]. </p>

</div>
</div>
<a class="anchor" id="a19f3771a1ca0970c2610bae1d21213bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int yeti::PartitioningPolicy::nidx_min_per_tile_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same concept as <a class="el" href="classyeti_1_1PartitioningPolicy.html#ae5c5d275819cfd207b2502b9d2aa8bfd">PartitioningPolicy::nfxn_min_per_tile_</a>, except this counts indices at levels higher than the data level. </p>

</div>
</div>
<a class="anchor" id="a11500d6e176d4b7e86d026a7a0677689"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; yeti::PartitioningPolicy::sizecheck_traits_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a list of traits (which can be bitwise OR'd) at each level that only cause partitioning to occur if there are at least nfxn_min_per_tile_ functions in the tile (at depth = 1) or nidx_min_per_tile indices in a metadata tile (at depth &gt; 1) </p>

</div>
</div>
<a class="anchor" id="add7f51146586b8ee4cd69c54d6a1f5c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;PartitionableTrait&gt; yeti::PartitioningPolicy::sort_importance_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This defaults to the same as levels_, but offers some finer-grained control in cases where the user wishes to combine traits in one level but still specify an order of importance in sorting that level. Note that these values cannot be bitwise OR'd </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="aobasis_8h_source.html">aobasis.h</a></li>
<li>aobasis.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
