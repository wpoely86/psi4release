<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>PSI: psi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PSI
   &#160;<span id="projectnumber">4.0.0-beta5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">psi Namespace Reference<div class="ingroups"><a class="el" href="group__QT.html">libqt: The Quantum-Trio Miscellaneous Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Rotate a set of vectors around an arbitrary axis Vectors are rows of input matrix.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CholeskyMatrix.html">CholeskyMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CholeskyERI.html">CholeskyERI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CholeskyMP2.html">CholeskyMP2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CholeskyDelta.html">CholeskyDelta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CholeskyLocal.html">CholeskyLocal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Denominator.html">Denominator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1LaplaceDenominator.html">LaplaceDenominator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CholeskyDenominator.html">CholeskyDenominator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SAPTDenominator.html">SAPTDenominator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SAPTLaplaceDenominator.html">SAPTLaplaceDenominator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SAPTCholeskyDenominator.html">SAPTCholeskyDenominator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1TLaplaceDenominator.html">TLaplaceDenominator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1FittingMetric.html">FittingMetric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DFTensor.html">DFTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DFChargeFitter.html">DFChargeFitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DealiasBasisSet.html">DealiasBasisSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PSTensorII.html">PSTensorII</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PSTensor.html">PSTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PseudoTrial.html">PseudoTrial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1QR.html">QR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SchwarzSieve.html">SchwarzSieve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Chkpt.html">Chkpt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DIISEntry.html">DIISEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DIISManager.html">DIISManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Dispersion.html">Dispersion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpdparams4.html">dpdparams4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpdfile4.html">dpdfile4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpdshift4.html">dpdshift4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpdbuf4.html">dpdbuf4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpdtrans4.html">dpdtrans4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpdparams2.html">dpdparams2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpdfile2.html">dpdfile2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpd__file4__cache__entry.html">dpd_file4_cache_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpd__file2__cache__entry.html">dpd_file2_cache_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpd__data.html">dpd_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1thread__data.html">thread_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpd__gbl.html">dpd_gbl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DPD.html">DPD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1dpdpair.html">dpdpair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RBase.html">RBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RCIS.html">RCIS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RTDHF.html">RTDHF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RCPHF.html">RCPHF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RCPKS.html">RCPKS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RTDA.html">RTDA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RTDDFT.html">RTDDFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RadialPruneMgr.html">RadialPruneMgr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1MassPoint.html">MassPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MolecularGrid.html">MolecularGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PseudospectralGrid.html">PseudospectralGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DFTGrid.html">DFTGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RadialGrid.html">RadialGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SphericalGrid.html">SphericalGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1BlockOPoints.html">BlockOPoints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1BasisExtents.html">BasisExtents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DirectScreening.html">DirectScreening</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1GridBlocker.html">GridBlocker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1NaiveGridBlocker.html">NaiveGridBlocker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1OctreeGridBlocker.html">OctreeGridBlocker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Hamiltonian.html">Hamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RHamiltonian.html">RHamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1UHamiltonian.html">UHamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MatrixRHamiltonian.html">MatrixRHamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MatrixUHamiltonian.html">MatrixUHamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CISRHamiltonian.html">CISRHamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1TDHFRHamiltonian.html">TDHFRHamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CPHFRHamiltonian.html">CPHFRHamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1TDARHamiltonian.html">TDARHamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1TDDFTRHamiltonian.html">TDDFTRHamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CPKSRHamiltonian.html">CPKSRHamiltonian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1JK.html">JK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DiskJK.html">DiskJK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PKJK.html">PKJK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DirectJK.html">DirectJK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DFJK.html">DFJK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CDJK.html">CDJK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1FastDFJK.html">FastDFJK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1JKIndependent.html">JKIndependent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1LinK.html">LinK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1BasisFunctions.html">BasisFunctions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PointFunctions.html">PointFunctions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RKSFunctions.html">RKSFunctions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1UKSFunctions.html">UKSFunctions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Solver.html">Solver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RSolver.html">RSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1USolver.html">USolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CGRSolver.html">CGRSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DLRSolver.html">DLRSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RayleighRSolver.html">RayleighRSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DLRXSolver.html">DLRXSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1VBase.html">VBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RV.html">RV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1UV.html">UV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RK.html">RK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1UK.html">UK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CFunctional.html">CFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1FT97__CFunctional.html">FT97_CFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1FT97B__XFunctional.html">FT97B_XFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Functional.html">Functional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1LYP__CFunctional.html">LYP_CFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1NAMEFunctional.html">NAMEFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1P86__CFunctional.html">P86_CFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PBE__CFunctional.html">PBE_CFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PW91__CFunctional.html">PW91_CFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PW92__CFunctional.html">PW92_CFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PZ81__CFunctional.html">PZ81_CFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SuperFunctional.html">SuperFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1VWN3__CFunctional.html">VWN3_CFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1VWN5__CFunctional.html">VWN5_CFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1wPBECFunctional.html">wPBECFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1wPBEXFunctional.html">wPBEXFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1XFunctional.html">XFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1IWL.html">IWL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ThreeCenterOverlapInt.html">ThreeCenterOverlapInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three center overlap integral.  <a href="classpsi_1_1ThreeCenterOverlapInt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1AngularMomentumInt.html">AngularMomentumInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1BasisSet.html">BasisSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis set container class.  <a href="classpsi_1_1BasisSet.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1BasisSetFileNotFound.html">BasisSetFileNotFound</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1BasisSetNotFound.html">BasisSetNotFound</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1BasisSetParser.html">BasisSetParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for parsing basis sets from a text file.  <a href="classpsi_1_1BasisSetParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Gaussian94BasisSetParser.html">Gaussian94BasisSetParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading in basis sets formatted for Gaussian.  <a href="classpsi_1_1Gaussian94BasisSetParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CartesianIter.html">CartesianIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RedundantCartesianIter.html">RedundantCartesianIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RedundantCartesianSubIter.html">RedundantCartesianSubIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CdSalc.html">CdSalc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CdSalcWRTAtom.html">CdSalcWRTAtom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CdSalcList.html">CdSalcList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CoordValue.html">CoordValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1NumberValue.html">NumberValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1VariableValue.html">VariableValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CoordEntry.html">CoordEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CartesianEntry.html">CartesianEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ZMatrixEntry.html">ZMatrixEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CorrelationTable.html">CorrelationTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CubeFile.html">CubeFile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CorrelatedFunctor.html">CorrelatedFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ScfRestrictedFunctor.html">ScfRestrictedFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ScfAndDfCorrelationRestrictedFunctor.html">ScfAndDfCorrelationRestrictedFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ScfUnrestrictedFunctor.html">ScfUnrestrictedFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Deriv.html">Deriv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Dimension.html">Dimension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DipoleInt.html">DipoleInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes dipole integrals.  <a href="classpsi_1_1DipoleInt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1EFPMultipolePotentialInt.html">EFPMultipolePotentialInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ElectricFieldInt.html">ElectricFieldInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes electric field integrals.  <a href="classpsi_1_1ElectricFieldInt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ElectrostaticInt.html">ElectrostaticInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1ShellPair__typ.html">ShellPair_typ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1TwoElectronInt.html">TwoElectronInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ERI.html">ERI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capable of computing two-electron repulsion integrals.  <a href="classpsi_1_1ERI.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1F12.html">F12</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1F12Squared.html">F12Squared</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1F12G12.html">F12G12</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1F12DoubleCommutator.html">F12DoubleCommutator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ErfERI.html">ErfERI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ErfComplementERI.html">ErfComplementERI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ExternalPotential.html">ExternalPotential</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MatrixFactory.html">MatrixFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for creating <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a>, SimpleMatrix, <a class="el" href="classpsi_1_1Vector.html">Vector</a>, and SimpleVector objects.  <a href="classpsi_1_1MatrixFactory.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Fjt.html">Fjt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Boys function F_j(T)  <a href="classpsi_1_1Fjt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Taylor__Fjt.html">Taylor_Fjt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses Taylor interpolation of up to 8-th order to compute the Boys function.  <a href="classpsi_1_1Taylor__Fjt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1FJT.html">FJT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1GaussianFundamental.html">GaussianFundamental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1F12Fundamental.html">F12Fundamental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1F12SquaredFundamental.html">F12SquaredFundamental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1F12G12Fundamental.html">F12G12Fundamental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1F12DoubleCommutatorFundamental.html">F12DoubleCommutatorFundamental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ErfFundamental.html">ErfFundamental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ErfComplementFundamental.html">ErfComplementFundamental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1GridBlock.html">GridBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration Point/Weight container class (blocks, not individual)  <a href="classpsi_1_1GridBlock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CubicScalarGrid.html">CubicScalarGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ShellInfo.html">ShellInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class has the same behavior as <a class="el" href="classpsi_1_1GaussianShell.html" title="Gaussian orbital shell.">GaussianShell</a>, but implements everything using slower data structures, which are easier to construct. These are used to build the basis set, which builds more efficient pointer-based <a class="el" href="classpsi_1_1GaussianShell.html" title="Gaussian orbital shell.">GaussianShell</a> objects.  <a href="classpsi_1_1ShellInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1GaussianShell.html">GaussianShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian orbital shell.  <a href="classpsi_1_1GaussianShell.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SphericalTransformComponent.html">SphericalTransformComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SphericalTransform.html">SphericalTransform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ISphericalTransform.html">ISphericalTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This describes a solid harmonic to Cartesian transformation.  <a href="classpsi_1_1ISphericalTransform.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SphericalTransformIter.html">SphericalTransformIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1AOIntegralsIterator.html">AOIntegralsIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1AOShellCombinationsIterator.html">AOShellCombinationsIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SOShellCombinationsIterator.html">SOShellCombinationsIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SO__PQ__Iterator.html">SO_PQ_Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SO__RS__Iterator.html">SO_RS_Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1IntegralFactory.html">IntegralFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1IntegralParameters.html">IntegralParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CorrelationFactor.html">CorrelationFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1FittedSlaterCorrelationFactor.html">FittedSlaterCorrelationFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1KineticInt.html">KineticInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes kinetic integrals.  <a href="classpsi_1_1KineticInt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Localizer.html">Localizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1BoysLocalizer.html">BoysLocalizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PMLocalizer.html">PMLocalizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes using matrices just a little easier.  <a href="classpsi_1_1Matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1IWLWriter.html">IWLWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MintsHelper.html">MintsHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Molecule.html">Molecule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpsi_1_1Molecule.html" title="Molecule information class.">Molecule</a> information class.  <a href="classpsi_1_1Molecule.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MultipoleInt.html">MultipoleInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes arbitrary-order multipole integrals.  <a href="classpsi_1_1MultipoleInt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1OperatorSymmetry.html">OperatorSymmetry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MultipoleSymmetry.html">MultipoleSymmetry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1NablaInt.html">NablaInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Prop.html">Prop</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1OEProp.html">OEProp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1OneBodyAOInt.html">OneBodyAOInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1OrbitalSpace.html">OrbitalSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpsi_1_1OrbitalSpace.html" title="The OrbitalSpace class.">OrbitalSpace</a> class.  <a href="classpsi_1_1OrbitalSpace.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1OverlapOrthog.html">OverlapOrthog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ObaraSaikaTwoCenterRecursion.html">ObaraSaikaTwoCenterRecursion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Obara and Saika recursion object.  <a href="classpsi_1_1ObaraSaikaTwoCenterRecursion.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ObaraSaikaTwoCenterMIRecursion.html">ObaraSaikaTwoCenterMIRecursion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obara and Saika recursion object for moment integrals. Currently not used by <a class="el" href="classpsi_1_1DipoleInt.html" title="Computes dipole integrals.">DipoleInt</a>, hopefully soon. THIS CLASS HAS NOT BEEN TESTED!!!  <a href="classpsi_1_1ObaraSaikaTwoCenterMIRecursion.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ObaraSaikaTwoCenterVIRecursion.html">ObaraSaikaTwoCenterVIRecursion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obara and Saika recursion object for potential integrals.  <a href="classpsi_1_1ObaraSaikaTwoCenterVIRecursion.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ObaraSaikaTwoCenterVIDerivRecursion.html">ObaraSaikaTwoCenterVIDerivRecursion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obara and Saika recursion object for computing potential derivatives.  <a href="classpsi_1_1ObaraSaikaTwoCenterVIDerivRecursion.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ObaraSaikaTwoCenterVIDeriv2Recursion.html">ObaraSaikaTwoCenterVIDeriv2Recursion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ObaraSaikaTwoCenterElectricField.html">ObaraSaikaTwoCenterElectricField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obara and Saika recursion object for computing electric field integrals.  <a href="classpsi_1_1ObaraSaikaTwoCenterElectricField.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ObaraSaikaTwoCenterElectricFieldGradient.html">ObaraSaikaTwoCenterElectricFieldGradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obara and Saika recursion object for computing electric field gradient integrals.  <a href="classpsi_1_1ObaraSaikaTwoCenterElectricFieldGradient.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ObaraSaikaTwoCenterEFPRecursion.html">ObaraSaikaTwoCenterEFPRecursion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obara and Saika recursion object for potential integrals, and electric derivatives thereof, required in EFP.  <a href="classpsi_1_1ObaraSaikaTwoCenterEFPRecursion.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ObaraSaikaThreeCenterRecursion.html">ObaraSaikaThreeCenterRecursion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1OverlapInt.html">OverlapInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class computes overlap integrals and soon overlap integral derivatives. Use an <a class="el" href="classpsi_1_1IntegralFactory.html">IntegralFactory</a> to create this object.  <a href="classpsi_1_1OverlapInt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1lin__comb.html">lin_comb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1contribution.html">contribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1SO.html">SO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1SO__block.html">SO_block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1SOCoefficients.html">SOCoefficients</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PetiteList.html">PetiteList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SymmetryOperation.html">SymmetryOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SymRep.html">SymRep</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1IrreducibleRepresentation.html">IrreducibleRepresentation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CharacterTable.html">CharacterTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PointGroup.html">PointGroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PotentialInt.html">PotentialInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes potential integrals. Use an <a class="el" href="classpsi_1_1IntegralFactory.html">IntegralFactory</a> to create this object.  <a href="classpsi_1_1PotentialInt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PotentialSOInt.html">PotentialSOInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PCMPotentialInt.html">PCMPotentialInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PrintIntegralsFunctor.html">PrintIntegralsFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ContractOverDensityFunctor.html">ContractOverDensityFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ContractOverChargesFunctor.html">ContractOverChargesFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PseudospectralInt.html">PseudospectralInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PyBuffer.html">PyBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thin wrapper to the NumPy array interface.  <a href="classpsi_1_1PyBuffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1QuadrupoleInt.html">QuadrupoleInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes quadrupole integrals. At last check this may not be working. Use an <a class="el" href="classpsi_1_1IntegralFactory.html">IntegralFactory</a> to create this object.  <a href="classpsi_1_1QuadrupoleInt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ShellRotation.html">ShellRotation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ERISieve.html">ERISieve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SOTransformFunction.html">SOTransformFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1AOTransformFunction.html">AOTransformFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SOTransformShell.html">SOTransformShell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SOTransform.html">SOTransform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1AOTransform.html">AOTransform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SOBasisSet.html">SOBasisSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1OneBodySOInt.html">OneBodySOInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1TwoBodySOInt.html">TwoBodySOInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1TracelessQuadrupoleInt.html">TracelessQuadrupoleInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes quadrupole integrals. At last check this may not be working. Use an <a class="el" href="classpsi_1_1IntegralFactory.html">IntegralFactory</a> to create this object.  <a href="classpsi_1_1TracelessQuadrupoleInt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1TwoBodyAOInt.html">TwoBodyAOInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Vector.html">Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1IntVector.html">IntVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Vector3.html">Vector3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1View.html">View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a view to a region of the matrix.  <a href="classpsi_1_1View.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Wavefunction.html">Wavefunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wavefunction base class.  <a href="classpsi_1_1Wavefunction.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1GradientWriter.html">GradientWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MoldenWriter.html">MoldenWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MOWriter.html">MOWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1NBOWriter.html">NBOWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ModelSpace.html">ModelSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MOInfo.html">MOInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MOInfoBase.html">MOInfoBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MOInfoSCF.html">MOInfoSCF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SlaterDeterminant.html">SlaterDeterminant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DataTypeException.html">DataTypeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1IndexException.html">IndexException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DuplicateKeyException.html">DuplicateKeyException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1OptionsException.html">OptionsException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DataType.html">DataType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1BooleanDataType.html">BooleanDataType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1IntDataType.html">IntDataType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DoubleDataType.html">DoubleDataType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1StringDataType.html">StringDataType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1IStringDataType.html">IStringDataType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Data.html">Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ArrayType.html">ArrayType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MapType.html">MapType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Options.html">Options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PythonDataType.html">PythonDataType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1LocalCommWrapper.html">LocalCommWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Serializable.html">Serializable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1threaded__storage.html">threaded_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1plugin__info__struct.html">plugin_info_struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1AIOHandler.html">AIOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1psio__address.html">psio_address</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1psio__vol.html">psio_vol</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1psio__entry.html">psio_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1psio__ud.html">psio_ud</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PSIOManager.html">PSIOManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PSIO.html">PSIO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1String.html">String</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1StringSet.html">StringSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1SlaterDet.html">SlaterDet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1timer.html">timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1LaplaceDenom.html">LaplaceDenom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1LRERI.html">LRERI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DFERI.html">DFERI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1LSTHCERI.html">LSTHCERI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1THCE.html">THCE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Tensor.html">Tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1CoreTensor.html">CoreTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DiskTensor.html">DiskTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1THCEW.html">THCEW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1RTHCEW.html">RTHCEW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1IntegralTransform.html">IntegralTransform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1FrozenCoreAndFockRestrictedFunctor.html">FrozenCoreAndFockRestrictedFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1FrozenCoreAndFockUnrestrictedFunctor.html">FrozenCoreAndFockUnrestrictedFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1DPDFillerFunctor.html">DPDFillerFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1NullFunctor.html">NullFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MOSpace.html">MOSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Timer.html">Timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsi_1_1AllocationEntry.html">AllocationEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MemoryManager.html">MemoryManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Quadrature.html">Quadrature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ChebyshevIIQuadrature.html">ChebyshevIIQuadrature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1StandardObjectPolicy.html">StandardObjectPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1StandardArrayPolicy.html">StandardArrayPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SimpleReferenceCount.html">SimpleReferenceCount</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Ref.html">Ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1AtomicDensity.html">AtomicDensity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1StockholderDensity.html">StockholderDensity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>PluginFileManager</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Script.html">Script</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Python.html">Python</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Element__to__Z.html">Element_to_Z</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1PsiException.html">PsiException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1NotImplementedException__.html">NotImplementedException_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SanityCheckError.html">SanityCheckError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1SystemError.html">SystemError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1FeatureNotImplemented.html">FeatureNotImplemented</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1LimitExceeded.html">LimitExceeded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1StepSizeError.html">StepSizeError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MaxIterationsExceeded.html">MaxIterationsExceeded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ConvergenceError.html">ConvergenceError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1ResourceAllocationError.html">ResourceAllocationError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1InputException.html">InputException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1MolecularSystem.html">MolecularSystem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsi_1_1Process.html">Process</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afb1523bc4f6f7b8c77e5ad6766354c73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb1523bc4f6f7b8c77e5ad6766354c73"></a>
typedef short int&#160;</td><td class="memItemRight" valign="bottom"><b>Label</b></td></tr>
<tr class="separator:afb1523bc4f6f7b8c77e5ad6766354c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313ce7ffba11465f1918776d36ef4aaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a313ce7ffba11465f1918776d36ef4aaa"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>Value</b></td></tr>
<tr class="separator:a313ce7ffba11465f1918776d36ef4aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga991fafd4711ac93b9cf90a59464247c1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpsi_1_1ShellPair__typ.html">psi::ShellPair_typ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MINTS.html#ga991fafd4711ac93b9cf90a59464247c1">ShellPair</a></td></tr>
<tr class="separator:ga991fafd4711ac93b9cf90a59464247c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33696c828e53021244375489e232af3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae33696c828e53021244375489e232af3"></a>
typedef <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classpsi_1_1GridBlock.html">GridBlock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedGridBlock</b></td></tr>
<tr class="separator:ae33696c828e53021244375489e232af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8946f1ea29c43297031e0107803a2dd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8946f1ea29c43297031e0107803a2dd6"></a>
typedef <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classpsi_1_1Molecule.html">Molecule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedMolecule</b></td></tr>
<tr class="separator:a8946f1ea29c43297031e0107803a2dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fdfb2f4d8a83de537c1f0b41e0f929"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05fdfb2f4d8a83de537c1f0b41e0f929"></a>
typedef <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classpsi_1_1OneBodyAOInt.html">OneBodyAOInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedOneBodyAOInt</b></td></tr>
<tr class="separator:a05fdfb2f4d8a83de537c1f0b41e0f929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaff3311028211a095bff0600b8ab8f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaff3311028211a095bff0600b8ab8f2"></a>
typedef <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classpsi_1_1OneBodySOInt.html">OneBodySOInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedOneBodySOInt</b></td></tr>
<tr class="separator:afaff3311028211a095bff0600b8ab8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae24289d32aeba50fbc7df6bf4e53ff6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae24289d32aeba50fbc7df6bf4e53ff6"></a>
typedef <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classpsi_1_1TwoBodySOInt.html">TwoBodySOInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedTwoBodySOInt</b></td></tr>
<tr class="separator:aae24289d32aeba50fbc7df6bf4e53ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a446bf0a1e582075501dfbc7dbcd55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04a446bf0a1e582075501dfbc7dbcd55"></a>
typedef <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classpsi_1_1TwoBodyAOInt.html">TwoBodyAOInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedTwoBodyAOInt</b></td></tr>
<tr class="separator:a04a446bf0a1e582075501dfbc7dbcd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3363b2c15490574e4749f895444fe17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3363b2c15490574e4749f895444fe17"></a>
typedef <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classpsi_1_1Matrix.html">psi::Matrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedMatrix</b></td></tr>
<tr class="separator:ad3363b2c15490574e4749f895444fe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37674c473b79a5631b70956e966c41bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37674c473b79a5631b70956e966c41bf"></a>
typedef <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classpsi_1_1Vector.html">psi::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedVector</b></td></tr>
<tr class="separator:a37674c473b79a5631b70956e966c41bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713f6db6ed37a43e78e2f17c523eb3f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a713f6db6ed37a43e78e2f17c523eb3f2"></a>
typedef <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedIntVector</b></td></tr>
<tr class="separator:a713f6db6ed37a43e78e2f17c523eb3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb697190bdb074bca257507e3cc3ea2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bb697190bdb074bca257507e3cc3ea2"></a>
typedef PsiReturnType(*&#160;</td><td class="memItemRight" valign="bottom"><b>plugin_t</b> )(<a class="el" href="classpsi_1_1Options.html">Options</a> &amp;)</td></tr>
<tr class="separator:a1bb697190bdb074bca257507e3cc3ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720ebef395a4b1d19a54c19244d04a10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a720ebef395a4b1d19a54c19244d04a10"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>read_options_t</b> )(std::string, <a class="el" href="classpsi_1_1Options.html">Options</a> &amp;)</td></tr>
<tr class="separator:a720ebef395a4b1d19a54c19244d04a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36e02ec0317e412de593d063931127e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af36e02ec0317e412de593d063931127e"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>init_plugin_t</b> )()</td></tr>
<tr class="separator:af36e02ec0317e412de593d063931127e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955c33d763ad7957886c98b2556ed40c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a955c33d763ad7957886c98b2556ed40c"></a>
typedef struct <br class="typebreak"/>
<a class="el" href="structpsi_1_1plugin__info__struct.html">psi::plugin_info_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><b>plugin_info</b></td></tr>
<tr class="separator:a955c33d763ad7957886c98b2556ed40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421bc069620e550691b65451a846c965"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a421bc069620e550691b65451a846c965"></a>
typedef unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><b>ULI</b></td></tr>
<tr class="separator:a421bc069620e550691b65451a846c965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e3a236506387bad7a5664e8ff914fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8e3a236506387bad7a5664e8ff914fa"></a>
typedef struct <a class="el" href="structpsi_1_1psio__entry.html">psi::psio_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><b>psio_tocentry</b></td></tr>
<tr class="separator:ab8e3a236506387bad7a5664e8ff914fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2d172708ebbb8a6d3236cf23ecec06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b2d172708ebbb8a6d3236cf23ecec06"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1MOSpace.html">MOSpace</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SpaceVec</b></td></tr>
<tr class="separator:a6b2d172708ebbb8a6d3236cf23ecec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859a79daf3e2eb280b7c0aa54e5965ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859a79daf3e2eb280b7c0aa54e5965ff"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>strvec</b></td></tr>
<tr class="separator:a859a79daf3e2eb280b7c0aa54e5965ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a35a1045b72318870bb07e8f307bafcd8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>indices</b> { <br/>
&#160;&#160;<b>pqrs</b>, 
<b>pqsr</b>, 
<b>prqs</b>, 
<b>prsq</b>, 
<br/>
&#160;&#160;<b>psqr</b>, 
<b>psrq</b>, 
<b>qprs</b>, 
<b>qpsr</b>, 
<br/>
&#160;&#160;<b>qrps</b>, 
<b>qrsp</b>, 
<b>qspr</b>, 
<b>qsrp</b>, 
<br/>
&#160;&#160;<b>rqps</b>, 
<b>rqsp</b>, 
<b>rpqs</b>, 
<b>rpsq</b>, 
<br/>
&#160;&#160;<b>rsqp</b>, 
<b>rspq</b>, 
<b>sqrp</b>, 
<b>sqpr</b>, 
<br/>
&#160;&#160;<b>srqp</b>, 
<b>srpq</b>, 
<b>spqr</b>, 
<b>sprq</b>
<br/>
 }</td></tr>
<tr class="separator:a35a1045b72318870bb07e8f307bafcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af098d161e45e896ef4981b690030391e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>pattern</b> { <br/>
&#160;&#160;<b>abc</b>, 
<b>acb</b>, 
<b>cab</b>, 
<b>cba</b>, 
<br/>
&#160;&#160;<b>bca</b>, 
<b>bac</b>
<br/>
 }</td></tr>
<tr class="separator:af098d161e45e896ef4981b690030391e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ca4878f5158df5cd35a4a992ab99da"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>PrimitiveType</b> { <b>Normalized</b>, 
<b>Unnormalized</b>
 }</td></tr>
<tr class="separator:af9ca4878f5158df5cd35a4a992ab99da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53233d145d500aa9b5f2ff82e720e442"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>GaussianType</b> { <b>Cartesian</b> = 0, 
<b>Pure</b> = 1
 }</td></tr>
<tr class="separator:a53233d145d500aa9b5f2ff82e720e442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad603b0846ccf48c8fba6d098c77cbee7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>diagonalize_order</b> { <b>evals_only_ascending</b> = 0, 
<b>ascending</b> = 1, 
<b>evals_only_descending</b> = 2, 
<b>descending</b> = 3
 }</td></tr>
<tr class="separator:ad603b0846ccf48c8fba6d098c77cbee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c42fd351c67f48a59c9ea0ea73785d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>RotorType</b> { <br/>
&#160;&#160;<b>RT_ASYMMETRIC_TOP</b>, 
<b>RT_SYMMETRIC_TOP</b>, 
<b>RT_SPHERICAL_TOP</b>, 
<b>RT_LINEAR</b>, 
<br/>
&#160;&#160;<b>RT_ATOM</b>
<br/>
 }</td></tr>
<tr class="separator:a50c42fd351c67f48a59c9ea0ea73785d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca53d5ab4b646ffb855c453227b64e44"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>FullPointGroup</b> { <br/>
&#160;&#160;<b>PG_ATOM</b>, 
<b>PG_Cinfv</b>, 
<b>PG_Dinfh</b>, 
<b>PG_C1</b>, 
<br/>
&#160;&#160;<b>PG_Cs</b>, 
<b>PG_Ci</b>, 
<b>PG_Cn</b>, 
<b>PG_Cnv</b>, 
<br/>
&#160;&#160;<b>PG_Cnh</b>, 
<b>PG_Sn</b>, 
<b>PG_Dn</b>, 
<b>PG_Dnd</b>, 
<br/>
&#160;&#160;<b>PG_Dnh</b>, 
<b>PG_Td</b>, 
<b>PG_Oh</b>, 
<b>PG_Ih</b>
<br/>
 }</td></tr>
<tr class="separator:aca53d5ab4b646ffb855c453227b64e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a5c27c684720505e34177e53051553"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceType</b> { <b>AllRefs</b>, 
<b>UniqueRefs</b>, 
<b>ClosedShellRefs</b>, 
<b>UniqueOpenShellRefs</b>
 }</td></tr>
<tr class="separator:a09a5c27c684720505e34177e53051553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bad4a3c4b10d6f0b32e9dc59238c4ac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>PsiReturnType</b> { <b>Success</b>, 
<b>Failure</b>, 
<b>Balk</b>, 
<b>EndLoop</b>
 }</td></tr>
<tr class="separator:a2bad4a3c4b10d6f0b32e9dc59238c4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a005aa74dc233eb9c2c7d58045f09c607"><td class="memTemplParams" colspan="2"><a class="anchor" id="a005aa74dc233eb9c2c7d58045f09c607"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a005aa74dc233eb9c2c7d58045f09c607"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_string</b> (T &amp;t, const std::string &amp;s, std::ios_base &amp;(*f)(std::ios_base &amp;))</td></tr>
<tr class="separator:a005aa74dc233eb9c2c7d58045f09c607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga909b5955f68538927f8677ebc0ccac81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga909b5955f68538927f8677ebc0ccac81">add_arr</a> (double *a, double *b, double *c, int n)</td></tr>
<tr class="separator:ga909b5955f68538927f8677ebc0ccac81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf50633fdadc5ff146651bd8a953d74f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gacf50633fdadc5ff146651bd8a953d74f">add_mat</a> (double **a, double **b, double **c, int n, int m)</td></tr>
<tr class="separator:gacf50633fdadc5ff146651bd8a953d74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5342d96a20702d84857440badc8be2ec"><td class="memItemLeft" align="right" valign="top">double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga5342d96a20702d84857440badc8be2ec">block_matrix</a> (unsigned long int n, unsigned long int m, bool memlock)</td></tr>
<tr class="separator:ga5342d96a20702d84857440badc8be2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4fe42f2b28f61fece2c6d63096126e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gaeb4fe42f2b28f61fece2c6d63096126e">free_block</a> (double **array)</td></tr>
<tr class="separator:gaeb4fe42f2b28f61fece2c6d63096126e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga751089b6272243ad54ad56d3cb988835"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga751089b6272243ad54ad56d3cb988835">dot_mat</a> (double **a, double **b, int n)</td></tr>
<tr class="separator:ga751089b6272243ad54ad56d3cb988835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga954427c4da622125955f2d13e45aa9fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga954427c4da622125955f2d13e45aa9fb">dot_arr</a> (double *a, double *b, int n, double *value)</td></tr>
<tr class="separator:ga954427c4da622125955f2d13e45aa9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28cac015de0705010d8f484e69e551ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga28cac015de0705010d8f484e69e551ae">eigout</a> (double **a, double *b, double *c, int m, int n, FILE *out)</td></tr>
<tr class="separator:ga28cac015de0705010d8f484e69e551ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0ca0f24aa8a06b97225de2edd16bd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga1a0ca0f24aa8a06b97225de2edd16bd5">eigsort</a> (double *d, double **v, int n)</td></tr>
<tr class="separator:ga1a0ca0f24aa8a06b97225de2edd16bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf645901bc7c2140ffe1cdfec28b887ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gaf645901bc7c2140ffe1cdfec28b887ba">mosort</a> (double *d, double **v, int *sym, int nso, int nmo)</td></tr>
<tr class="separator:gaf645901bc7c2140ffe1cdfec28b887ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c79ee14ebc6f7fef18cfa6b7779cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gaf4c79ee14ebc6f7fef18cfa6b7779cb1">eivout</a> (double **a, double *b, int m, int n, FILE *out)</td></tr>
<tr class="separator:gaf4c79ee14ebc6f7fef18cfa6b7779cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81b278ebdf9c1fb2fae26905ff1acbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga81b278ebdf9c1fb2fae26905ff1acbfa">ffile</a> (FILE **fptr, const char *suffix, int code)</td></tr>
<tr class="separator:ga81b278ebdf9c1fb2fae26905ff1acbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a35e3396f46acf0fb3e9174b5d4c5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gad5a35e3396f46acf0fb3e9174b5d4c5e">ffile_noexit</a> (FILE **fptr, char *suffix, int code)</td></tr>
<tr class="separator:gad5a35e3396f46acf0fb3e9174b5d4c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4cbfef91d1e69f6647ffed5fd2a5f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gabb4cbfef91d1e69f6647ffed5fd2a5f7">ffileb</a> (FILE **fptr, char *suffix, int code)</td></tr>
<tr class="separator:gabb4cbfef91d1e69f6647ffed5fd2a5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb600e79949909dfb87c2d3737a94dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gadb600e79949909dfb87c2d3737a94dcc">ffileb_noexit</a> (FILE **fptr, char *suffix, int code)</td></tr>
<tr class="separator:gadb600e79949909dfb87c2d3737a94dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d09e2e2aa5a22c9800c2b4139ec23a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66d09e2e2aa5a22c9800c2b4139ec23a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ludcmp</b> (double **, int, int *, double *)</td></tr>
<tr class="separator:a66d09e2e2aa5a22c9800c2b4139ec23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fc4b47a11036527cc96b9690f1e449"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4fc4b47a11036527cc96b9690f1e449"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lubksb</b> (double **, int, int *, double *)</td></tr>
<tr class="separator:aa4fc4b47a11036527cc96b9690f1e449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd02dddc9cfd72712540c0e7a437e55d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gafd02dddc9cfd72712540c0e7a437e55d">flin</a> (double **a, double *b, int in, int im, double *det)</td></tr>
<tr class="separator:gafd02dddc9cfd72712540c0e7a437e55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35255b9a71ed5869db7c1c5507923929"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga35255b9a71ed5869db7c1c5507923929">init_array</a> (unsigned long int size)</td></tr>
<tr class="separator:ga35255b9a71ed5869db7c1c5507923929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8051e0bc66ea6a19f3c6b43b215560"><td class="memItemLeft" align="right" valign="top">double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga2c8051e0bc66ea6a19f3c6b43b215560">init_matrix</a> (unsigned long int n, unsigned long int m)</td></tr>
<tr class="separator:ga2c8051e0bc66ea6a19f3c6b43b215560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd43dc578249ac947a22aeb718940db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga1fd43dc578249ac947a22aeb718940db">free_matrix</a> (double **array, unsigned long int)</td></tr>
<tr class="separator:ga1fd43dc578249ac947a22aeb718940db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae22ab2f8c96f4c132c42cd405c805841"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gae22ab2f8c96f4c132c42cd405c805841">init_int_array</a> (int size)</td></tr>
<tr class="separator:gae22ab2f8c96f4c132c42cd405c805841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20eede3931a4c5f9fe18ab0a9a53b688"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga20eede3931a4c5f9fe18ab0a9a53b688">zero_int_array</a> (int *a, int size)</td></tr>
<tr class="separator:ga20eede3931a4c5f9fe18ab0a9a53b688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8847103aa5444911a3271169daf06294"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga8847103aa5444911a3271169daf06294">init_int_matrix</a> (int rows, int cols)</td></tr>
<tr class="separator:ga8847103aa5444911a3271169daf06294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga745c4af9d06f1793980918e23565982e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga745c4af9d06f1793980918e23565982e">free_int_matrix</a> (int **array)</td></tr>
<tr class="separator:ga745c4af9d06f1793980918e23565982e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bcb1fc3d56cd29e02af9e9ac4da01c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga92bcb1fc3d56cd29e02af9e9ac4da01c">zero_int_matrix</a> (int **array, int rows, int cols)</td></tr>
<tr class="separator:ga92bcb1fc3d56cd29e02af9e9ac4da01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ce9558f5d86218b6934e9e120d1eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gab2ce9558f5d86218b6934e9e120d1eb3">print_int_mat</a> (int **a, int m, int n, FILE *out)</td></tr>
<tr class="separator:gab2ce9558f5d86218b6934e9e120d1eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593bb1f71f0a7f55c191649a97f12735"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a593bb1f71f0a7f55c191649a97f12735"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psi_start</b> (FILE **infile, FILE **outfile, char **psi_file_prefix, int argc, char *argv[], int overwrite_output)</td></tr>
<tr class="separator:a593bb1f71f0a7f55c191649a97f12735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d5785cc3329c388b22412a646cc5038"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga6d5785cc3329c388b22412a646cc5038">psi_stop</a> (FILE *infile, FILE *outfile, char *psi_file_prefix)</td></tr>
<tr class="separator:ga6d5785cc3329c388b22412a646cc5038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899fef8f7a2601b1033a2fe1d622fc1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a899fef8f7a2601b1033a2fe1d622fc1e"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>psi_ifname</b> ()</td></tr>
<tr class="separator:a899fef8f7a2601b1033a2fe1d622fc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7eb39f56b3513ed7d0f9ab2eba7cbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d7eb39f56b3513ed7d0f9ab2eba7cbb"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>psi_ofname</b> ()</td></tr>
<tr class="separator:a4d7eb39f56b3513ed7d0f9ab2eba7cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2df13a937f7281163d8b98681995e32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2df13a937f7281163d8b98681995e32"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>psi_fprefix</b> ()</td></tr>
<tr class="separator:aa2df13a937f7281163d8b98681995e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e35129a75f6db6de7dba3b728833a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53e35129a75f6db6de7dba3b728833a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>balance</b> (double **a, int n)</td></tr>
<tr class="separator:a53e35129a75f6db6de7dba3b728833a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2b3ecdc6638b469d0e2d3bb68aa033"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb2b3ecdc6638b469d0e2d3bb68aa033"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mat_to_arr</b> (double **a, double *b, int m, int n)</td></tr>
<tr class="separator:acb2b3ecdc6638b469d0e2d3bb68aa033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf87d8219c08ae6af2dda14dd564eee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf87d8219c08ae6af2dda14dd564eee5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>arr_to_mat</b> (double **a, double *b, int m, int n)</td></tr>
<tr class="separator:abf87d8219c08ae6af2dda14dd564eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcab75421c56def41337f3b0d7efe502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gafcab75421c56def41337f3b0d7efe502">mmult</a> (double **AF, int ta, double **BF, int tb, double **CF, int tc, int nr, int nl, int nc, int add)</td></tr>
<tr class="separator:gafcab75421c56def41337f3b0d7efe502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba9bacbf72523bc02749d6738f768997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gaba9bacbf72523bc02749d6738f768997">mxmb</a> (double **a, int ia, int ja, double **b, int ib, int jb, double **c, int ic, int jc, int nrow, int nlnk, int ncol)</td></tr>
<tr class="separator:gaba9bacbf72523bc02749d6738f768997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176a03f37c3dd941a5d30be2d3614b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga176a03f37c3dd941a5d30be2d3614b58">print_array</a> (double *a, int m, FILE *out)</td></tr>
<tr class="separator:ga176a03f37c3dd941a5d30be2d3614b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86db3a2fc816b99e6b32eb307cbaa651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga86db3a2fc816b99e6b32eb307cbaa651">print_mat</a> (double **a, int rows, int cols, FILE *out)</td></tr>
<tr class="separator:ga86db3a2fc816b99e6b32eb307cbaa651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa72584deffae950af7604ff8f9f345d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gaa72584deffae950af7604ff8f9f345d9">rsp</a> (int nm, int n, int nv, double *array, double *evals, int matz, double **evecs, double toler)</td></tr>
<tr class="separator:gaa72584deffae950af7604ff8f9f345d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d6bbb5ebb9cfc28d07621acc323cf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga07d6bbb5ebb9cfc28d07621acc323cf4">sq_rsp</a> (int nm, int n, double **array, double *evals, int matz, double **evecs, double toler)</td></tr>
<tr class="separator:ga07d6bbb5ebb9cfc28d07621acc323cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fd1ca67ada496903d10056901a02f79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga5fd1ca67ada496903d10056901a02f79">sq_to_tri</a> (double **bmat, double *amat, int size)</td></tr>
<tr class="separator:ga5fd1ca67ada496903d10056901a02f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa68837842728a9bcf2f4ded0d3d512d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa68837842728a9bcf2f4ded0d3d512d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tri_to_block</b> (double *a, double **b, int num_ir, int *num_so, int *ioff)</td></tr>
<tr class="separator:afa68837842728a9bcf2f4ded0d3d512d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fcfac3857fa218079a3d4452cdb0d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70fcfac3857fa218079a3d4452cdb0d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>block_to_tri</b> (double *a, double **b, int num_ir, int *num_so, int *ioff)</td></tr>
<tr class="separator:a70fcfac3857fa218079a3d4452cdb0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9d37355ffc2930a74efb3121e96edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gacd9d37355ffc2930a74efb3121e96edc">tri_to_sq</a> (double *amat, double **bmat, int size)</td></tr>
<tr class="separator:gacd9d37355ffc2930a74efb3121e96edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9996102f35b660c8148eda7ea5b2a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gaa9996102f35b660c8148eda7ea5b2a9f">tstart</a> ()</td></tr>
<tr class="separator:gaa9996102f35b660c8148eda7ea5b2a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae474392e6a03328b747fd746b8dddb15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gae474392e6a03328b747fd746b8dddb15">tstop</a> ()</td></tr>
<tr class="separator:gae474392e6a03328b747fd746b8dddb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga683e8ba2785d12eb3a459661fc3f2b68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga683e8ba2785d12eb3a459661fc3f2b68">zero_arr</a> (double *a, int size)</td></tr>
<tr class="separator:ga683e8ba2785d12eb3a459661fc3f2b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe0e3d471a7dea06882d4c997775e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga4fe0e3d471a7dea06882d4c997775e1b">zero_mat</a> (double **a, int rows, int cols)</td></tr>
<tr class="separator:ga4fe0e3d471a7dea06882d4c997775e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04c18700d83b6b209cd8decf6830474"><td class="memItemLeft" align="right" valign="top">long int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gad04c18700d83b6b209cd8decf6830474">init_long_int_array</a> (int size)</td></tr>
<tr class="separator:gad04c18700d83b6b209cd8decf6830474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a554940d65f7f0196b5f5abeb60dce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1a554940d65f7f0196b5f5abeb60dce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zero_long_int_array</b> (long int *a, int size)</td></tr>
<tr class="separator:af1a554940d65f7f0196b5f5abeb60dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9f7ef316a86f802b9f0a81d7b610be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f9f7ef316a86f802b9f0a81d7b610be"></a>
long int **&#160;</td><td class="memItemRight" valign="bottom"><b>init_long_int_matrix</b> (int rows, int cols)</td></tr>
<tr class="separator:a5f9f7ef316a86f802b9f0a81d7b610be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5f18fe60f7f16daba21c641aa4f4db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e5f18fe60f7f16daba21c641aa4f4db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_long_int_matrix</b> (long int **array)</td></tr>
<tr class="separator:a0e5f18fe60f7f16daba21c641aa4f4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2614a24a0c64ba58d34a3f14494a739"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2614a24a0c64ba58d34a3f14494a739"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zero_long_int_matrix</b> (long int **array, int rows, int cols)</td></tr>
<tr class="separator:ad2614a24a0c64ba58d34a3f14494a739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d8c36ce48a51390dfaf48146cca230"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44d8c36ce48a51390dfaf48146cca230"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_long_int_mat</b> (long int **a, int m, int n, FILE *out)</td></tr>
<tr class="separator:a44d8c36ce48a51390dfaf48146cca230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1adcd2a0a10c293db08b5a63f159e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f1adcd2a0a10c293db08b5a63f159e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fndcor</b> (long int *maxcrb, FILE *infile, FILE *outfile)</td></tr>
<tr class="separator:a5f1adcd2a0a10c293db08b5a63f159e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea6737d85bf28bbed1e3de688902f4af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#gaea6737d85bf28bbed1e3de688902f4af">tred2</a> (int n, double **a, double *d, double *e, int matz)</td></tr>
<tr class="separator:gaea6737d85bf28bbed1e3de688902f4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e0c2d17910e9ca680cb9abc3c5aa444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CIOMR.html#ga0e0c2d17910e9ca680cb9abc3c5aa444">tqli</a> (int n, double *d, double **z, double *e, int matz, double toler)</td></tr>
<tr class="separator:ga0e0c2d17910e9ca680cb9abc3c5aa444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0258b00884013ebc4a45f43f0f5572e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0258b00884013ebc4a45f43f0f5572e8"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>cc3_sigma_RHF_ic_thread</b> (void *thread_data_in)</td></tr>
<tr class="separator:a0258b00884013ebc4a45f43f0f5572e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7b242ef431ad73e9e4e36acfeca3f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe7b242ef431ad73e9e4e36acfeca3f0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dpd_set_default</b> (int dpd_num)</td></tr>
<tr class="separator:afe7b242ef431ad73e9e4e36acfeca3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e6bf7e814574cec324c7f7451174c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84e6bf7e814574cec324c7f7451174c2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dpd_init</b> (int dpd_num, int nirreps, long int memory, int cachetype, int *cachefiles, int **cachelist, <a class="el" href="structpsi_1_1dpd__file4__cache__entry.html">dpd_file4_cache_entry</a> *priority, int num_subspaces, std::vector&lt; int * &gt; &amp;spaceArrays)</td></tr>
<tr class="separator:a84e6bf7e814574cec324c7f7451174c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc81236fcd75105d4bdc6e972b979b3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc81236fcd75105d4bdc6e972b979b3a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dpd_close</b> (int dpd_num)</td></tr>
<tr class="separator:adc81236fcd75105d4bdc6e972b979b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285cef4dd2a5df14332fec10810f582f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a285cef4dd2a5df14332fec10810f582f"></a>
long int&#160;</td><td class="memItemRight" valign="bottom"><b>dpd_memfree</b> (void)</td></tr>
<tr class="separator:a285cef4dd2a5df14332fec10810f582f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7498e911bde29ed2ce3316dc2a6b8624"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7498e911bde29ed2ce3316dc2a6b8624"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dpd_memset</b> (long int memory)</td></tr>
<tr class="separator:a7498e911bde29ed2ce3316dc2a6b8624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8672cb52f77dbc874a0197305596951"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8672cb52f77dbc874a0197305596951"></a>
<a class="el" href="structpsi_1_1dpd__file4__cache__entry.html">dpd_file4_cache_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>dpd_file4_cache_find_low</b> (void)</td></tr>
<tr class="separator:af8672cb52f77dbc874a0197305596951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c34a1a45b6f17e4599c041e2f64f268"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c34a1a45b6f17e4599c041e2f64f268"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wpbe_F</b> (double rho, double s, double omega, double *F, double *F_rho, double *F_s)</td></tr>
<tr class="separator:a9c34a1a45b6f17e4599c041e2f64f268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab605ef0d64ce923bd9955c2fb7242623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gab605ef0d64ce923bd9955c2fb7242623">iwl_buf_close</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int k)</td></tr>
<tr class="separator:gab605ef0d64ce923bd9955c2fb7242623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac911d759b786733d5f666d7b22d4b626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gac911d759b786733d5f666d7b22d4b626">iwl_buf_fetch</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf)</td></tr>
<tr class="separator:gac911d759b786733d5f666d7b22d4b626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf25d77d2b1ba5f862f8a9c62b9beade5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gaf25d77d2b1ba5f862f8a9c62b9beade5">iwl_buf_flush</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int lastbuf)</td></tr>
<tr class="separator:gaf25d77d2b1ba5f862f8a9c62b9beade5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17e4eee1412d1540e2c3091fd526658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gaf17e4eee1412d1540e2c3091fd526658">iwl_buf_init</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int itape, double cutoff, int oldfile, int readflag)</td></tr>
<tr class="separator:gaf17e4eee1412d1540e2c3091fd526658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305abfee9d72d2cd5c2c39a823da7680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga305abfee9d72d2cd5c2c39a823da7680">iwl_buf_put</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf)</td></tr>
<tr class="separator:ga305abfee9d72d2cd5c2c39a823da7680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff560dfd22becae1d1953b0a5fab8d33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gaff560dfd22becae1d1953b0a5fab8d33">iwl_buf_rd</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int target_pq, double *ints, int *ioff_lt, int *ioff_rt, int mp2, int printflg, FILE *out)</td></tr>
<tr class="separator:gaff560dfd22becae1d1953b0a5fab8d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb82f44066ccb9b3acafee95ee0f253e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gabb82f44066ccb9b3acafee95ee0f253e">iwl_buf_rd_all</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, double *ints, int *ioff_lt, int *ioff_rt, int no_pq_perm, int *ioff, int printflg, FILE *out)</td></tr>
<tr class="separator:gabb82f44066ccb9b3acafee95ee0f253e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e4b3d93ffdef73a198ac43312132321"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga0e4b3d93ffdef73a198ac43312132321">iwl_buf_rd_all2</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, double **ints, int *ioff_lt, int *ioff_rt, int no_pq_perm, int *, int printflg, FILE *out)</td></tr>
<tr class="separator:ga0e4b3d93ffdef73a198ac43312132321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf821d0ea97d511cd28db1f7a3a508cfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gaf821d0ea97d511cd28db1f7a3a508cfc">iwl_buf_rd_all_act</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, double *ints, int *ioff_lt, int *ioff_rt, int no_pq_perm, int *ioff, int fstact, int lstact, int printflg, FILE *out)</td></tr>
<tr class="separator:gaf821d0ea97d511cd28db1f7a3a508cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f416c78697c05b36d26580e8570500e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga9f416c78697c05b36d26580e8570500e">iwl_buf_rd_all_mp2r12a</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, double *ints, int *ioff_lt, int *ioff_rt, int bra_ket_symm, int *, int printflg, FILE *out)</td></tr>
<tr class="separator:ga9f416c78697c05b36d26580e8570500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f4f2041c90edf88b8a4bed5aec99124"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga7f4f2041c90edf88b8a4bed5aec99124">iwl_buf_rd_arr</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int target_pq, double *ints, int *rlist, int *slist, int *size, int *ioff, int printflg, FILE *out)</td></tr>
<tr class="separator:ga7f4f2041c90edf88b8a4bed5aec99124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add566862dea77a013c26ba269a9b9f6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#add566862dea77a013c26ba269a9b9f6d">iwl_buf_rd_arr2</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, double *ints, int *plist, int *qlist, int *rlist, int *slist, int *size, int *ioff, int printflg, FILE *out)</td></tr>
<tr class="separator:add566862dea77a013c26ba269a9b9f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12b6469ba7693cdafaa689513a44f557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga12b6469ba7693cdafaa689513a44f557">iwl_buf_toend</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf)</td></tr>
<tr class="separator:ga12b6469ba7693cdafaa689513a44f557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc23af6c125c81d824aaa552a3718f87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gadc23af6c125c81d824aaa552a3718f87">iwl_buf_wrt</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int p, int q, int pq, int pqsym, double *arr, int rmax, int *ioff, int *orbsym, int *firsti, int *lasti, int printflag, FILE *out)</td></tr>
<tr class="separator:gadc23af6c125c81d824aaa552a3718f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32d69b5c4a1ad12b2528d0e29ed5261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gac32d69b5c4a1ad12b2528d0e29ed5261">iwl_buf_wrt_all</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int nbfso, double *ints, int *ioff, int printflg, FILE *out)</td></tr>
<tr class="separator:gac32d69b5c4a1ad12b2528d0e29ed5261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea5e60ff7e4d99da1f866c2378a788b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga6ea5e60ff7e4d99da1f866c2378a788b">iwl_buf_wrt_arr</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, double *arr, int *p, int *q, int *r, int *s, long int size)</td></tr>
<tr class="separator:ga6ea5e60ff7e4d99da1f866c2378a788b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc0db8f64ed72616c0600a7de0b948a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gadcc0db8f64ed72616c0600a7de0b948a">iwl_buf_wrt_arr2</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, double *arr, int p, int q, int *rlist, int *slist, int size, int printflag, FILE *out)</td></tr>
<tr class="separator:gadcc0db8f64ed72616c0600a7de0b948a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa63e8c29d8d6af8dadb4f58a473507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga3aa63e8c29d8d6af8dadb4f58a473507">iwl_buf_wrt_arr_SI</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, double *arr, short int *p, short int *q, short int *r, short int *s, int size)</td></tr>
<tr class="separator:ga3aa63e8c29d8d6af8dadb4f58a473507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e943af44666fff9d538eeafe908536d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga7e943af44666fff9d538eeafe908536d">iwl_buf_wrt_arr_SI_nocut</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, double *arr, short int *p, short int *q, short int *r, short int *s, int size)</td></tr>
<tr class="separator:ga7e943af44666fff9d538eeafe908536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9b3df9d0700243c6df58e24679bf81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga1f9b3df9d0700243c6df58e24679bf81">iwl_buf_wrt_mat</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int ptr, int qtr, double **mat, int rfirst, int rlast, int sfirst, int slast, int *reorder, int reorder_offset, int printflag, int *ioff, FILE *out)</td></tr>
<tr class="separator:ga1f9b3df9d0700243c6df58e24679bf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a22bf5a91317f6d99cf3ac84dac293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga04a22bf5a91317f6d99cf3ac84dac293">iwl_buf_wrt_mat2</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int ptr, int qtr, double **mat, int rfirst, int rlast, int sfirst, int slast, int *reorder, int reorder_offset, int printflag, int *ioff, FILE *out)</td></tr>
<tr class="separator:ga04a22bf5a91317f6d99cf3ac84dac293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga371de3c7826da8f346db7ab82a71cf0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga371de3c7826da8f346db7ab82a71cf0b">iwl_buf_wrt_mp2</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int p, int q, int pq, int pqsym, double **arr, int rsym, int *firstr, int *lastr, int *firsts, int *lasts, int *occ, int *vir, int *ioff, int printflag, FILE *out)</td></tr>
<tr class="separator:ga371de3c7826da8f346db7ab82a71cf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a06f8c5c360af741439d2927a7e269"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga43a06f8c5c360af741439d2927a7e269">iwl_buf_wrt_mp2r12a</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int p, int q, int pq, int pqsym, double **arr, int rsym, int *firstr, int *lastr, int *firsts, int *lasts, int *occ, int bra_ket_symm, int *ioff, int printflag, FILE *out)</td></tr>
<tr class="separator:ga43a06f8c5c360af741439d2927a7e269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f0d5c44e713a5ea3dc205df5e67b345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga1f0d5c44e713a5ea3dc205df5e67b345">iwl_buf_wrt_val</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, int p, int q, int r, int s, double value, int printflag, FILE *out, int dirac)</td></tr>
<tr class="separator:ga1f0d5c44e713a5ea3dc205df5e67b345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38c3bb545c8c07d7c5a0001d94bf977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gae38c3bb545c8c07d7c5a0001d94bf977">iwl_buf_wrt_val_SI</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *Buf, short int p, short int q, short int r, short int s, double value, int printflag, FILE *out, int dirac)</td></tr>
<tr class="separator:gae38c3bb545c8c07d7c5a0001d94bf977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c5b528801e437b9c547b411c6aecb96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#ga3c5b528801e437b9c547b411c6aecb96">iwl_rdone</a> (int itap, const char *label, double *ints, int ntri, int erase, int printflg, FILE *outfile)</td></tr>
<tr class="separator:ga3c5b528801e437b9c547b411c6aecb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5a0cef49daf49b3df5d3cc2d1a3a3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gabe5a0cef49daf49b3df5d3cc2d1a3a3d">iwl_wrtone</a> (int itap, const char *label, int ntri, double *onel_ints)</td></tr>
<tr class="separator:gabe5a0cef49daf49b3df5d3cc2d1a3a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa898acb8e7fafcc7490a76d418ff11b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gaa898acb8e7fafcc7490a76d418ff11b2">iwl_rdtwo</a> (int itap, double *ints, int *ioff, int norbs, int nfzc, int nfzv, int printflg, FILE *outfile)</td></tr>
<tr class="separator:gaa898acb8e7fafcc7490a76d418ff11b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47bc515c18b41235322d0ad21796d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gaf47bc515c18b41235322d0ad21796d91">iwl_wrttwo</a> (int itap, int nbfso, double *ints, int *ioff, double toler, int printflg, FILE *outfile)</td></tr>
<tr class="separator:gaf47bc515c18b41235322d0ad21796d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac31f5ede2e3c350a3ecf3054f9e64dd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IWL.html#gac31f5ede2e3c350a3ecf3054f9e64dd0">sortbuf</a> (struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *inbuf, struct <a class="el" href="structpsi_1_1iwlbuf.html">iwlbuf</a> *outbuf, double *ints, int fpq, int lpq, int *ioff, int *ioff2, int nbfso, int elbert, int intermediate, int no_pq_perm, int qdim, int add, int printflg, FILE *outfile)</td></tr>
<tr class="separator:gac31f5ede2e3c350a3ecf3054f9e64dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a39a9e86ea8437b8967be4b852558e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52a39a9e86ea8437b8967be4b852558e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>shell_sorter_ncenter</b> (const <a class="el" href="classpsi_1_1GaussianShell.html">GaussianShell</a> &amp;d1, const <a class="el" href="classpsi_1_1GaussianShell.html">GaussianShell</a> &amp;d2)</td></tr>
<tr class="separator:a52a39a9e86ea8437b8967be4b852558e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4493959ca445a58b7b987177d595f512"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4493959ca445a58b7b987177d595f512"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>shell_sorter_am</b> (const <a class="el" href="classpsi_1_1GaussianShell.html">GaussianShell</a> &amp;d1, const <a class="el" href="classpsi_1_1GaussianShell.html">GaussianShell</a> &amp;d2)</td></tr>
<tr class="separator:a4493959ca445a58b7b987177d595f512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b1fec1a58f70ea5b8be45b109e90ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59b1fec1a58f70ea5b8be45b109e90ab"></a>
<a class="el" href="classpsi_1_1BasisSet.html">BasisSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classpsi_1_1BasisSet.html">BasisSet</a> &amp;a, const <a class="el" href="classpsi_1_1BasisSet.html">BasisSet</a> &amp;b)</td></tr>
<tr class="separator:a59b1fec1a58f70ea5b8be45b109e90ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e1b731cbf92155cab361257426c1e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5e1b731cbf92155cab361257426c1e8"></a>
<a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1BasisSet.html">BasisSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1BasisSet.html">BasisSet</a> &gt; &amp;a, const <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1BasisSet.html">BasisSet</a> &gt; &amp;b)</td></tr>
<tr class="separator:ab5e1b731cbf92155cab361257426c1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94898dbde057458f7f55480abd1ef90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae94898dbde057458f7f55480abd1ef90">benchmark_blas1</a> (int N, double min_time)</td></tr>
<tr class="separator:ae94898dbde057458f7f55480abd1ef90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4e9e11a4a771b54e65f2223ceba66b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a4f4e9e11a4a771b54e65f2223ceba66b">benchmark_blas2</a> (int N, double min_time)</td></tr>
<tr class="separator:a4f4e9e11a4a771b54e65f2223ceba66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe743339b4c555d69aa96c0bdea7474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7fe743339b4c555d69aa96c0bdea7474">benchmark_blas3</a> (int N, double min_time, int max_threads)</td></tr>
<tr class="separator:a7fe743339b4c555d69aa96c0bdea7474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d2b10d46e85d8d8389d849b2c24607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad2d2b10d46e85d8d8389d849b2c24607">benchmark_disk</a> (int N, double min_time)</td></tr>
<tr class="separator:ad2d2b10d46e85d8d8389d849b2c24607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aba6c665f535235a3b3377baf8fd08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2aba6c665f535235a3b3377baf8fd08c">benchmark_math</a> (double min_time)</td></tr>
<tr class="separator:a2aba6c665f535235a3b3377baf8fd08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10438bc4af3d0303663c48f3c3cfe32a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a10438bc4af3d0303663c48f3c3cfe32a">benchmark_integrals</a> (int max_am, double min_time)</td></tr>
<tr class="separator:a10438bc4af3d0303663c48f3c3cfe32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6d03ca8cb444ad052bb41d0eb6563b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a6d03ca8cb444ad052bb41d0eb6563b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classpsi_1_1Dimension.html">Dimension</a> &amp;a, const <a class="el" href="classpsi_1_1Dimension.html">Dimension</a> &amp;b)</td></tr>
<tr class="separator:a1a6d03ca8cb444ad052bb41d0eb6563b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4ad368a4c709440c86f34e16367f3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a4ad368a4c709440c86f34e16367f3a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classpsi_1_1Dimension.html">Dimension</a> &amp;a, const <a class="el" href="classpsi_1_1Dimension.html">Dimension</a> &amp;b)</td></tr>
<tr class="separator:a3a4ad368a4c709440c86f34e16367f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bffd4300f7396fc3d3c9f0610e06b54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bffd4300f7396fc3d3c9f0610e06b54"></a>
<a class="el" href="classpsi_1_1Dimension.html">Dimension</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classpsi_1_1Dimension.html">Dimension</a> &amp;a, const <a class="el" href="classpsi_1_1Dimension.html">Dimension</a> &amp;b)</td></tr>
<tr class="separator:a0bffd4300f7396fc3d3c9f0610e06b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae41baf8aa9774062d5c8d95efea74d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae41baf8aa9774062d5c8d95efea74d5"></a>
<a class="el" href="classpsi_1_1Dimension.html">Dimension</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classpsi_1_1Dimension.html">Dimension</a> &amp;a, const <a class="el" href="classpsi_1_1Dimension.html">Dimension</a> &amp;b)</td></tr>
<tr class="separator:aae41baf8aa9774062d5c8d95efea74d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1954217ae329f8c78fa79de1fcd9dd26"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MINTS.html#ga1954217ae329f8c78fa79de1fcd9dd26">get_writer_file_prefix</a> (void)</td></tr>
<tr class="separator:ga1954217ae329f8c78fa79de1fcd9dd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fe6317a550161d8b053d2d1686c02c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a89fe6317a550161d8b053d2d1686c02c">str_to_int</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a89fe6317a550161d8b053d2d1686c02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c62ee3e6ebd249518cb533e988b9d9c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2c62ee3e6ebd249518cb533e988b9d9c">str_to_double</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a2c62ee3e6ebd249518cb533e988b9d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad837054511910c029015f4131ca04238"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad837054511910c029015f4131ca04238"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>integerNumber_</b> (&quot;(-?\\d+)&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:ad837054511910c029015f4131ca04238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff3459c41fbbd3d214299e02d0bd85d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ff3459c41fbbd3d214299e02d0bd85d"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>atomSymbol_</b> (&quot;([A-Z]{1,2})\\d*&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:a9ff3459c41fbbd3d214299e02d0bd85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a81a4b08d8936b69ae28cd6801b656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73a81a4b08d8936b69ae28cd6801b656"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>variableDefinition_</b> (&quot;\\s*(\\w+)\\s*=\\s*((-?\\d+\\.\\d+)|(-?\\d+\\.)|(-?\\.\\d+)|(-?\\d+)|(tda))\\s*&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:a73a81a4b08d8936b69ae28cd6801b656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd218635555ff964788064d1e8aa90b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bd218635555ff964788064d1e8aa90b"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>blankLine_</b> (&quot;[\\s%]*&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:a8bd218635555ff964788064d1e8aa90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf0a4db11201ebda79eceeb7de28197"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bf0a4db11201ebda79eceeb7de28197"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>commentLine_</b> (&quot;\\s*[#%].*&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:a9bf0a4db11201ebda79eceeb7de28197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3996a66d80736130853dfc75b94a2a3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3996a66d80736130853dfc75b94a2a3d"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>unitLabel_</b> (&quot;\\s*units?[\\s=]+((ang)|(angstrom)|(bohr)|(au)|(a\\.u\\.))\\s*&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:a3996a66d80736130853dfc75b94a2a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73cd5605f0edf638a0c6f77b4f595b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad73cd5605f0edf638a0c6f77b4f595b5"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>chargeAndMultiplicity_</b> (&quot;\\s*(-?\\d+)\\s+(\\d+)\\s*&quot;, boost::regbase::normal)</td></tr>
<tr class="separator:ad73cd5605f0edf638a0c6f77b4f595b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab327fe23614203791ff8029738d88126"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab327fe23614203791ff8029738d88126"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>fragmentMarker_</b> (&quot;\\s*--\\s*&quot;, boost::regbase::normal)</td></tr>
<tr class="separator:ab327fe23614203791ff8029738d88126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7e94a2362fa6a072526da040d81063"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e7e94a2362fa6a072526da040d81063"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>orientCommand_</b> (&quot;\\s*no_?reorient\\s*&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:a5e7e94a2362fa6a072526da040d81063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00141aaaa7bae99c7bef6182a7eac43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac00141aaaa7bae99c7bef6182a7eac43"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>comCommand_</b> (&quot;\\s*no_?com\\s*&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:ac00141aaaa7bae99c7bef6182a7eac43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6643a0bbd0df4b3f8e23ff9785919293"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6643a0bbd0df4b3f8e23ff9785919293"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>symmetry_</b> (&quot;\\s*symmetry[\\s=]+(\\w+)\\s*&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:a6643a0bbd0df4b3f8e23ff9785919293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4b226cbf18b164c195bffb98fc082a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a4b226cbf18b164c195bffb98fc082a"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>pubchemError_</b> (&quot;\\s*PubchemError\\s*&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:a2a4b226cbf18b164c195bffb98fc082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6b579ad15f6e36a2b4e10e9c9e70aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c6b579ad15f6e36a2b4e10e9c9e70aa"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>pubchemInput_</b> (&quot;\\s*PubchemInput\\s*&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:a7c6b579ad15f6e36a2b4e10e9c9e70aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf38c95f0a8ed7eb7bc11ab846ae41fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf38c95f0a8ed7eb7bc11ab846ae41fa"></a>
boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>ghostAtom_</b> (&quot;@(.*)|Gh\\((.*)\\)&quot;, boost::regbase::normal|boost::regbase::icase)</td></tr>
<tr class="separator:abf38c95f0a8ed7eb7bc11ab846ae41fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21def25b6ee74349d04729aa315397f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21def25b6ee74349d04729aa315397f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>if_to_invert_axis</b> (const <a class="el" href="classpsi_1_1Vector3.html">Vector3</a> &amp;v1, int &amp;must_invert, int &amp;should_invert, double &amp;maxproj)</td></tr>
<tr class="separator:a21def25b6ee74349d04729aa315397f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2db1f5570a0ea8562f8c076fcc9fdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d2db1f5570a0ea8562f8c076fcc9fdf"></a>
int **&#160;</td><td class="memItemRight" valign="bottom"><b>compute_shell_map</b> (int **atom_map, const <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1BasisSet.html">BasisSet</a> &gt; &amp;basis)</td></tr>
<tr class="separator:a7d2db1f5570a0ea8562f8c076fcc9fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689a5dde09e5c300799c77e22be7baf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a689a5dde09e5c300799c77e22be7baf9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delete_shell_map</b> (int **shell_map, const <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1BasisSet.html">BasisSet</a> &gt; &amp;basis)</td></tr>
<tr class="separator:a689a5dde09e5c300799c77e22be7baf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc049610221359746da817fb43e0568"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbc049610221359746da817fb43e0568"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>ij_offset64</b> (int64_t i, int64_t j)</td></tr>
<tr class="separator:abbc049610221359746da817fb43e0568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577723280fb49b6f64e8854cd4e0434e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a577723280fb49b6f64e8854cd4e0434e"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>i_offset64</b> (int64_t i)</td></tr>
<tr class="separator:a577723280fb49b6f64e8854cd4e0434e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa116a8d61fee439f97017fd70dc885ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa116a8d61fee439f97017fd70dc885ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa116a8d61fee439f97017fd70dc885ed">PSI_DGBMV</a> (int irrep, char trans, int m, int n, int kl, int ku, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, double beta, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy)</td></tr>
<tr class="memdesc:aa116a8d61fee439f97017fd70dc885ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGBMV, a wrapper to C_DGBMV using objects. <br/></td></tr>
<tr class="separator:aa116a8d61fee439f97017fd70dc885ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cee3be98354896f81bcdd1458c5d0a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cee3be98354896f81bcdd1458c5d0a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a4cee3be98354896f81bcdd1458c5d0a6">PSI_DGEMM</a> (int irrep, char transa, char transb, int m, int n, int k, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, double beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc)</td></tr>
<tr class="memdesc:a4cee3be98354896f81bcdd1458c5d0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEMM, a wrapper to C_DGEMM using objects. <br/></td></tr>
<tr class="separator:a4cee3be98354896f81bcdd1458c5d0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e6267563a789b58fcaeea9136b3a7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27e6267563a789b58fcaeea9136b3a7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a27e6267563a789b58fcaeea9136b3a7e">PSI_DGEMV</a> (int irrep, char trans, int m, int n, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, double beta, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy)</td></tr>
<tr class="memdesc:a27e6267563a789b58fcaeea9136b3a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEMV, a wrapper to C_DGEMV using objects. <br/></td></tr>
<tr class="separator:a27e6267563a789b58fcaeea9136b3a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f878c62bbcfecc0db99392efb8dbcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1f878c62bbcfecc0db99392efb8dbcd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac1f878c62bbcfecc0db99392efb8dbcd">PSI_DGER</a> (int irrep, int m, int n, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda)</td></tr>
<tr class="memdesc:ac1f878c62bbcfecc0db99392efb8dbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGER, a wrapper to C_DGER using objects. <br/></td></tr>
<tr class="separator:ac1f878c62bbcfecc0db99392efb8dbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843de62f9c9d941326baefef2714c38c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a843de62f9c9d941326baefef2714c38c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a843de62f9c9d941326baefef2714c38c">PSI_DSBMV</a> (int irrep, char uplo, int n, int k, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, double beta, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy)</td></tr>
<tr class="memdesc:a843de62f9c9d941326baefef2714c38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSBMV, a wrapper to C_DSBMV using objects. <br/></td></tr>
<tr class="separator:a843de62f9c9d941326baefef2714c38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cf23d81fbafb0f528b57f8e56fc06e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8cf23d81fbafb0f528b57f8e56fc06e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad8cf23d81fbafb0f528b57f8e56fc06e">PSI_DSYMM</a> (int irrep, char side, char uplo, int m, int n, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, double beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc)</td></tr>
<tr class="memdesc:ad8cf23d81fbafb0f528b57f8e56fc06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYMM, a wrapper to C_DSYMM using objects. <br/></td></tr>
<tr class="separator:ad8cf23d81fbafb0f528b57f8e56fc06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab008f44c4e553765ae146da6101f24b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab008f44c4e553765ae146da6101f24b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aab008f44c4e553765ae146da6101f24b">PSI_DSYMV</a> (int irrep, char uplo, int n, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, double beta, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy)</td></tr>
<tr class="memdesc:aab008f44c4e553765ae146da6101f24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYMV, a wrapper to C_DSYMV using objects. <br/></td></tr>
<tr class="separator:aab008f44c4e553765ae146da6101f24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cd9705369498f099a50386bedbf941"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76cd9705369498f099a50386bedbf941"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a76cd9705369498f099a50386bedbf941">PSI_DSYR</a> (int irrep, char uplo, int n, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda)</td></tr>
<tr class="memdesc:a76cd9705369498f099a50386bedbf941"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYR, a wrapper to C_DSYR using objects. <br/></td></tr>
<tr class="separator:a76cd9705369498f099a50386bedbf941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf16df51c20e4a5a3d6e0181a497cbff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf16df51c20e4a5a3d6e0181a497cbff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#acf16df51c20e4a5a3d6e0181a497cbff">PSI_DSYR2</a> (int irrep, char uplo, int n, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda)</td></tr>
<tr class="memdesc:acf16df51c20e4a5a3d6e0181a497cbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYR2, a wrapper to C_DSYR2 using objects. <br/></td></tr>
<tr class="separator:acf16df51c20e4a5a3d6e0181a497cbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535190a6dee1f6b85dae2cadc3ff96e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a535190a6dee1f6b85dae2cadc3ff96e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a535190a6dee1f6b85dae2cadc3ff96e8">PSI_DSYR2K</a> (int irrep, char uplo, char trans, int n, int k, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, double beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc)</td></tr>
<tr class="memdesc:a535190a6dee1f6b85dae2cadc3ff96e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYR2K, a wrapper to C_DSYR2K using objects. <br/></td></tr>
<tr class="separator:a535190a6dee1f6b85dae2cadc3ff96e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6641fe8ce9399a76820bb4b49ad65dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6641fe8ce9399a76820bb4b49ad65dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa6641fe8ce9399a76820bb4b49ad65dd">PSI_DSYRK</a> (int irrep, char uplo, char trans, int n, int k, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, double beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc)</td></tr>
<tr class="memdesc:aa6641fe8ce9399a76820bb4b49ad65dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYRK, a wrapper to C_DSYRK using objects. <br/></td></tr>
<tr class="separator:aa6641fe8ce9399a76820bb4b49ad65dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd7655a864b8d367d28102743b49a5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fd7655a864b8d367d28102743b49a5f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8fd7655a864b8d367d28102743b49a5f">PSI_DTBMV</a> (int irrep, char uplo, char trans, char diag, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx)</td></tr>
<tr class="memdesc:a8fd7655a864b8d367d28102743b49a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTBMV, a wrapper to C_DTBMV using objects. <br/></td></tr>
<tr class="separator:a8fd7655a864b8d367d28102743b49a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ddc3b96170fbbf693826c6997f5272"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9ddc3b96170fbbf693826c6997f5272"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac9ddc3b96170fbbf693826c6997f5272">PSI_DTBSV</a> (int irrep, char uplo, char trans, char diag, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx)</td></tr>
<tr class="memdesc:ac9ddc3b96170fbbf693826c6997f5272"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTBSV, a wrapper to C_DTBSV using objects. <br/></td></tr>
<tr class="separator:ac9ddc3b96170fbbf693826c6997f5272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e4316abd0231ad67929ef20572bc5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74e4316abd0231ad67929ef20572bc5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a74e4316abd0231ad67929ef20572bc5c">PSI_DTRMM</a> (int irrep, char side, char uplo, char transa, char diag, int m, int n, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:a74e4316abd0231ad67929ef20572bc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRMM, a wrapper to C_DTRMM using objects. <br/></td></tr>
<tr class="separator:a74e4316abd0231ad67929ef20572bc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c195cabefbfaf8a5c7f3f2707388624"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c195cabefbfaf8a5c7f3f2707388624"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3c195cabefbfaf8a5c7f3f2707388624">PSI_DTRMV</a> (int irrep, char uplo, char trans, char diag, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx)</td></tr>
<tr class="memdesc:a3c195cabefbfaf8a5c7f3f2707388624"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRMV, a wrapper to C_DTRMV using objects. <br/></td></tr>
<tr class="separator:a3c195cabefbfaf8a5c7f3f2707388624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff44e0b0bb14e89be94f53b04e793614"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff44e0b0bb14e89be94f53b04e793614"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aff44e0b0bb14e89be94f53b04e793614">PSI_DTRSM</a> (int irrep, char side, char uplo, char transa, char diag, int m, int n, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:aff44e0b0bb14e89be94f53b04e793614"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRSM, a wrapper to C_DTRSM using objects. <br/></td></tr>
<tr class="separator:aff44e0b0bb14e89be94f53b04e793614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ee1751236678b38022c418a0cbd7e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79ee1751236678b38022c418a0cbd7e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a79ee1751236678b38022c418a0cbd7e4">PSI_DTRSV</a> (int irrep, char uplo, char trans, char diag, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx)</td></tr>
<tr class="memdesc:a79ee1751236678b38022c418a0cbd7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRSV, a wrapper to C_DTRSV using objects. <br/></td></tr>
<tr class="separator:a79ee1751236678b38022c418a0cbd7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abc57fcb61e7b68697a29f7f9593487"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9abc57fcb61e7b68697a29f7f9593487"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9abc57fcb61e7b68697a29f7f9593487">PSI_DROT</a> (int irrep, unsigned long int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy, double c, double s)</td></tr>
<tr class="memdesc:a9abc57fcb61e7b68697a29f7f9593487"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DROT, a wrapper to C_DROT using objects. <br/></td></tr>
<tr class="separator:a9abc57fcb61e7b68697a29f7f9593487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd1fe3bc60351d13c0b2d9b739a3064"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbd1fe3bc60351d13c0b2d9b739a3064"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#adbd1fe3bc60351d13c0b2d9b739a3064">PSI_DSWAP</a> (int irrep, unsigned long int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy)</td></tr>
<tr class="memdesc:adbd1fe3bc60351d13c0b2d9b739a3064"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSWAP, a wrapper to C_DSWAP using objects. <br/></td></tr>
<tr class="separator:adbd1fe3bc60351d13c0b2d9b739a3064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572ce9deacd04012fcf5e47965354a14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a572ce9deacd04012fcf5e47965354a14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a572ce9deacd04012fcf5e47965354a14">PSI_DCOPY</a> (int irrep, unsigned long int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy)</td></tr>
<tr class="memdesc:a572ce9deacd04012fcf5e47965354a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DCOPY, a wrapper to C_DCOPY using objects. <br/></td></tr>
<tr class="separator:a572ce9deacd04012fcf5e47965354a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15807f0dfc0c86a9bec32e9f8a7d209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad15807f0dfc0c86a9bec32e9f8a7d209"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad15807f0dfc0c86a9bec32e9f8a7d209">PSI_DSCAL</a> (int irrep, unsigned long int n, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx)</td></tr>
<tr class="memdesc:ad15807f0dfc0c86a9bec32e9f8a7d209"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSCAL, a wrapper to C_DSCAL using objects. <br/></td></tr>
<tr class="separator:ad15807f0dfc0c86a9bec32e9f8a7d209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddc7eaeb5e868a84c028b2330c9b7f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ddc7eaeb5e868a84c028b2330c9b7f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9ddc7eaeb5e868a84c028b2330c9b7f7">PSI_DAXPY</a> (int irrep, unsigned long int n, double alpha, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy)</td></tr>
<tr class="memdesc:a9ddc7eaeb5e868a84c028b2330c9b7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DAXPY, a wrapper to C_DAXPY using objects. <br/></td></tr>
<tr class="separator:a9ddc7eaeb5e868a84c028b2330c9b7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d0d8c8c21a4e95509b4ddccfc65a08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07d0d8c8c21a4e95509b4ddccfc65a08"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a07d0d8c8c21a4e95509b4ddccfc65a08">PSI_DDOT</a> (int irrep, unsigned long int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, int incy)</td></tr>
<tr class="memdesc:a07d0d8c8c21a4e95509b4ddccfc65a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DDOT, a wrapper to C_DDOT using objects. <br/></td></tr>
<tr class="separator:a07d0d8c8c21a4e95509b4ddccfc65a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9ccf1f38be189d99309b7a49a10bbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f9ccf1f38be189d99309b7a49a10bbc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8f9ccf1f38be189d99309b7a49a10bbc">PSI_DNRM2</a> (int irrep, unsigned long int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx)</td></tr>
<tr class="memdesc:a8f9ccf1f38be189d99309b7a49a10bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DNRM2, a wrapper to C_DNRM2 using objects. <br/></td></tr>
<tr class="separator:a8f9ccf1f38be189d99309b7a49a10bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6096193312e05de35998d9426019007"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6096193312e05de35998d9426019007"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac6096193312e05de35998d9426019007">PSI_DASUM</a> (int irrep, unsigned long int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx)</td></tr>
<tr class="memdesc:ac6096193312e05de35998d9426019007"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DASUM, a wrapper to C_DASUM using objects. <br/></td></tr>
<tr class="separator:ac6096193312e05de35998d9426019007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c29d9606f9764a96e0d3a9748bf49e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c29d9606f9764a96e0d3a9748bf49e8"></a>
unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1c29d9606f9764a96e0d3a9748bf49e8">PSI_IDAMAX</a> (int irrep, unsigned long int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, int incx)</td></tr>
<tr class="memdesc:a1c29d9606f9764a96e0d3a9748bf49e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_IDAMAX, a wrapper to C_IDAMAX using objects. <br/></td></tr>
<tr class="separator:a1c29d9606f9764a96e0d3a9748bf49e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645227094af54ecf858eba192f85144a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a645227094af54ecf858eba192f85144a">PSI_DBDSDC</a> (int irrep, char uplo, char compq, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> u, int ldu, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vt, int ldvt, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; q, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iq, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="separator:a645227094af54ecf858eba192f85144a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac236e5b656bbb772e14a8a2009851901"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac236e5b656bbb772e14a8a2009851901"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac236e5b656bbb772e14a8a2009851901">PSI_DBDSQR</a> (int irrep, char uplo, int n, int ncvt, int nru, int ncc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vt, int ldvt, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> u, int ldu, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:ac236e5b656bbb772e14a8a2009851901"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DBDSQR, a wrapper to return C_DBDSQR using objects. <br/></td></tr>
<tr class="separator:ac236e5b656bbb772e14a8a2009851901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b08235822f7786635562ffef084eab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3b08235822f7786635562ffef084eab"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac3b08235822f7786635562ffef084eab">PSI_DDISNA</a> (int irrep, char job, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; sep)</td></tr>
<tr class="memdesc:ac3b08235822f7786635562ffef084eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DDISNA, a wrapper to return C_DDISNA using objects. <br/></td></tr>
<tr class="separator:ac3b08235822f7786635562ffef084eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1af1271910af62f446a48a8681b228"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec1af1271910af62f446a48a8681b228"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aec1af1271910af62f446a48a8681b228">PSI_DGBBRD</a> (int irrep, char vect, int m, int n, int ncc, int kl, int ku, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> pt, int ldpt, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:aec1af1271910af62f446a48a8681b228"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGBBRD, a wrapper to return C_DGBBRD using objects. <br/></td></tr>
<tr class="separator:aec1af1271910af62f446a48a8681b228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8548b61c50065f920bc5007a0ec05f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8548b61c50065f920bc5007a0ec05f6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae8548b61c50065f920bc5007a0ec05f6">PSI_DGBCON</a> (int irrep, char norm, int n, int kl, int ku, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, double anorm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:ae8548b61c50065f920bc5007a0ec05f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGBCON, a wrapper to return C_DGBCON using objects. <br/></td></tr>
<tr class="separator:ae8548b61c50065f920bc5007a0ec05f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af9ee1b1aae1fd472307f5d3dc31979"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9af9ee1b1aae1fd472307f5d3dc31979"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9af9ee1b1aae1fd472307f5d3dc31979">PSI_DGBEQU</a> (int irrep, int m, int n, int kl, int ku, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; r, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; c, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rowcnd, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; colcnd, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; amax)</td></tr>
<tr class="memdesc:a9af9ee1b1aae1fd472307f5d3dc31979"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGBEQU, a wrapper to return C_DGBEQU using objects. <br/></td></tr>
<tr class="separator:a9af9ee1b1aae1fd472307f5d3dc31979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d0fd8883f15661586715be41ca900e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43d0fd8883f15661586715be41ca900e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a43d0fd8883f15661586715be41ca900e">PSI_DGBRFS</a> (int irrep, char trans, int n, int kl, int ku, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> afb, int ldafb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a43d0fd8883f15661586715be41ca900e"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGBRFS, a wrapper to return C_DGBRFS using objects. <br/></td></tr>
<tr class="separator:a43d0fd8883f15661586715be41ca900e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8255e09f7ea4ddf37158c28c404d90d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8255e09f7ea4ddf37158c28c404d90d8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8255e09f7ea4ddf37158c28c404d90d8">PSI_DGBSV</a> (int irrep, int n, int kl, int ku, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:a8255e09f7ea4ddf37158c28c404d90d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGBSV, a wrapper to return C_DGBSV using objects. <br/></td></tr>
<tr class="separator:a8255e09f7ea4ddf37158c28c404d90d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfed762b72a7025184dccf2b44ccceb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cfed762b72a7025184dccf2b44ccceb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a6cfed762b72a7025184dccf2b44ccceb">PSI_DGBSVX</a> (int irrep, char fact, char trans, int n, int kl, int ku, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> afb, int ldafb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, char equed, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; r, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; c, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a6cfed762b72a7025184dccf2b44ccceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGBSVX, a wrapper to return C_DGBSVX using objects. <br/></td></tr>
<tr class="separator:a6cfed762b72a7025184dccf2b44ccceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be28b8785810c2a7eeae08c2b9d2331"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3be28b8785810c2a7eeae08c2b9d2331"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3be28b8785810c2a7eeae08c2b9d2331">PSI_DGBTRF</a> (int irrep, int m, int n, int kl, int ku, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv)</td></tr>
<tr class="memdesc:a3be28b8785810c2a7eeae08c2b9d2331"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGBTRF, a wrapper to return C_DGBTRF using objects. <br/></td></tr>
<tr class="separator:a3be28b8785810c2a7eeae08c2b9d2331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8baf1546939d59083e29c7974817a78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8baf1546939d59083e29c7974817a78"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af8baf1546939d59083e29c7974817a78">PSI_DGBTRS</a> (int irrep, char trans, int n, int kl, int ku, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:af8baf1546939d59083e29c7974817a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGBTRS, a wrapper to return C_DGBTRS using objects. <br/></td></tr>
<tr class="separator:af8baf1546939d59083e29c7974817a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f1569254f94f95a19141e0796ead8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37f1569254f94f95a19141e0796ead8b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a37f1569254f94f95a19141e0796ead8b">PSI_DGEBAK</a> (int irrep, char job, char side, int n, int ilo, int ihi, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; scale, int m, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> v, int ldv)</td></tr>
<tr class="memdesc:a37f1569254f94f95a19141e0796ead8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEBAK, a wrapper to return C_DGEBAK using objects. <br/></td></tr>
<tr class="separator:a37f1569254f94f95a19141e0796ead8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207ef13a8956b65aaba61ea248f6ecef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a207ef13a8956b65aaba61ea248f6ecef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a207ef13a8956b65aaba61ea248f6ecef">PSI_DGEBAL</a> (int irrep, char job, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ilo, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ihi, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; scale)</td></tr>
<tr class="memdesc:a207ef13a8956b65aaba61ea248f6ecef"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEBAL, a wrapper to return C_DGEBAL using objects. <br/></td></tr>
<tr class="separator:a207ef13a8956b65aaba61ea248f6ecef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae369d047cf27ad5baecb18097a129edb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae369d047cf27ad5baecb18097a129edb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae369d047cf27ad5baecb18097a129edb">PSI_DGEBRD</a> (int irrep, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tauq, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; taup, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:ae369d047cf27ad5baecb18097a129edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEBRD, a wrapper to return C_DGEBRD using objects. <br/></td></tr>
<tr class="separator:ae369d047cf27ad5baecb18097a129edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95376ed3b6c9453a80c32debc7b85f01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95376ed3b6c9453a80c32debc7b85f01"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a95376ed3b6c9453a80c32debc7b85f01">PSI_DGECON</a> (int irrep, char norm, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, double anorm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a95376ed3b6c9453a80c32debc7b85f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGECON, a wrapper to return C_DGECON using objects. <br/></td></tr>
<tr class="separator:a95376ed3b6c9453a80c32debc7b85f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba56b8c0209ca2a923e24775876d3e6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba56b8c0209ca2a923e24775876d3e6f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aba56b8c0209ca2a923e24775876d3e6f">PSI_DGEEQU</a> (int irrep, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; r, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; c, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rowcnd, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; colcnd, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; amax)</td></tr>
<tr class="memdesc:aba56b8c0209ca2a923e24775876d3e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEEQU, a wrapper to return C_DGEEQU using objects. <br/></td></tr>
<tr class="separator:aba56b8c0209ca2a923e24775876d3e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e93955e3bc8e5c9b9c1df4854a335f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59e93955e3bc8e5c9b9c1df4854a335f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a59e93955e3bc8e5c9b9c1df4854a335f">PSI_DGEES</a> (int irrep, char jobvs, char sort, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; sdim, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vs, int ldvs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a59e93955e3bc8e5c9b9c1df4854a335f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEES, a wrapper to return C_DGEES using objects. <br/></td></tr>
<tr class="separator:a59e93955e3bc8e5c9b9c1df4854a335f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce9e2e9c97ac05308a3fb2a4e89b14b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abce9e2e9c97ac05308a3fb2a4e89b14b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#abce9e2e9c97ac05308a3fb2a4e89b14b">PSI_DGEESX</a> (int irrep, char jobvs, char sort, char sense, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; sdim, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vs, int ldvs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rconde, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcondv, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:abce9e2e9c97ac05308a3fb2a4e89b14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEESX, a wrapper to return C_DGEESX using objects. <br/></td></tr>
<tr class="separator:abce9e2e9c97ac05308a3fb2a4e89b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7466436b0f7ebc7292f39ee96d5e8aa4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7466436b0f7ebc7292f39ee96d5e8aa4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7466436b0f7ebc7292f39ee96d5e8aa4">PSI_DGEEV</a> (int irrep, char jobvl, char jobvr, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vl, int ldvl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vr, int ldvr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a7466436b0f7ebc7292f39ee96d5e8aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEEV, a wrapper to return C_DGEEV using objects. <br/></td></tr>
<tr class="separator:a7466436b0f7ebc7292f39ee96d5e8aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac76cbdff1a7e2052b5f3caaeea81721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac76cbdff1a7e2052b5f3caaeea81721"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aac76cbdff1a7e2052b5f3caaeea81721">PSI_DGEEVX</a> (int irrep, char balanc, char jobvl, char jobvr, char sense, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vl, int ldvl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vr, int ldvr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ilo, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ihi, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; scale, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; abnrm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rconde, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcondv, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:aac76cbdff1a7e2052b5f3caaeea81721"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEEVX, a wrapper to return C_DGEEVX using objects. <br/></td></tr>
<tr class="separator:aac76cbdff1a7e2052b5f3caaeea81721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad859fa5a0afa0a63585b6edb51207087"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad859fa5a0afa0a63585b6edb51207087"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad859fa5a0afa0a63585b6edb51207087">PSI_DGEGS</a> (int irrep, char jobvsl, char jobvsr, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphar, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphai, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vsl, int ldvsl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vsr, int ldvsr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:ad859fa5a0afa0a63585b6edb51207087"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEGS, a wrapper to return C_DGEGS using objects. <br/></td></tr>
<tr class="separator:ad859fa5a0afa0a63585b6edb51207087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27eb89c649e7dd956ff985a1d94a9daa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27eb89c649e7dd956ff985a1d94a9daa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a27eb89c649e7dd956ff985a1d94a9daa">PSI_DGEGV</a> (int irrep, char jobvl, char jobvr, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphar, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphai, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vl, int ldvl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vr, int ldvr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a27eb89c649e7dd956ff985a1d94a9daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEGV, a wrapper to return C_DGEGV using objects. <br/></td></tr>
<tr class="separator:a27eb89c649e7dd956ff985a1d94a9daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d2edc702e795db52ba026b279ea1ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91d2edc702e795db52ba026b279ea1ed"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a91d2edc702e795db52ba026b279ea1ed">PSI_DGEHRD</a> (int irrep, int n, int ilo, int ihi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a91d2edc702e795db52ba026b279ea1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEHRD, a wrapper to return C_DGEHRD using objects. <br/></td></tr>
<tr class="separator:a91d2edc702e795db52ba026b279ea1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547febf28bbae8c3d6b00fa8513822d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a547febf28bbae8c3d6b00fa8513822d7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a547febf28bbae8c3d6b00fa8513822d7">PSI_DGELQF</a> (int irrep, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a547febf28bbae8c3d6b00fa8513822d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGELQF, a wrapper to return C_DGELQF using objects. <br/></td></tr>
<tr class="separator:a547febf28bbae8c3d6b00fa8513822d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4832f807a8e1a2619e61e4b8cfd8906d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4832f807a8e1a2619e61e4b8cfd8906d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a4832f807a8e1a2619e61e4b8cfd8906d">PSI_DGELS</a> (int irrep, char trans, int m, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a4832f807a8e1a2619e61e4b8cfd8906d"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGELS, a wrapper to return C_DGELS using objects. <br/></td></tr>
<tr class="separator:a4832f807a8e1a2619e61e4b8cfd8906d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615ef0c7b9da037b9b510e4735c25167"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a615ef0c7b9da037b9b510e4735c25167"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a615ef0c7b9da037b9b510e4735c25167">PSI_DGELSD</a> (int irrep, int m, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; s, double rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; rank, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a615ef0c7b9da037b9b510e4735c25167"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGELSD, a wrapper to return C_DGELSD using objects. <br/></td></tr>
<tr class="separator:a615ef0c7b9da037b9b510e4735c25167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385f03c0419b11b83655ee3ffa9129f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a385f03c0419b11b83655ee3ffa9129f6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a385f03c0419b11b83655ee3ffa9129f6">PSI_DGELSS</a> (int irrep, int m, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; s, double rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; rank, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a385f03c0419b11b83655ee3ffa9129f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGELSS, a wrapper to return C_DGELSS using objects. <br/></td></tr>
<tr class="separator:a385f03c0419b11b83655ee3ffa9129f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcb649f5ca97d6472e78b87eeb55b10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dcb649f5ca97d6472e78b87eeb55b10"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9dcb649f5ca97d6472e78b87eeb55b10">PSI_DGELSX</a> (int irrep, int m, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; jpvt, double rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; rank, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a9dcb649f5ca97d6472e78b87eeb55b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGELSX, a wrapper to return C_DGELSX using objects. <br/></td></tr>
<tr class="separator:a9dcb649f5ca97d6472e78b87eeb55b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9688503a066786af249cd377be057c25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9688503a066786af249cd377be057c25"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9688503a066786af249cd377be057c25">PSI_DGELSY</a> (int irrep, int m, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; jpvt, double rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; rank, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a9688503a066786af249cd377be057c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGELSY, a wrapper to return C_DGELSY using objects. <br/></td></tr>
<tr class="separator:a9688503a066786af249cd377be057c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7592acc5cd4aaa126e76968966fe6475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7592acc5cd4aaa126e76968966fe6475"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7592acc5cd4aaa126e76968966fe6475">PSI_DGEQLF</a> (int irrep, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a7592acc5cd4aaa126e76968966fe6475"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEQLF, a wrapper to return C_DGEQLF using objects. <br/></td></tr>
<tr class="separator:a7592acc5cd4aaa126e76968966fe6475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1542bfa2cf8a8fdb9224b0d3bff9d374"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1542bfa2cf8a8fdb9224b0d3bff9d374"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1542bfa2cf8a8fdb9224b0d3bff9d374">PSI_DGEQP3</a> (int irrep, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; jpvt, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a1542bfa2cf8a8fdb9224b0d3bff9d374"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEQP3, a wrapper to return C_DGEQP3 using objects. <br/></td></tr>
<tr class="separator:a1542bfa2cf8a8fdb9224b0d3bff9d374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af838df773898f361aa0991eb02a48132"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af838df773898f361aa0991eb02a48132"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af838df773898f361aa0991eb02a48132">PSI_DGEQPF</a> (int irrep, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; jpvt, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:af838df773898f361aa0991eb02a48132"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGEQPF, a wrapper to return C_DGEQPF using objects. <br/></td></tr>
<tr class="separator:af838df773898f361aa0991eb02a48132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d729ea916ec50ae43c83cf7df142bfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d729ea916ec50ae43c83cf7df142bfc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1d729ea916ec50ae43c83cf7df142bfc">PSI_DGERFS</a> (int irrep, char trans, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> af, int ldaf, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a1d729ea916ec50ae43c83cf7df142bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGERFS, a wrapper to return C_DGERFS using objects. <br/></td></tr>
<tr class="separator:a1d729ea916ec50ae43c83cf7df142bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea80dfb0098e827c3280720372d43e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea80dfb0098e827c3280720372d43e0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#afea80dfb0098e827c3280720372d43e0">PSI_DGERQF</a> (int irrep, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:afea80dfb0098e827c3280720372d43e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGERQF, a wrapper to return C_DGERQF using objects. <br/></td></tr>
<tr class="separator:afea80dfb0098e827c3280720372d43e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3297fdd68bbdec191133ac081b21156c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3297fdd68bbdec191133ac081b21156c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3297fdd68bbdec191133ac081b21156c">PSI_DGESDD</a> (int irrep, char jobz, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; s, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> u, int ldu, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vt, int ldvt, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a3297fdd68bbdec191133ac081b21156c"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGESDD, a wrapper to return C_DGESDD using objects. <br/></td></tr>
<tr class="separator:a3297fdd68bbdec191133ac081b21156c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e80d2de4b2a9dc3233e66185ef9d478"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e80d2de4b2a9dc3233e66185ef9d478"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1e80d2de4b2a9dc3233e66185ef9d478">PSI_DGESV</a> (int irrep, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:a1e80d2de4b2a9dc3233e66185ef9d478"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGESV, a wrapper to return C_DGESV using objects. <br/></td></tr>
<tr class="separator:a1e80d2de4b2a9dc3233e66185ef9d478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727e5d7e71e42e835f43ff02722872a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a727e5d7e71e42e835f43ff02722872a4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a727e5d7e71e42e835f43ff02722872a4">PSI_DGESVX</a> (int irrep, char fact, char trans, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> af, int ldaf, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, char equed, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; r, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; c, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a727e5d7e71e42e835f43ff02722872a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGESVX, a wrapper to return C_DGESVX using objects. <br/></td></tr>
<tr class="separator:a727e5d7e71e42e835f43ff02722872a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed34ec6d85ff4cdcec6233dbd511bd85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed34ec6d85ff4cdcec6233dbd511bd85"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aed34ec6d85ff4cdcec6233dbd511bd85">PSI_DGETRF</a> (int irrep, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv)</td></tr>
<tr class="memdesc:aed34ec6d85ff4cdcec6233dbd511bd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGETRF, a wrapper to return C_DGETRF using objects. <br/></td></tr>
<tr class="separator:aed34ec6d85ff4cdcec6233dbd511bd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fed4140d96e6a1dd548a44a41448664"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fed4140d96e6a1dd548a44a41448664"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7fed4140d96e6a1dd548a44a41448664">PSI_DGETRI</a> (int irrep, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a7fed4140d96e6a1dd548a44a41448664"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGETRI, a wrapper to return C_DGETRI using objects. <br/></td></tr>
<tr class="separator:a7fed4140d96e6a1dd548a44a41448664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a616ae8ceae87e9ec962cb4d98ecc11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a616ae8ceae87e9ec962cb4d98ecc11"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a4a616ae8ceae87e9ec962cb4d98ecc11">PSI_DGETRS</a> (int irrep, char trans, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:a4a616ae8ceae87e9ec962cb4d98ecc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGETRS, a wrapper to return C_DGETRS using objects. <br/></td></tr>
<tr class="separator:a4a616ae8ceae87e9ec962cb4d98ecc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc142fc2d7ecc5ae8b80cd08e639abb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fc142fc2d7ecc5ae8b80cd08e639abb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0fc142fc2d7ecc5ae8b80cd08e639abb">PSI_DGGBAK</a> (int irrep, char job, char side, int n, int ilo, int ihi, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; lscale, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rscale, int m, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> v, int ldv)</td></tr>
<tr class="memdesc:a0fc142fc2d7ecc5ae8b80cd08e639abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGBAK, a wrapper to return C_DGGBAK using objects. <br/></td></tr>
<tr class="separator:a0fc142fc2d7ecc5ae8b80cd08e639abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29a94982ccf19cb8699c0e720e364a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab29a94982ccf19cb8699c0e720e364a6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab29a94982ccf19cb8699c0e720e364a6">PSI_DGGBAL</a> (int irrep, char job, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ilo, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ihi, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; lscale, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rscale, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:ab29a94982ccf19cb8699c0e720e364a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGBAL, a wrapper to return C_DGGBAL using objects. <br/></td></tr>
<tr class="separator:ab29a94982ccf19cb8699c0e720e364a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb7ba1939a732fc9cb9115f5bfce116"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfb7ba1939a732fc9cb9115f5bfce116"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#abfb7ba1939a732fc9cb9115f5bfce116">PSI_DGGES</a> (int irrep, char jobvsl, char jobvsr, char sort, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; sdim, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphar, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphai, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vsl, int ldvsl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vsr, int ldvsr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:abfb7ba1939a732fc9cb9115f5bfce116"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGES, a wrapper to return C_DGGES using objects. <br/></td></tr>
<tr class="separator:abfb7ba1939a732fc9cb9115f5bfce116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6494f410133c0a37c111eb9f815449"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f6494f410133c0a37c111eb9f815449"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5f6494f410133c0a37c111eb9f815449">PSI_DGGESX</a> (int irrep, char jobvsl, char jobvsr, char sort, char sense, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; sdim, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphar, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphai, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vsl, int ldvsl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vsr, int ldvsr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rconde, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcondv, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:a5f6494f410133c0a37c111eb9f815449"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGESX, a wrapper to return C_DGGESX using objects. <br/></td></tr>
<tr class="separator:a5f6494f410133c0a37c111eb9f815449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b34fed04ca1718db15f4bd2db6b0e13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b34fed04ca1718db15f4bd2db6b0e13"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5b34fed04ca1718db15f4bd2db6b0e13">PSI_DGGEV</a> (int irrep, char jobvl, char jobvr, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphar, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphai, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vl, int ldvl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vr, int ldvr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a5b34fed04ca1718db15f4bd2db6b0e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGEV, a wrapper to return C_DGGEV using objects. <br/></td></tr>
<tr class="separator:a5b34fed04ca1718db15f4bd2db6b0e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fba2814ad1e92371322e4ea01483ba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fba2814ad1e92371322e4ea01483ba1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5fba2814ad1e92371322e4ea01483ba1">PSI_DGGEVX</a> (int irrep, char balanc, char jobvl, char jobvr, char sense, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphar, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphai, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vl, int ldvl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vr, int ldvr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ilo, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ihi, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; lscale, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rscale, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; abnrm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; bbnrm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rconde, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcondv, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a5fba2814ad1e92371322e4ea01483ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGEVX, a wrapper to return C_DGGEVX using objects. <br/></td></tr>
<tr class="separator:a5fba2814ad1e92371322e4ea01483ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8017e1954d04b6ed8e2bc8c23eedae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe8017e1954d04b6ed8e2bc8c23eedae"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#afe8017e1954d04b6ed8e2bc8c23eedae">PSI_DGGGLM</a> (int irrep, int n, int m, int p, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; y, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:afe8017e1954d04b6ed8e2bc8c23eedae"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGGLM, a wrapper to return C_DGGGLM using objects. <br/></td></tr>
<tr class="separator:afe8017e1954d04b6ed8e2bc8c23eedae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba906e0fea92db8db3b13de680dae81a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba906e0fea92db8db3b13de680dae81a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aba906e0fea92db8db3b13de680dae81a">PSI_DGGHRD</a> (int irrep, char compq, char compz, int n, int ilo, int ihi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz)</td></tr>
<tr class="memdesc:aba906e0fea92db8db3b13de680dae81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGHRD, a wrapper to return C_DGGHRD using objects. <br/></td></tr>
<tr class="separator:aba906e0fea92db8db3b13de680dae81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18f8b788df95c87ebe1033372a10130"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af18f8b788df95c87ebe1033372a10130"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af18f8b788df95c87ebe1033372a10130">PSI_DGGLSE</a> (int irrep, int m, int n, int p, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; c, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; x, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:af18f8b788df95c87ebe1033372a10130"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGLSE, a wrapper to return C_DGGLSE using objects. <br/></td></tr>
<tr class="separator:af18f8b788df95c87ebe1033372a10130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6964f231ff76d346d5070c66c940edf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6964f231ff76d346d5070c66c940edf7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a6964f231ff76d346d5070c66c940edf7">PSI_DGGQRF</a> (int irrep, int n, int m, int p, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; taua, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; taub, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a6964f231ff76d346d5070c66c940edf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGQRF, a wrapper to return C_DGGQRF using objects. <br/></td></tr>
<tr class="separator:a6964f231ff76d346d5070c66c940edf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8012f7ddec7f50b1caf9ca204264bb41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8012f7ddec7f50b1caf9ca204264bb41"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8012f7ddec7f50b1caf9ca204264bb41">PSI_DGGRQF</a> (int irrep, int m, int p, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; taua, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; taub, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a8012f7ddec7f50b1caf9ca204264bb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGRQF, a wrapper to return C_DGGRQF using objects. <br/></td></tr>
<tr class="separator:a8012f7ddec7f50b1caf9ca204264bb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203f5d70670e393c9b971d80615d84b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a203f5d70670e393c9b971d80615d84b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a203f5d70670e393c9b971d80615d84b4">PSI_DGGSVD</a> (int irrep, char jobu, char jobv, char jobq, int m, int n, int p, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; k, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; l, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alpha, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> u, int ldu, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> v, int ldv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a203f5d70670e393c9b971d80615d84b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGSVD, a wrapper to return C_DGGSVD using objects. <br/></td></tr>
<tr class="separator:a203f5d70670e393c9b971d80615d84b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5b9b385fd6e79f3ef4b60453bde0ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b5b9b385fd6e79f3ef4b60453bde0ad"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1b5b9b385fd6e79f3ef4b60453bde0ad">PSI_DGGSVP</a> (int irrep, char jobu, char jobv, char jobq, int m, int p, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, double tola, double tolb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; k, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; l, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> u, int ldu, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> v, int ldv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a1b5b9b385fd6e79f3ef4b60453bde0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGGSVP, a wrapper to return C_DGGSVP using objects. <br/></td></tr>
<tr class="separator:a1b5b9b385fd6e79f3ef4b60453bde0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bda806bd6e3c27b2f49415ab6e22b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78bda806bd6e3c27b2f49415ab6e22b6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a78bda806bd6e3c27b2f49415ab6e22b6">PSI_DGTCON</a> (int irrep, char norm, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dl, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du2, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, double anorm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a78bda806bd6e3c27b2f49415ab6e22b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGTCON, a wrapper to return C_DGTCON using objects. <br/></td></tr>
<tr class="separator:a78bda806bd6e3c27b2f49415ab6e22b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40af6d429e16bda44ede5dddeea515fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40af6d429e16bda44ede5dddeea515fd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a40af6d429e16bda44ede5dddeea515fd">PSI_DGTRFS</a> (int irrep, char trans, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dl, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dlf, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; df, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; duf, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du2, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a40af6d429e16bda44ede5dddeea515fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGTRFS, a wrapper to return C_DGTRFS using objects. <br/></td></tr>
<tr class="separator:a40af6d429e16bda44ede5dddeea515fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf9195b08e51f2a6d055e24f28c26a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addf9195b08e51f2a6d055e24f28c26a3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#addf9195b08e51f2a6d055e24f28c26a3">PSI_DGTSV</a> (int irrep, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dl, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:addf9195b08e51f2a6d055e24f28c26a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGTSV, a wrapper to return C_DGTSV using objects. <br/></td></tr>
<tr class="separator:addf9195b08e51f2a6d055e24f28c26a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a7ac690db0dffa9d86be2821fb27e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4a7ac690db0dffa9d86be2821fb27e0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab4a7ac690db0dffa9d86be2821fb27e0">PSI_DGTSVX</a> (int irrep, char fact, char trans, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dl, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dlf, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; df, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; duf, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du2, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond)</td></tr>
<tr class="memdesc:ab4a7ac690db0dffa9d86be2821fb27e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGTSVX, a wrapper to return C_DGTSVX using objects. <br/></td></tr>
<tr class="separator:ab4a7ac690db0dffa9d86be2821fb27e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac948b85eeb5eda1f2f67d97ea26b7348"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac948b85eeb5eda1f2f67d97ea26b7348"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac948b85eeb5eda1f2f67d97ea26b7348">PSI_DGTTRF</a> (int irrep, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dl, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du2, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv)</td></tr>
<tr class="memdesc:ac948b85eeb5eda1f2f67d97ea26b7348"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGTTRF, a wrapper to return C_DGTTRF using objects. <br/></td></tr>
<tr class="separator:ac948b85eeb5eda1f2f67d97ea26b7348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b03acf6967b64a3263ac901c826e8c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b03acf6967b64a3263ac901c826e8c9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3b03acf6967b64a3263ac901c826e8c9">PSI_DGTTRS</a> (int irrep, char trans, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dl, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; du2, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:a3b03acf6967b64a3263ac901c826e8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DGTTRS, a wrapper to return C_DGTTRS using objects. <br/></td></tr>
<tr class="separator:a3b03acf6967b64a3263ac901c826e8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab532fc355a4581f7b249844c8471d5c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab532fc355a4581f7b249844c8471d5c3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab532fc355a4581f7b249844c8471d5c3">PSI_DHGEQZ</a> (int irrep, char job, char compq, char compz, int n, int ilo, int ihi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> h, int ldh, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> t, int ldt, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphar, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphai, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:ab532fc355a4581f7b249844c8471d5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DHGEQZ, a wrapper to return C_DHGEQZ using objects. <br/></td></tr>
<tr class="separator:ab532fc355a4581f7b249844c8471d5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec8ae6c04b6f2962edc18fb60138806"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ec8ae6c04b6f2962edc18fb60138806"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8ec8ae6c04b6f2962edc18fb60138806">PSI_DHSEIN</a> (int irrep, char side, char eigsrc, char initv, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> h, int ldh, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vl, int ldvl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vr, int ldvr, int mm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ifaill, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ifailr)</td></tr>
<tr class="memdesc:a8ec8ae6c04b6f2962edc18fb60138806"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DHSEIN, a wrapper to return C_DHSEIN using objects. <br/></td></tr>
<tr class="separator:a8ec8ae6c04b6f2962edc18fb60138806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045aa35b50f98978552def6b60c80665"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a045aa35b50f98978552def6b60c80665"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a045aa35b50f98978552def6b60c80665">PSI_DHSEQR</a> (int irrep, char job, char compz, int n, int ilo, int ihi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> h, int ldh, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a045aa35b50f98978552def6b60c80665"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DHSEQR, a wrapper to return C_DHSEQR using objects. <br/></td></tr>
<tr class="separator:a045aa35b50f98978552def6b60c80665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e8a1a9a3ec412c273126667bd8c8fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30e8a1a9a3ec412c273126667bd8c8fc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a30e8a1a9a3ec412c273126667bd8c8fc">PSI_DORGBR</a> (int irrep, char vect, int m, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a30e8a1a9a3ec412c273126667bd8c8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORGBR, a wrapper to return C_DORGBR using objects. <br/></td></tr>
<tr class="separator:a30e8a1a9a3ec412c273126667bd8c8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03cec59c5cf2e222cc3daa12f7f69f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af03cec59c5cf2e222cc3daa12f7f69f7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af03cec59c5cf2e222cc3daa12f7f69f7">PSI_DORGHR</a> (int irrep, int n, int ilo, int ihi, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:af03cec59c5cf2e222cc3daa12f7f69f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORGHR, a wrapper to return C_DORGHR using objects. <br/></td></tr>
<tr class="separator:af03cec59c5cf2e222cc3daa12f7f69f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787eea73e34d3b7e528f783a11732b58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a787eea73e34d3b7e528f783a11732b58"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a787eea73e34d3b7e528f783a11732b58">PSI_DORGLQ</a> (int irrep, int m, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a787eea73e34d3b7e528f783a11732b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORGLQ, a wrapper to return C_DORGLQ using objects. <br/></td></tr>
<tr class="separator:a787eea73e34d3b7e528f783a11732b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcb85f68f6242277fc42d3e37d66866"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfcb85f68f6242277fc42d3e37d66866"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#acfcb85f68f6242277fc42d3e37d66866">PSI_DORGQL</a> (int irrep, int m, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:acfcb85f68f6242277fc42d3e37d66866"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORGQL, a wrapper to return C_DORGQL using objects. <br/></td></tr>
<tr class="separator:acfcb85f68f6242277fc42d3e37d66866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33642b500da20253c74a7b5f2230369c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33642b500da20253c74a7b5f2230369c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a33642b500da20253c74a7b5f2230369c">PSI_DORGQR</a> (int irrep, int m, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a33642b500da20253c74a7b5f2230369c"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORGQR, a wrapper to return C_DORGQR using objects. <br/></td></tr>
<tr class="separator:a33642b500da20253c74a7b5f2230369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228ac340d58553d0b7f8b06bd069de4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a228ac340d58553d0b7f8b06bd069de4d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a228ac340d58553d0b7f8b06bd069de4d">PSI_DORGRQ</a> (int irrep, int m, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a228ac340d58553d0b7f8b06bd069de4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORGRQ, a wrapper to return C_DORGRQ using objects. <br/></td></tr>
<tr class="separator:a228ac340d58553d0b7f8b06bd069de4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437e76e2f1b4724d482d0514699553d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a437e76e2f1b4724d482d0514699553d4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a437e76e2f1b4724d482d0514699553d4">PSI_DORGTR</a> (int irrep, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a437e76e2f1b4724d482d0514699553d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORGTR, a wrapper to return C_DORGTR using objects. <br/></td></tr>
<tr class="separator:a437e76e2f1b4724d482d0514699553d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2860ce0a13c91162627de331e850018"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2860ce0a13c91162627de331e850018"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa2860ce0a13c91162627de331e850018">PSI_DORMBR</a> (int irrep, char vect, char side, char trans, int m, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:aa2860ce0a13c91162627de331e850018"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORMBR, a wrapper to return C_DORMBR using objects. <br/></td></tr>
<tr class="separator:aa2860ce0a13c91162627de331e850018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837d5d9bbb602f891ed88c25afce7dcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a837d5d9bbb602f891ed88c25afce7dcb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a837d5d9bbb602f891ed88c25afce7dcb">PSI_DORMHR</a> (int irrep, char side, char trans, int m, int n, int ilo, int ihi, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a837d5d9bbb602f891ed88c25afce7dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORMHR, a wrapper to return C_DORMHR using objects. <br/></td></tr>
<tr class="separator:a837d5d9bbb602f891ed88c25afce7dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4834531f56af1457e1c75001ac0f2492"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4834531f56af1457e1c75001ac0f2492"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a4834531f56af1457e1c75001ac0f2492">PSI_DORMLQ</a> (int irrep, char side, char trans, int m, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a4834531f56af1457e1c75001ac0f2492"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORMLQ, a wrapper to return C_DORMLQ using objects. <br/></td></tr>
<tr class="separator:a4834531f56af1457e1c75001ac0f2492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accae3d12ca95a868ca47343f3b57b1c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accae3d12ca95a868ca47343f3b57b1c9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#accae3d12ca95a868ca47343f3b57b1c9">PSI_DORMQL</a> (int irrep, char side, char trans, int m, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:accae3d12ca95a868ca47343f3b57b1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORMQL, a wrapper to return C_DORMQL using objects. <br/></td></tr>
<tr class="separator:accae3d12ca95a868ca47343f3b57b1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aa3965725e3968da155943d53ea3ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13aa3965725e3968da155943d53ea3ba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a13aa3965725e3968da155943d53ea3ba">PSI_DORMQR</a> (int irrep, char side, char trans, int m, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a13aa3965725e3968da155943d53ea3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORMQR, a wrapper to return C_DORMQR using objects. <br/></td></tr>
<tr class="separator:a13aa3965725e3968da155943d53ea3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cccd1cc1a99b5374588e24c3053abb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cccd1cc1a99b5374588e24c3053abb3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0cccd1cc1a99b5374588e24c3053abb3">PSI_DORMR3</a> (int irrep, char side, char trans, int m, int n, int k, int l, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a0cccd1cc1a99b5374588e24c3053abb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORMR3, a wrapper to return C_DORMR3 using objects. <br/></td></tr>
<tr class="separator:a0cccd1cc1a99b5374588e24c3053abb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86429f9ee8449dc79e7b0d968a43d1b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86429f9ee8449dc79e7b0d968a43d1b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a86429f9ee8449dc79e7b0d968a43d1b4">PSI_DORMRQ</a> (int irrep, char side, char trans, int m, int n, int k, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a86429f9ee8449dc79e7b0d968a43d1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORMRQ, a wrapper to return C_DORMRQ using objects. <br/></td></tr>
<tr class="separator:a86429f9ee8449dc79e7b0d968a43d1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b83ec69b59d0c639c6ef213ebc6f62c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b83ec69b59d0c639c6ef213ebc6f62c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9b83ec69b59d0c639c6ef213ebc6f62c">PSI_DORMRZ</a> (int irrep, char side, char trans, int m, int n, int k, int l, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a9b83ec69b59d0c639c6ef213ebc6f62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORMRZ, a wrapper to return C_DORMRZ using objects. <br/></td></tr>
<tr class="separator:a9b83ec69b59d0c639c6ef213ebc6f62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a455b6f22fda0643a24e2735e2377b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a455b6f22fda0643a24e2735e2377b7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8a455b6f22fda0643a24e2735e2377b7">PSI_DORMTR</a> (int irrep, char side, char uplo, char trans, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a8a455b6f22fda0643a24e2735e2377b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DORMTR, a wrapper to return C_DORMTR using objects. <br/></td></tr>
<tr class="separator:a8a455b6f22fda0643a24e2735e2377b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3221e22c3b2c60f380abfbca12e9833a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3221e22c3b2c60f380abfbca12e9833a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3221e22c3b2c60f380abfbca12e9833a">PSI_DPBCON</a> (int irrep, char uplo, int n, int kd, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, double anorm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a3221e22c3b2c60f380abfbca12e9833a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPBCON, a wrapper to return C_DPBCON using objects. <br/></td></tr>
<tr class="separator:a3221e22c3b2c60f380abfbca12e9833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d0620bb3d07b4b9f30420198c2be80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22d0620bb3d07b4b9f30420198c2be80"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a22d0620bb3d07b4b9f30420198c2be80">PSI_DPBEQU</a> (int irrep, char uplo, int n, int kd, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; s, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; scond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; amax)</td></tr>
<tr class="memdesc:a22d0620bb3d07b4b9f30420198c2be80"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPBEQU, a wrapper to return C_DPBEQU using objects. <br/></td></tr>
<tr class="separator:a22d0620bb3d07b4b9f30420198c2be80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174a19ab779238f51e433d955277866a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a174a19ab779238f51e433d955277866a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a174a19ab779238f51e433d955277866a">PSI_DPBRFS</a> (int irrep, char uplo, int n, int kd, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> afb, int ldafb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a174a19ab779238f51e433d955277866a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPBRFS, a wrapper to return C_DPBRFS using objects. <br/></td></tr>
<tr class="separator:a174a19ab779238f51e433d955277866a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987de96e2a9eba24442e2e48a8dad66a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a987de96e2a9eba24442e2e48a8dad66a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a987de96e2a9eba24442e2e48a8dad66a">PSI_DPBSTF</a> (int irrep, char uplo, int n, int kd, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab)</td></tr>
<tr class="memdesc:a987de96e2a9eba24442e2e48a8dad66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPBSTF, a wrapper to return C_DPBSTF using objects. <br/></td></tr>
<tr class="separator:a987de96e2a9eba24442e2e48a8dad66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf706696c7d9d72c5f6e6bc3cf430b7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf706696c7d9d72c5f6e6bc3cf430b7c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aaf706696c7d9d72c5f6e6bc3cf430b7c">PSI_DPBSV</a> (int irrep, char uplo, int n, int kd, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:aaf706696c7d9d72c5f6e6bc3cf430b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPBSV, a wrapper to return C_DPBSV using objects. <br/></td></tr>
<tr class="separator:aaf706696c7d9d72c5f6e6bc3cf430b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36b8b59e7260c4824eb3d3067baa426"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad36b8b59e7260c4824eb3d3067baa426"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad36b8b59e7260c4824eb3d3067baa426">PSI_DPBSVX</a> (int irrep, char fact, char uplo, int n, int kd, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> afb, int ldafb, char equed, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; s, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:ad36b8b59e7260c4824eb3d3067baa426"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPBSVX, a wrapper to return C_DPBSVX using objects. <br/></td></tr>
<tr class="separator:ad36b8b59e7260c4824eb3d3067baa426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4df55ce0a832d6a18ce5fc1ff4387e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d4df55ce0a832d6a18ce5fc1ff4387e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a6d4df55ce0a832d6a18ce5fc1ff4387e">PSI_DPBTRF</a> (int irrep, char uplo, int n, int kd, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab)</td></tr>
<tr class="memdesc:a6d4df55ce0a832d6a18ce5fc1ff4387e"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPBTRF, a wrapper to return C_DPBTRF using objects. <br/></td></tr>
<tr class="separator:a6d4df55ce0a832d6a18ce5fc1ff4387e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3fd025c27a34bd8a8d872f5ff66011"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a3fd025c27a34bd8a8d872f5ff66011"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2a3fd025c27a34bd8a8d872f5ff66011">PSI_DPBTRS</a> (int irrep, char uplo, int n, int kd, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:a2a3fd025c27a34bd8a8d872f5ff66011"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPBTRS, a wrapper to return C_DPBTRS using objects. <br/></td></tr>
<tr class="separator:a2a3fd025c27a34bd8a8d872f5ff66011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf81b9774556b91b28e092bcfafc56eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf81b9774556b91b28e092bcfafc56eb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#acf81b9774556b91b28e092bcfafc56eb">PSI_DPOCON</a> (int irrep, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, double anorm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:acf81b9774556b91b28e092bcfafc56eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPOCON, a wrapper to return C_DPOCON using objects. <br/></td></tr>
<tr class="separator:acf81b9774556b91b28e092bcfafc56eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddfdb6133d8fa747a60980a59221a7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ddfdb6133d8fa747a60980a59221a7c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1ddfdb6133d8fa747a60980a59221a7c">PSI_DPOEQU</a> (int irrep, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; s, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; scond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; amax)</td></tr>
<tr class="memdesc:a1ddfdb6133d8fa747a60980a59221a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPOEQU, a wrapper to return C_DPOEQU using objects. <br/></td></tr>
<tr class="separator:a1ddfdb6133d8fa747a60980a59221a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417d81809cba09794e672cd9da52f8f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a417d81809cba09794e672cd9da52f8f5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a417d81809cba09794e672cd9da52f8f5">PSI_DPORFS</a> (int irrep, char uplo, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> af, int ldaf, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a417d81809cba09794e672cd9da52f8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPORFS, a wrapper to return C_DPORFS using objects. <br/></td></tr>
<tr class="separator:a417d81809cba09794e672cd9da52f8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb059875d3cbd0b4bfff0b463a2e74df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb059875d3cbd0b4bfff0b463a2e74df"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#afb059875d3cbd0b4bfff0b463a2e74df">PSI_DPOSV</a> (int irrep, char uplo, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:afb059875d3cbd0b4bfff0b463a2e74df"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPOSV, a wrapper to return C_DPOSV using objects. <br/></td></tr>
<tr class="separator:afb059875d3cbd0b4bfff0b463a2e74df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c10abf8024dc271c55da4be4fca3ca8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c10abf8024dc271c55da4be4fca3ca8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1c10abf8024dc271c55da4be4fca3ca8">PSI_DPOSVX</a> (int irrep, char fact, char uplo, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> af, int ldaf, char equed, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; s, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a1c10abf8024dc271c55da4be4fca3ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPOSVX, a wrapper to return C_DPOSVX using objects. <br/></td></tr>
<tr class="separator:a1c10abf8024dc271c55da4be4fca3ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa61d3fe59b40ea6a267e0d80138a03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fa61d3fe59b40ea6a267e0d80138a03"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a4fa61d3fe59b40ea6a267e0d80138a03">PSI_DPOTRF</a> (int irrep, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda)</td></tr>
<tr class="memdesc:a4fa61d3fe59b40ea6a267e0d80138a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPOTRF, a wrapper to return C_DPOTRF using objects. <br/></td></tr>
<tr class="separator:a4fa61d3fe59b40ea6a267e0d80138a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1a46f1aff30b1e7bf1a75f5b4f34bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c1a46f1aff30b1e7bf1a75f5b4f34bd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a6c1a46f1aff30b1e7bf1a75f5b4f34bd">PSI_DPOTRI</a> (int irrep, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda)</td></tr>
<tr class="memdesc:a6c1a46f1aff30b1e7bf1a75f5b4f34bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPOTRI, a wrapper to return C_DPOTRI using objects. <br/></td></tr>
<tr class="separator:a6c1a46f1aff30b1e7bf1a75f5b4f34bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15385c268b56bab4c1d4b105c69a242"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af15385c268b56bab4c1d4b105c69a242"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af15385c268b56bab4c1d4b105c69a242">PSI_DPOTRS</a> (int irrep, char uplo, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:af15385c268b56bab4c1d4b105c69a242"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPOTRS, a wrapper to return C_DPOTRS using objects. <br/></td></tr>
<tr class="separator:af15385c268b56bab4c1d4b105c69a242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae381aaf76f2eed1a45f1ea9dc2bc7d5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae381aaf76f2eed1a45f1ea9dc2bc7d5d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae381aaf76f2eed1a45f1ea9dc2bc7d5d">PSI_DPTCON</a> (int irrep, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, double anorm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:ae381aaf76f2eed1a45f1ea9dc2bc7d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPTCON, a wrapper to return C_DPTCON using objects. <br/></td></tr>
<tr class="separator:ae381aaf76f2eed1a45f1ea9dc2bc7d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83982c84521ada99bad743bb5199a15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af83982c84521ada99bad743bb5199a15"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af83982c84521ada99bad743bb5199a15">PSI_DPTEQR</a> (int irrep, char compz, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:af83982c84521ada99bad743bb5199a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPTEQR, a wrapper to return C_DPTEQR using objects. <br/></td></tr>
<tr class="separator:af83982c84521ada99bad743bb5199a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4a63efab1a0a350e80cc9c42039fbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e4a63efab1a0a350e80cc9c42039fbd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7e4a63efab1a0a350e80cc9c42039fbd">PSI_DPTRFS</a> (int irrep, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; df, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ef, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a7e4a63efab1a0a350e80cc9c42039fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPTRFS, a wrapper to return C_DPTRFS using objects. <br/></td></tr>
<tr class="separator:a7e4a63efab1a0a350e80cc9c42039fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ea19d19b9bab9fc60b850f8f0f5524"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8ea19d19b9bab9fc60b850f8f0f5524"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac8ea19d19b9bab9fc60b850f8f0f5524">PSI_DPTSV</a> (int irrep, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:ac8ea19d19b9bab9fc60b850f8f0f5524"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPTSV, a wrapper to return C_DPTSV using objects. <br/></td></tr>
<tr class="separator:ac8ea19d19b9bab9fc60b850f8f0f5524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32adafa827cb9827a7e0bc2691bfcb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae32adafa827cb9827a7e0bc2691bfcb3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae32adafa827cb9827a7e0bc2691bfcb3">PSI_DPTSVX</a> (int irrep, char fact, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; df, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ef, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:ae32adafa827cb9827a7e0bc2691bfcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPTSVX, a wrapper to return C_DPTSVX using objects. <br/></td></tr>
<tr class="separator:ae32adafa827cb9827a7e0bc2691bfcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b534b6308200f23613ddc11a9088de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35b534b6308200f23613ddc11a9088de"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a35b534b6308200f23613ddc11a9088de">PSI_DPTTRF</a> (int irrep, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e)</td></tr>
<tr class="memdesc:a35b534b6308200f23613ddc11a9088de"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPTTRF, a wrapper to return C_DPTTRF using objects. <br/></td></tr>
<tr class="separator:a35b534b6308200f23613ddc11a9088de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ef162fbb93a5f5d5c2cff53f5cf624"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ef162fbb93a5f5d5c2cff53f5cf624"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad5ef162fbb93a5f5d5c2cff53f5cf624">PSI_DPTTRS</a> (int irrep, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:ad5ef162fbb93a5f5d5c2cff53f5cf624"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DPTTRS, a wrapper to return C_DPTTRS using objects. <br/></td></tr>
<tr class="separator:ad5ef162fbb93a5f5d5c2cff53f5cf624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bae1fb54a6652a5f2e066301001de62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bae1fb54a6652a5f2e066301001de62"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a4bae1fb54a6652a5f2e066301001de62">PSI_DSBEV</a> (int irrep, char jobz, char uplo, int n, int kd, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a4bae1fb54a6652a5f2e066301001de62"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSBEV, a wrapper to return C_DSBEV using objects. <br/></td></tr>
<tr class="separator:a4bae1fb54a6652a5f2e066301001de62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad990c6386333beb7b9b9676ff2caba68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad990c6386333beb7b9b9676ff2caba68"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad990c6386333beb7b9b9676ff2caba68">PSI_DSBEVD</a> (int irrep, char jobz, char uplo, int n, int kd, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:ad990c6386333beb7b9b9676ff2caba68"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSBEVD, a wrapper to return C_DSBEVD using objects. <br/></td></tr>
<tr class="separator:ad990c6386333beb7b9b9676ff2caba68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a423d5d5919bdc3406d48585b427170"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a423d5d5919bdc3406d48585b427170"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2a423d5d5919bdc3406d48585b427170">PSI_DSBEVX</a> (int irrep, char jobz, char range, char uplo, int n, int kd, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, double vl, double vu, int il, int iu, double abstol, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ifail)</td></tr>
<tr class="memdesc:a2a423d5d5919bdc3406d48585b427170"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSBEVX, a wrapper to return C_DSBEVX using objects. <br/></td></tr>
<tr class="separator:a2a423d5d5919bdc3406d48585b427170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca969ebf9e3ea4718f6f04a620a0537"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afca969ebf9e3ea4718f6f04a620a0537"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#afca969ebf9e3ea4718f6f04a620a0537">PSI_DSBGST</a> (int irrep, char vect, char uplo, int n, int ka, int kb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> bb, int ldbb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:afca969ebf9e3ea4718f6f04a620a0537"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSBGST, a wrapper to return C_DSBGST using objects. <br/></td></tr>
<tr class="separator:afca969ebf9e3ea4718f6f04a620a0537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fb4156e2d8cee2c508e47f0c5c9662"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3fb4156e2d8cee2c508e47f0c5c9662"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae3fb4156e2d8cee2c508e47f0c5c9662">PSI_DSBGV</a> (int irrep, char jobz, char uplo, int n, int ka, int kb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> bb, int ldbb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:ae3fb4156e2d8cee2c508e47f0c5c9662"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSBGV, a wrapper to return C_DSBGV using objects. <br/></td></tr>
<tr class="separator:ae3fb4156e2d8cee2c508e47f0c5c9662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490632701668dda426d388e6c335e6e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a490632701668dda426d388e6c335e6e4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a490632701668dda426d388e6c335e6e4">PSI_DSBGVD</a> (int irrep, char jobz, char uplo, int n, int ka, int kb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> bb, int ldbb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:a490632701668dda426d388e6c335e6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSBGVD, a wrapper to return C_DSBGVD using objects. <br/></td></tr>
<tr class="separator:a490632701668dda426d388e6c335e6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ba8064395e2001d05847a8d0b9db96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14ba8064395e2001d05847a8d0b9db96"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a14ba8064395e2001d05847a8d0b9db96">PSI_DSBGVX</a> (int irrep, char jobz, char range, char uplo, int n, int ka, int kb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> bb, int ldbb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, double vl, double vu, int il, int iu, double abstol, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ifail)</td></tr>
<tr class="memdesc:a14ba8064395e2001d05847a8d0b9db96"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSBGVX, a wrapper to return C_DSBGVX using objects. <br/></td></tr>
<tr class="separator:a14ba8064395e2001d05847a8d0b9db96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136903ae74da15686685cefd1c093ccf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a136903ae74da15686685cefd1c093ccf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a136903ae74da15686685cefd1c093ccf">PSI_DSBTRD</a> (int irrep, char vect, char uplo, int n, int kd, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a136903ae74da15686685cefd1c093ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSBTRD, a wrapper to return C_DSBTRD using objects. <br/></td></tr>
<tr class="separator:a136903ae74da15686685cefd1c093ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad22e216c6fa24f35f9e46228245019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ad22e216c6fa24f35f9e46228245019"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9ad22e216c6fa24f35f9e46228245019">PSI_DSGESV</a> (int irrep, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iter)</td></tr>
<tr class="memdesc:a9ad22e216c6fa24f35f9e46228245019"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSGESV, a wrapper to return C_DSGESV using objects. <br/></td></tr>
<tr class="separator:a9ad22e216c6fa24f35f9e46228245019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e13cc13e00b4fa5ef8de30673438bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45e13cc13e00b4fa5ef8de30673438bd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a45e13cc13e00b4fa5ef8de30673438bd">PSI_DSTEBZ</a> (int irrep, char range, char order, int n, double vl, double vu, int il, int iu, double abstol, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; nsplit, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iblock, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; isplit, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a45e13cc13e00b4fa5ef8de30673438bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSTEBZ, a wrapper to return C_DSTEBZ using objects. <br/></td></tr>
<tr class="separator:a45e13cc13e00b4fa5ef8de30673438bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b88273a8393b5c4e63847f6e40a7609"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b88273a8393b5c4e63847f6e40a7609"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2b88273a8393b5c4e63847f6e40a7609">PSI_DSTEDC</a> (int irrep, char compz, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:a2b88273a8393b5c4e63847f6e40a7609"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSTEDC, a wrapper to return C_DSTEDC using objects. <br/></td></tr>
<tr class="separator:a2b88273a8393b5c4e63847f6e40a7609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e84c35f88c71ffbd48e4fed0499d589"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e84c35f88c71ffbd48e4fed0499d589"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9e84c35f88c71ffbd48e4fed0499d589">PSI_DSTEGR</a> (int irrep, char jobz, char range, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, double vl, double vu, int il, int iu, double abstol, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; isuppz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:a9e84c35f88c71ffbd48e4fed0499d589"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSTEGR, a wrapper to return C_DSTEGR using objects. <br/></td></tr>
<tr class="separator:a9e84c35f88c71ffbd48e4fed0499d589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa027c63d31488a099c1205db59f57299"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa027c63d31488a099c1205db59f57299"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa027c63d31488a099c1205db59f57299">PSI_DSTEIN</a> (int irrep, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, int m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iblock, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; isplit, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ifail)</td></tr>
<tr class="memdesc:aa027c63d31488a099c1205db59f57299"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSTEIN, a wrapper to return C_DSTEIN using objects. <br/></td></tr>
<tr class="separator:aa027c63d31488a099c1205db59f57299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557219dd275dce1b47525f67cb48c993"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a557219dd275dce1b47525f67cb48c993"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a557219dd275dce1b47525f67cb48c993">PSI_DSTEQR</a> (int irrep, char compz, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a557219dd275dce1b47525f67cb48c993"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSTEQR, a wrapper to return C_DSTEQR using objects. <br/></td></tr>
<tr class="separator:a557219dd275dce1b47525f67cb48c993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28123d8a63ed506c58ab6cb8971ac681"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28123d8a63ed506c58ab6cb8971ac681"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a28123d8a63ed506c58ab6cb8971ac681">PSI_DSTERF</a> (int irrep, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e)</td></tr>
<tr class="memdesc:a28123d8a63ed506c58ab6cb8971ac681"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSTERF, a wrapper to return C_DSTERF using objects. <br/></td></tr>
<tr class="separator:a28123d8a63ed506c58ab6cb8971ac681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a65766a251139abf9a9de2affbf210e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a65766a251139abf9a9de2affbf210e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0a65766a251139abf9a9de2affbf210e">PSI_DSTEV</a> (int irrep, char jobz, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a0a65766a251139abf9a9de2affbf210e"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSTEV, a wrapper to return C_DSTEV using objects. <br/></td></tr>
<tr class="separator:a0a65766a251139abf9a9de2affbf210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d58c05050dba6f5260c1db76c8919df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d58c05050dba6f5260c1db76c8919df"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9d58c05050dba6f5260c1db76c8919df">PSI_DSTEVD</a> (int irrep, char jobz, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:a9d58c05050dba6f5260c1db76c8919df"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSTEVD, a wrapper to return C_DSTEVD using objects. <br/></td></tr>
<tr class="separator:a9d58c05050dba6f5260c1db76c8919df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efa92f65a5cc10f729a8951701438da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7efa92f65a5cc10f729a8951701438da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7efa92f65a5cc10f729a8951701438da">PSI_DSTEVR</a> (int irrep, char jobz, char range, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, double vl, double vu, int il, int iu, double abstol, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; isuppz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:a7efa92f65a5cc10f729a8951701438da"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSTEVR, a wrapper to return C_DSTEVR using objects. <br/></td></tr>
<tr class="separator:a7efa92f65a5cc10f729a8951701438da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaa67950a0f2275d7cf9029b41a4bae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eaa67950a0f2275d7cf9029b41a4bae"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a6eaa67950a0f2275d7cf9029b41a4bae">PSI_DSTEVX</a> (int irrep, char jobz, char range, int n, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, double vl, double vu, int il, int iu, double abstol, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ifail)</td></tr>
<tr class="memdesc:a6eaa67950a0f2275d7cf9029b41a4bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSTEVX, a wrapper to return C_DSTEVX using objects. <br/></td></tr>
<tr class="separator:a6eaa67950a0f2275d7cf9029b41a4bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07115fb675b28087a9eb0738f076bfc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07115fb675b28087a9eb0738f076bfc1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a07115fb675b28087a9eb0738f076bfc1">PSI_DSYCON</a> (int irrep, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, double anorm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a07115fb675b28087a9eb0738f076bfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYCON, a wrapper to return C_DSYCON using objects. <br/></td></tr>
<tr class="separator:a07115fb675b28087a9eb0738f076bfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835dc67fa8e856f5855086129f0e04f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a835dc67fa8e856f5855086129f0e04f0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a835dc67fa8e856f5855086129f0e04f0">PSI_DSYEV</a> (int irrep, char jobz, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a835dc67fa8e856f5855086129f0e04f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYEV, a wrapper to return C_DSYEV using objects. <br/></td></tr>
<tr class="separator:a835dc67fa8e856f5855086129f0e04f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647bcf1c4a7cde528d3b3323605822d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a647bcf1c4a7cde528d3b3323605822d5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a647bcf1c4a7cde528d3b3323605822d5">PSI_DSYEVD</a> (int irrep, char jobz, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:a647bcf1c4a7cde528d3b3323605822d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYEVD, a wrapper to return C_DSYEVD using objects. <br/></td></tr>
<tr class="separator:a647bcf1c4a7cde528d3b3323605822d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0060f35cd949e7d9ef74ff5f75b33870"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0060f35cd949e7d9ef74ff5f75b33870"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0060f35cd949e7d9ef74ff5f75b33870">PSI_DSYEVR</a> (int irrep, char jobz, char range, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, double vl, double vu, int il, int iu, double abstol, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; isuppz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:a0060f35cd949e7d9ef74ff5f75b33870"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYEVR, a wrapper to return C_DSYEVR using objects. <br/></td></tr>
<tr class="separator:a0060f35cd949e7d9ef74ff5f75b33870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07146002f91650fd1069aa96ea1e12fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07146002f91650fd1069aa96ea1e12fb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a07146002f91650fd1069aa96ea1e12fb">PSI_DSYEVX</a> (int irrep, char jobz, char range, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, double vl, double vu, int il, int iu, double abstol, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ifail)</td></tr>
<tr class="memdesc:a07146002f91650fd1069aa96ea1e12fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYEVX, a wrapper to return C_DSYEVX using objects. <br/></td></tr>
<tr class="separator:a07146002f91650fd1069aa96ea1e12fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ae4afee9ff3b844944b525aa420c3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00ae4afee9ff3b844944b525aa420c3a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a00ae4afee9ff3b844944b525aa420c3a">PSI_DSYGST</a> (int irrep, int itype, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:a00ae4afee9ff3b844944b525aa420c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYGST, a wrapper to return C_DSYGST using objects. <br/></td></tr>
<tr class="separator:a00ae4afee9ff3b844944b525aa420c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad781399054cdf6781f38937c6add4a72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad781399054cdf6781f38937c6add4a72"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad781399054cdf6781f38937c6add4a72">PSI_DSYGV</a> (int irrep, int itype, char jobz, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:ad781399054cdf6781f38937c6add4a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYGV, a wrapper to return C_DSYGV using objects. <br/></td></tr>
<tr class="separator:ad781399054cdf6781f38937c6add4a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9fa14cfc5abbf02b1ba74a3316d2c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a9fa14cfc5abbf02b1ba74a3316d2c2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2a9fa14cfc5abbf02b1ba74a3316d2c2">PSI_DSYGVD</a> (int irrep, int itype, char jobz, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:a2a9fa14cfc5abbf02b1ba74a3316d2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYGVD, a wrapper to return C_DSYGVD using objects. <br/></td></tr>
<tr class="separator:a2a9fa14cfc5abbf02b1ba74a3316d2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc9b87d8d3356446a0f411af1fa25b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbc9b87d8d3356446a0f411af1fa25b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#abbc9b87d8d3356446a0f411af1fa25b4">PSI_DSYGVX</a> (int irrep, int itype, char jobz, char range, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, double vl, double vu, int il, int iu, double abstol, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; w, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ifail)</td></tr>
<tr class="memdesc:abbc9b87d8d3356446a0f411af1fa25b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYGVX, a wrapper to return C_DSYGVX using objects. <br/></td></tr>
<tr class="separator:abbc9b87d8d3356446a0f411af1fa25b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5493bd90d76cfb5fad130140d3a8df2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5493bd90d76cfb5fad130140d3a8df2b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5493bd90d76cfb5fad130140d3a8df2b">PSI_DSYRFS</a> (int irrep, char uplo, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> af, int ldaf, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a5493bd90d76cfb5fad130140d3a8df2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYRFS, a wrapper to return C_DSYRFS using objects. <br/></td></tr>
<tr class="separator:a5493bd90d76cfb5fad130140d3a8df2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e0f73bfcacf1ea90598f70c9d8fb0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95e0f73bfcacf1ea90598f70c9d8fb0e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a95e0f73bfcacf1ea90598f70c9d8fb0e">PSI_DSYSV</a> (int irrep, char uplo, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a95e0f73bfcacf1ea90598f70c9d8fb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYSV, a wrapper to return C_DSYSV using objects. <br/></td></tr>
<tr class="separator:a95e0f73bfcacf1ea90598f70c9d8fb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1d0449fac85dfc5ad7f30258366037"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b1d0449fac85dfc5ad7f30258366037"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1b1d0449fac85dfc5ad7f30258366037">PSI_DSYSVX</a> (int irrep, char fact, char uplo, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> af, int ldaf, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond)</td></tr>
<tr class="memdesc:a1b1d0449fac85dfc5ad7f30258366037"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYSVX, a wrapper to return C_DSYSVX using objects. <br/></td></tr>
<tr class="separator:a1b1d0449fac85dfc5ad7f30258366037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079752bde6f84b3e175a48b2ea69a99f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a079752bde6f84b3e175a48b2ea69a99f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a079752bde6f84b3e175a48b2ea69a99f">PSI_DSYTRD</a> (int irrep, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; d, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; e, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a079752bde6f84b3e175a48b2ea69a99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYTRD, a wrapper to return C_DSYTRD using objects. <br/></td></tr>
<tr class="separator:a079752bde6f84b3e175a48b2ea69a99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5481eee76cae4fcd8dacefe5c93857"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b5481eee76cae4fcd8dacefe5c93857"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8b5481eee76cae4fcd8dacefe5c93857">PSI_DSYTRF</a> (int irrep, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a8b5481eee76cae4fcd8dacefe5c93857"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYTRF, a wrapper to return C_DSYTRF using objects. <br/></td></tr>
<tr class="separator:a8b5481eee76cae4fcd8dacefe5c93857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc451832940190bc82fedfe10c0035c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dc451832940190bc82fedfe10c0035c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9dc451832940190bc82fedfe10c0035c">PSI_DSYTRI</a> (int irrep, char uplo, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a9dc451832940190bc82fedfe10c0035c"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYTRI, a wrapper to return C_DSYTRI using objects. <br/></td></tr>
<tr class="separator:a9dc451832940190bc82fedfe10c0035c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3d3600cbb18607793bfba816879fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ff3d3600cbb18607793bfba816879fe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0ff3d3600cbb18607793bfba816879fe">PSI_DSYTRS</a> (int irrep, char uplo, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ipiv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:a0ff3d3600cbb18607793bfba816879fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DSYTRS, a wrapper to return C_DSYTRS using objects. <br/></td></tr>
<tr class="separator:a0ff3d3600cbb18607793bfba816879fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67442141e58991911addcad7caf001a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67442141e58991911addcad7caf001a6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a67442141e58991911addcad7caf001a6">PSI_DTBCON</a> (int irrep, char norm, char uplo, char diag, int n, int kd, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a67442141e58991911addcad7caf001a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTBCON, a wrapper to return C_DTBCON using objects. <br/></td></tr>
<tr class="separator:a67442141e58991911addcad7caf001a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef3a3708e7b3c247c69ef7a4c977561"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abef3a3708e7b3c247c69ef7a4c977561"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#abef3a3708e7b3c247c69ef7a4c977561">PSI_DTBRFS</a> (int irrep, char uplo, char trans, char diag, int n, int kd, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:abef3a3708e7b3c247c69ef7a4c977561"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTBRFS, a wrapper to return C_DTBRFS using objects. <br/></td></tr>
<tr class="separator:abef3a3708e7b3c247c69ef7a4c977561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a4bad242ecee7f2cc3d2397a3d05fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58a4bad242ecee7f2cc3d2397a3d05fc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a58a4bad242ecee7f2cc3d2397a3d05fc">PSI_DTBTRS</a> (int irrep, char uplo, char trans, char diag, int n, int kd, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> ab, int ldab, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:a58a4bad242ecee7f2cc3d2397a3d05fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTBTRS, a wrapper to return C_DTBTRS using objects. <br/></td></tr>
<tr class="separator:a58a4bad242ecee7f2cc3d2397a3d05fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da8a4e55b8b0ff820eab55256d0cf7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5da8a4e55b8b0ff820eab55256d0cf7d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5da8a4e55b8b0ff820eab55256d0cf7d">PSI_DTGEVC</a> (int irrep, char side, char howmny, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> s, int lds, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> p, int ldp, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vl, int ldvl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vr, int ldvr, int mm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a5da8a4e55b8b0ff820eab55256d0cf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTGEVC, a wrapper to return C_DTGEVC using objects. <br/></td></tr>
<tr class="separator:a5da8a4e55b8b0ff820eab55256d0cf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7568fbe6accdd08dbe69d7d203b89962"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7568fbe6accdd08dbe69d7d203b89962"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7568fbe6accdd08dbe69d7d203b89962">PSI_DTGEXC</a> (int irrep, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ifst, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ilst, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:a7568fbe6accdd08dbe69d7d203b89962"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTGEXC, a wrapper to return C_DTGEXC using objects. <br/></td></tr>
<tr class="separator:a7568fbe6accdd08dbe69d7d203b89962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d1eff46a769744c61f7695d770f2b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00d1eff46a769744c61f7695d770f2b0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a00d1eff46a769744c61f7695d770f2b0">PSI_DTGSEN</a> (int irrep, int ijob, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphar, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alphai, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> z, int ldz, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; pl, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; pr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dif, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:a00d1eff46a769744c61f7695d770f2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTGSEN, a wrapper to return C_DTGSEN using objects. <br/></td></tr>
<tr class="separator:a00d1eff46a769744c61f7695d770f2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9005e50838f18250283643e6253ceb72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9005e50838f18250283643e6253ceb72"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9005e50838f18250283643e6253ceb72">PSI_DTGSJA</a> (int irrep, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, double tola, double tolb, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; alpha, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; beta, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> u, int ldu, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> v, int ldv, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ncycle)</td></tr>
<tr class="memdesc:a9005e50838f18250283643e6253ceb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTGSJA, a wrapper to return C_DTGSJA using objects. <br/></td></tr>
<tr class="separator:a9005e50838f18250283643e6253ceb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9f3dacb26543696bfaa3ffcffd6518"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f9f3dacb26543696bfaa3ffcffd6518"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5f9f3dacb26543696bfaa3ffcffd6518">PSI_DTGSNA</a> (int irrep, char job, char howmny, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vl, int ldvl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vr, int ldvr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; s, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dif, int mm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a5f9f3dacb26543696bfaa3ffcffd6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTGSNA, a wrapper to return C_DTGSNA using objects. <br/></td></tr>
<tr class="separator:a5f9f3dacb26543696bfaa3ffcffd6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3c127adc4f7bacef191e6a76619a2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f3c127adc4f7bacef191e6a76619a2a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3f3c127adc4f7bacef191e6a76619a2a">PSI_DTGSYL</a> (int irrep, char trans, int ijob, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> d, int ldd, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> e, int lde, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> f, int ldf, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; dif, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; scale, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a3f3c127adc4f7bacef191e6a76619a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTGSYL, a wrapper to return C_DTGSYL using objects. <br/></td></tr>
<tr class="separator:a3f3c127adc4f7bacef191e6a76619a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa276cb62d4aaa8e2b7c083565f73a361"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa276cb62d4aaa8e2b7c083565f73a361"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa276cb62d4aaa8e2b7c083565f73a361">PSI_DTRCON</a> (int irrep, char norm, char uplo, char diag, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; rcond, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:aa276cb62d4aaa8e2b7c083565f73a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRCON, a wrapper to return C_DTRCON using objects. <br/></td></tr>
<tr class="separator:aa276cb62d4aaa8e2b7c083565f73a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36619f8b6d2c563db03c3df29f05c893"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36619f8b6d2c563db03c3df29f05c893"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a36619f8b6d2c563db03c3df29f05c893">PSI_DTREVC</a> (int irrep, char side, char howmny, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> t, int ldt, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vl, int ldvl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vr, int ldvr, int mm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a36619f8b6d2c563db03c3df29f05c893"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTREVC, a wrapper to return C_DTREVC using objects. <br/></td></tr>
<tr class="separator:a36619f8b6d2c563db03c3df29f05c893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1f504f02a087f3983b19034cb4ec33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d1f504f02a087f3983b19034cb4ec33"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3d1f504f02a087f3983b19034cb4ec33">PSI_DTREXC</a> (int irrep, char compq, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> t, int ldt, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ifst, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; ilst, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work)</td></tr>
<tr class="memdesc:a3d1f504f02a087f3983b19034cb4ec33"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTREXC, a wrapper to return C_DTREXC using objects. <br/></td></tr>
<tr class="separator:a3d1f504f02a087f3983b19034cb4ec33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1551b1e7ffa20109ea34bca1d93fab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d1551b1e7ffa20109ea34bca1d93fab"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2d1551b1e7ffa20109ea34bca1d93fab">PSI_DTRRFS</a> (int irrep, char uplo, char trans, char diag, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> x, int ldx, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; ferr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; berr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a2d1551b1e7ffa20109ea34bca1d93fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRRFS, a wrapper to return C_DTRRFS using objects. <br/></td></tr>
<tr class="separator:a2d1551b1e7ffa20109ea34bca1d93fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6947b50facdf6bd57cd487e1db33c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae6947b50facdf6bd57cd487e1db33c5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aae6947b50facdf6bd57cd487e1db33c5">PSI_DTRSEN</a> (int irrep, char job, char compq, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> t, int ldt, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> q, int ldq, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; wi, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; s, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; sep, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork, int liwork)</td></tr>
<tr class="memdesc:aae6947b50facdf6bd57cd487e1db33c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRSEN, a wrapper to return C_DTRSEN using objects. <br/></td></tr>
<tr class="separator:aae6947b50facdf6bd57cd487e1db33c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5132878c727a0037039bbd26d0af0b90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5132878c727a0037039bbd26d0af0b90"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5132878c727a0037039bbd26d0af0b90">PSI_DTRSNA</a> (int irrep, char job, char howmny, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> t, int ldt, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vl, int ldvl, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> vr, int ldvr, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; s, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; sep, int mm, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; m, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> work, int ldwork, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1IntVector.html">IntVector</a> &gt; iwork)</td></tr>
<tr class="memdesc:a5132878c727a0037039bbd26d0af0b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRSNA, a wrapper to return C_DTRSNA using objects. <br/></td></tr>
<tr class="separator:a5132878c727a0037039bbd26d0af0b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d22fa123c2ecde22c543059bde50160"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d22fa123c2ecde22c543059bde50160"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0d22fa123c2ecde22c543059bde50160">PSI_DTRSYL</a> (int irrep, char trana, char tranb, int isgn, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> c, int ldc, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; scale)</td></tr>
<tr class="memdesc:a0d22fa123c2ecde22c543059bde50160"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRSYL, a wrapper to return C_DTRSYL using objects. <br/></td></tr>
<tr class="separator:a0d22fa123c2ecde22c543059bde50160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70eed9989413e3bc594c114fe405316"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab70eed9989413e3bc594c114fe405316"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab70eed9989413e3bc594c114fe405316">PSI_DTRTRI</a> (int irrep, char uplo, char diag, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda)</td></tr>
<tr class="memdesc:ab70eed9989413e3bc594c114fe405316"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRTRI, a wrapper to return C_DTRTRI using objects. <br/></td></tr>
<tr class="separator:ab70eed9989413e3bc594c114fe405316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb4dfd0081ff2fd4e78a07b221537a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eb4dfd0081ff2fd4e78a07b221537a2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a6eb4dfd0081ff2fd4e78a07b221537a2">PSI_DTRTRS</a> (int irrep, char uplo, char trans, char diag, int n, int nrhs, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> b, int ldb)</td></tr>
<tr class="memdesc:a6eb4dfd0081ff2fd4e78a07b221537a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTRTRS, a wrapper to return C_DTRTRS using objects. <br/></td></tr>
<tr class="separator:a6eb4dfd0081ff2fd4e78a07b221537a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f225f9cbd566ab0336adeec82c9bd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2f225f9cbd566ab0336adeec82c9bd9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af2f225f9cbd566ab0336adeec82c9bd9">PSI_DTZRQF</a> (int irrep, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau)</td></tr>
<tr class="memdesc:af2f225f9cbd566ab0336adeec82c9bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTZRQF, a wrapper to return C_DTZRQF using objects. <br/></td></tr>
<tr class="separator:af2f225f9cbd566ab0336adeec82c9bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad79ef021f836da125fa52c079326414"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad79ef021f836da125fa52c079326414"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aad79ef021f836da125fa52c079326414">PSI_DTZRZF</a> (int irrep, int m, int n, <a class="el" href="classboost_1_1shared__ptr.html">SharedMatrix</a> a, int lda, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; tau, <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Vector.html">Vector</a> &gt; work, int lwork)</td></tr>
<tr class="memdesc:aad79ef021f836da125fa52c079326414"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSI_DTZRZF, a wrapper to return C_DTZRZF using objects. <br/></td></tr>
<tr class="separator:aad79ef021f836da125fa52c079326414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23fce87757da4793e96bd8687d69f71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab23fce87757da4793e96bd8687d69f71"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>is_big_endian</b> (void)</td></tr>
<tr class="separator:ab23fce87757da4793e96bd8687d69f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05bb69e2e078c57670e875822e6737c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab05bb69e2e078c57670e875822e6737c"></a>
template&lt;typename vectType &gt; </td></tr>
<tr class="memitem:ab05bb69e2e078c57670e875822e6737c"><td class="memTemplItemLeft" align="right" valign="top">boost::python::tuple&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_tuple</b> (std::vector&lt; vectType &gt; v)</td></tr>
<tr class="separator:ab05bb69e2e078c57670e875822e6737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae214c7177933f03c0548e1068f97d82d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae214c7177933f03c0548e1068f97d82d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae214c7177933f03c0548e1068f97d82d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap_index</b> (T &amp;a, T &amp;b)</td></tr>
<tr class="separator:ae214c7177933f03c0548e1068f97d82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44129fd50e7595ea05350a305c9c5aa2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44129fd50e7595ea05350a305c9c5aa2"></a>
<a class="el" href="classpsi_1_1Vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double, const <a class="el" href="classpsi_1_1Vector3.html">Vector3</a> &amp;)</td></tr>
<tr class="separator:a44129fd50e7595ea05350a305c9c5aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af964b7270594a2a031b0355a5bd3b727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af964b7270594a2a031b0355a5bd3b727"></a>
boost::python::list&#160;</td><td class="memItemRight" valign="bottom"><b>fill_list</b> (boost::python::list l, <a class="el" href="classpsi_1_1Data.html">Data</a> d)</td></tr>
<tr class="separator:af964b7270594a2a031b0355a5bd3b727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e43c1d115f4c13903cc3fff0b86185"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4e43c1d115f4c13903cc3fff0b86185"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_openmp</b> ()</td></tr>
<tr class="separator:ac4e43c1d115f4c13903cc3fff0b86185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf603ee4c8034050fd4d1a9076b095b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf603ee4c8034050fd4d1a9076b095b0"></a>
<a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1LocalCommWrapper.html">worldcomm</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>initialize_communicator</b> (const int &amp;argc, char **argv)</td></tr>
<tr class="separator:aaf603ee4c8034050fd4d1a9076b095b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d65dae305bfe8987a16ce3107ab6a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6d65dae305bfe8987a16ce3107ab6a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>die_if_not_converged</b> ()</td></tr>
<tr class="separator:af6d65dae305bfe8987a16ce3107ab6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351ad90d7b017659728bc4e7f1a5e242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a351ad90d7b017659728bc4e7f1a5e242">plugin_close</a> (const <a class="el" href="structpsi_1_1plugin__info__struct.html">plugin_info</a> &amp;info)</td></tr>
<tr class="separator:a351ad90d7b017659728bc4e7f1a5e242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1171b74448d1f0cd7ac743ef20cf5685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpsi_1_1plugin__info__struct.html">plugin_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1171b74448d1f0cd7ac743ef20cf5685">plugin_load</a> (std::string &amp;plugin_path)</td></tr>
<tr class="separator:a1171b74448d1f0cd7ac743ef20cf5685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2f90f3e26e76651104c3e2abb85a25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add2f90f3e26e76651104c3e2abb85a25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_plugin</b> ()</td></tr>
<tr class="separator:add2f90f3e26e76651104c3e2abb85a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efc291af4bf4e0e1fc061f3eebeddf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9efc291af4bf4e0e1fc061f3eebeddf1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_close</b> (unsigned int unit, int keep)</td></tr>
<tr class="separator:a9efc291af4bf4e0e1fc061f3eebeddf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa697cccf1b853999c317c2df7982cd7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa697cccf1b853999c317c2df7982cd7d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_done</b> (void)</td></tr>
<tr class="separator:aa697cccf1b853999c317c2df7982cd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6c081b5776af1cc3d21a8a1cb5c337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga1e6c081b5776af1cc3d21a8a1cb5c337">psio_error</a> (unsigned int unit, unsigned int errval)</td></tr>
<tr class="separator:ga1e6c081b5776af1cc3d21a8a1cb5c337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2df5fbb98dd56bff96dd0a534fbc7d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2df5fbb98dd56bff96dd0a534fbc7d6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>fullkwd</b> (const char *kwdgrp, const char *kwd, int unit)</td></tr>
<tr class="separator:aa2df5fbb98dd56bff96dd0a534fbc7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1301313630d3bf971848526d3e1685"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace1301313630d3bf971848526d3e1685"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_set_filescfg_kwd</b> (const char *kwdgrp, const char *kwd, int unit, const char *kwdval)</td></tr>
<tr class="separator:ace1301313630d3bf971848526d3e1685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877894374a2c556224ad287fed3bca39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a877894374a2c556224ad287fed3bca39"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>psio_get_filescfg_kwd</b> (const char *kwdgrp, const char *kwd, int unit)</td></tr>
<tr class="separator:a877894374a2c556224ad287fed3bca39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd1b580899ec1cec5064f2cb0058a364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpsi_1_1psio__address.html">psio_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#gacd1b580899ec1cec5064f2cb0058a364">psio_get_address</a> (<a class="el" href="structpsi_1_1psio__address.html">psio_address</a> start, ULI shift)</td></tr>
<tr class="separator:gacd1b580899ec1cec5064f2cb0058a364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe95514e1e3870102b83a62269f1b91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbe95514e1e3870102b83a62269f1b91"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_get_filename_default</b> (char **name)</td></tr>
<tr class="separator:acbe95514e1e3870102b83a62269f1b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760073b297d2340a38f2771b5b13560f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpsi_1_1psio__address.html">psio_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga760073b297d2340a38f2771b5b13560f">psio_get_global_address</a> (<a class="el" href="structpsi_1_1psio__address.html">psio_address</a> entry_start, <a class="el" href="structpsi_1_1psio__address.html">psio_address</a> rel_address)</td></tr>
<tr class="separator:ga760073b297d2340a38f2771b5b13560f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f46e501df8c452884eadf03c4ae44b2"><td class="memItemLeft" align="right" valign="top">ULI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga2f46e501df8c452884eadf03c4ae44b2">psio_get_length</a> (<a class="el" href="structpsi_1_1psio__address.html">psio_address</a> sadd, <a class="el" href="structpsi_1_1psio__address.html">psio_address</a> eadd)</td></tr>
<tr class="separator:ga2f46e501df8c452884eadf03c4ae44b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302f65e2774ffc6a5235e84e99a0ca50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a302f65e2774ffc6a5235e84e99a0ca50"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_get_numvols_default</b> (void)</td></tr>
<tr class="separator:a302f65e2774ffc6a5235e84e99a0ca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe167621542db0d10c0605d14c4ce6bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe167621542db0d10c0605d14c4ce6bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_get_volpath_default</b> (unsigned int volume, char **path)</td></tr>
<tr class="separator:afe167621542db0d10c0605d14c4ce6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f42bdba940f8022cea3616f711c036e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f42bdba940f8022cea3616f711c036e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_init</b> (void)</td></tr>
<tr class="separator:a5f42bdba940f8022cea3616f711c036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d00af535912c5c071167d60cb07b336"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d00af535912c5c071167d60cb07b336"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_state</b> ()</td></tr>
<tr class="separator:a2d00af535912c5c071167d60cb07b336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76318623c3ef7a7449d2079c022cb9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af76318623c3ef7a7449d2079c022cb9f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_open</b> (unsigned int unit, int status)</td></tr>
<tr class="separator:af76318623c3ef7a7449d2079c022cb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea5452f8e228d0cd2d8e136d2e98c4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga2ea5452f8e228d0cd2d8e136d2e98c4a">psio_open_check</a> (unsigned int unit)</td></tr>
<tr class="separator:ga2ea5452f8e228d0cd2d8e136d2e98c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3414d79b13b070717da891b2f469337e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3414d79b13b070717da891b2f469337e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_ipv1_config</b> (void)</td></tr>
<tr class="separator:a3414d79b13b070717da891b2f469337e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0608b284b1f4b703c858612d39bef88c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga0608b284b1f4b703c858612d39bef88c">psio_volseek</a> (<a class="el" href="structpsi_1_1psio__vol.html">psio_vol</a> *vol, ULI page, ULI offset, ULI numvols)</td></tr>
<tr class="separator:ga0608b284b1f4b703c858612d39bef88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b37f33876c34cf733f7dca49e4012ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b37f33876c34cf733f7dca49e4012ea"></a>
<a class="el" href="structpsi_1_1psio__address.html">psio_address</a>&#160;</td><td class="memItemRight" valign="bottom"><b>psio_get_entry_end</b> (unsigned int unit, const char *key)</td></tr>
<tr class="separator:a3b37f33876c34cf733f7dca49e4012ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee16f35954f733e1fce461d5981e3871"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#gaee16f35954f733e1fce461d5981e3871">psio_tocwrite</a> (unsigned int unit)</td></tr>
<tr class="separator:gaee16f35954f733e1fce461d5981e3871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dcb17e092c36e1f7a8950ace9d1641"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45dcb17e092c36e1f7a8950ace9d1641"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_tocread</b> (unsigned int unit)</td></tr>
<tr class="separator:a45dcb17e092c36e1f7a8950ace9d1641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69f3312c6d1700667a7da89b162be8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af69f3312c6d1700667a7da89b162be8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>psio_tocprint</b> (unsigned int unit, FILE *output)</td></tr>
<tr class="separator:af69f3312c6d1700667a7da89b162be8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb84738717252302864b0da5f6f65f9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpsi_1_1psio__entry.html">psio_tocentry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#gabb84738717252302864b0da5f6f65f9d">psio_tocscan</a> (unsigned int unit, const char *key)</td></tr>
<tr class="separator:gabb84738717252302864b0da5f6f65f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga269f710f213f224afabb8e16d88d157a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga269f710f213f224afabb8e16d88d157a">psio_tocentry_exists</a> (unsigned int unit, const char *key)</td></tr>
<tr class="separator:ga269f710f213f224afabb8e16d88d157a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12481c416666870e40bcb3fd078280e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa12481c416666870e40bcb3fd078280e"></a>
<a class="el" href="structpsi_1_1psio__entry.html">psio_tocentry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>psio_toclast</b> (unsigned int unit)</td></tr>
<tr class="separator:aa12481c416666870e40bcb3fd078280e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf727d581db32a2fcff675f776b7513c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#gaf727d581db32a2fcff675f776b7513c9">psio_tocclean</a> (unsigned int unit, const char *key)</td></tr>
<tr class="separator:gaf727d581db32a2fcff675f776b7513c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac73c196234f26dcd094674cc29a6b18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#gaac73c196234f26dcd094674cc29a6b18">psio_write</a> (unsigned int unit, const char *key, char *buffer, ULI size, <a class="el" href="structpsi_1_1psio__address.html">psio_address</a> sadd, <a class="el" href="structpsi_1_1psio__address.html">psio_address</a> *eadd)</td></tr>
<tr class="separator:gaac73c196234f26dcd094674cc29a6b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb52625f96f6373eca3de9dcdf9487f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga7fb52625f96f6373eca3de9dcdf9487f">psio_read</a> (unsigned int unit, const char *key, char *buffer, ULI size, <a class="el" href="structpsi_1_1psio__address.html">psio_address</a> sadd, <a class="el" href="structpsi_1_1psio__address.html">psio_address</a> *eadd)</td></tr>
<tr class="separator:ga7fb52625f96f6373eca3de9dcdf9487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6767d56ea81c4ea0ac62ec194fc4e6e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga6767d56ea81c4ea0ac62ec194fc4e6e3">psio_write_entry</a> (unsigned int unit, const char *key, char *buffer, ULI size)</td></tr>
<tr class="separator:ga6767d56ea81c4ea0ac62ec194fc4e6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f8fc4eb069614c46d11d44646251e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga99f8fc4eb069614c46d11d44646251e6">psio_read_entry</a> (unsigned int unit, const char *key, char *buffer, ULI size)</td></tr>
<tr class="separator:ga99f8fc4eb069614c46d11d44646251e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088ebf47db2580c792c9e681aed541d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a088ebf47db2580c792c9e681aed541d2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_write_block</b> (unsigned int unit, const char *key, char *buffer, ULI blksiz, ULI start_blk, ULI end_blk)</td></tr>
<tr class="separator:a088ebf47db2580c792c9e681aed541d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01910eab6cc2e8f59461e8dbca7a1ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac01910eab6cc2e8f59461e8dbca7a1ba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_read_block</b> (unsigned int unit, const char *key, char *buffer, ULI blksiz, ULI start_blk, ULI end_blk)</td></tr>
<tr class="separator:ac01910eab6cc2e8f59461e8dbca7a1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7636f5e11d8d7b9a88a215529e907abe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga7636f5e11d8d7b9a88a215529e907abe">psio_rw</a> (unsigned int unit, char *buffer, <a class="el" href="structpsi_1_1psio__address.html">psio_address</a> address, ULI size, int wrt)</td></tr>
<tr class="separator:ga7636f5e11d8d7b9a88a215529e907abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db93195c4a40ccd0e2b30c6743dffec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#ga0db93195c4a40ccd0e2b30c6743dffec">psio_zero_disk</a> (unsigned int unit, const char *key, ULI rows, ULI cols)</td></tr>
<tr class="separator:ga0db93195c4a40ccd0e2b30c6743dffec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809646a6acab727f4b9ed1d290674e7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a809646a6acab727f4b9ed1d290674e7e"></a>
unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><b>psio_rd_toclen</b> (unsigned int unit)</td></tr>
<tr class="separator:a809646a6acab727f4b9ed1d290674e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736fdaa34ea25f6d46b6ad6aafd41568"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a736fdaa34ea25f6d46b6ad6aafd41568"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>psio_wt_toclen</b> (unsigned int unit, ULI toclen)</td></tr>
<tr class="separator:a736fdaa34ea25f6d46b6ad6aafd41568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036768c1944af4ceeb6581680704b282"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a036768c1944af4ceeb6581680704b282"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>psio_tocdel</b> (unsigned int unit, const char *key)</td></tr>
<tr class="separator:a036768c1944af4ceeb6581680704b282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb89095e5de3b1f75516254d0e5f0951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSIO.html#gacb89095e5de3b1f75516254d0e5f0951">psio_tocprint</a> (unsigned int unit)</td></tr>
<tr class="separator:gacb89095e5de3b1f75516254d0e5f0951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59a60b96011b32445e146d038e437c78"><td class="memItemLeft" align="right" valign="top">double ***&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga59a60b96011b32445e146d038e437c78">init_3d_array</a> (int p, int q, int r)</td></tr>
<tr class="separator:ga59a60b96011b32445e146d038e437c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8cf84ee88f3deeb68a4aa21b2b967d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga7f8cf84ee88f3deeb68a4aa21b2b967d">free_3d_array</a> (double ***A, int p, int q)</td></tr>
<tr class="separator:ga7f8cf84ee88f3deeb68a4aa21b2b967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ba35d35184dab8f9ad1eac331e4747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga33ba35d35184dab8f9ad1eac331e4747">C_DSWAP</a> (unsigned long int length, double *x, int inc_x, double *y, int inc_y)</td></tr>
<tr class="separator:ga33ba35d35184dab8f9ad1eac331e4747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef01298916a61134e83eeb4c9649a0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gafef01298916a61134e83eeb4c9649a0d">C_DAXPY</a> (unsigned long int length, double a, double *x, int inc_x, double *y, int inc_y)</td></tr>
<tr class="separator:gafef01298916a61134e83eeb4c9649a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada1f89a2db3689c3e7482ea755b49b27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gada1f89a2db3689c3e7482ea755b49b27">C_DCOPY</a> (unsigned long int length, double *x, int inc_x, double *y, int inc_y)</td></tr>
<tr class="separator:gada1f89a2db3689c3e7482ea755b49b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed877a653f8542c11a21987ae0f1e160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaed877a653f8542c11a21987ae0f1e160">C_DSCAL</a> (unsigned long int length, double alpha, double *vec, int inc)</td></tr>
<tr class="separator:gaed877a653f8542c11a21987ae0f1e160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb95a4ea160026291b1850b3571d5ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gafbb95a4ea160026291b1850b3571d5ed">C_DROT</a> (unsigned long int length, double *x, int inc_x, double *y, int inc_y, double costheta, double sintheta)</td></tr>
<tr class="separator:gafbb95a4ea160026291b1850b3571d5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff0d5067135afa4228460272b6b4781"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gafff0d5067135afa4228460272b6b4781">C_DDOT</a> (unsigned long int length, double *x, int inc_x, double *y, int inc_y)</td></tr>
<tr class="separator:gafff0d5067135afa4228460272b6b4781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1644e8ee3f7b6bb32137457a7dde7aa2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga1644e8ee3f7b6bb32137457a7dde7aa2">C_DNRM2</a> (unsigned long int length, double *x, int inc_x)</td></tr>
<tr class="separator:ga1644e8ee3f7b6bb32137457a7dde7aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b975bb8c1f54920f23214df365d3021"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga4b975bb8c1f54920f23214df365d3021">C_DASUM</a> (unsigned long int length, double *x, int inc_x)</td></tr>
<tr class="separator:ga4b975bb8c1f54920f23214df365d3021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d473748326ef68bd4af5fd4e9ff5e44"><td class="memItemLeft" align="right" valign="top">unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga3d473748326ef68bd4af5fd4e9ff5e44">C_IDAMAX</a> (unsigned long int length, double *x, int inc_x)</td></tr>
<tr class="separator:ga3d473748326ef68bd4af5fd4e9ff5e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf72d8f7785638e11663c452949cd837"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#adf72d8f7785638e11663c452949cd837">C_DGBMV</a> (char trans, int m, int n, int kl, int ku, double alpha, double *a, int lda, double *x, int incx, double beta, double *y, int incy)</td></tr>
<tr class="separator:adf72d8f7785638e11663c452949cd837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1112df35ff9d2b780efb0c24662f4fbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1112df35ff9d2b780efb0c24662f4fbe">C_DGEMM</a> (char transa, char transb, int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc)</td></tr>
<tr class="separator:a1112df35ff9d2b780efb0c24662f4fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f839afc1a7e4950dbaa3521e5eae60f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8f839afc1a7e4950dbaa3521e5eae60f">C_DGEMV</a> (char trans, int m, int n, double alpha, double *a, int lda, double *x, int incx, double beta, double *y, int incy)</td></tr>
<tr class="separator:a8f839afc1a7e4950dbaa3521e5eae60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa167c724fe9d2511e1f80dbe5125425e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa167c724fe9d2511e1f80dbe5125425e">C_DGER</a> (int m, int n, double alpha, double *x, int incx, double *y, int incy, double *a, int lda)</td></tr>
<tr class="separator:aa167c724fe9d2511e1f80dbe5125425e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ef675ad1d23833b56dcfa08c472a6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af8ef675ad1d23833b56dcfa08c472a6f">C_DSBMV</a> (char uplo, int n, int k, double alpha, double *a, int lda, double *x, int incx, double beta, double *y, int incy)</td></tr>
<tr class="separator:af8ef675ad1d23833b56dcfa08c472a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578640bdc458d6255fb3574cf44458e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a578640bdc458d6255fb3574cf44458e0">C_DSPMV</a> (char uplo, int n, double alpha, double *ap, double *x, int incx, double beta, double *y, int incy)</td></tr>
<tr class="separator:a578640bdc458d6255fb3574cf44458e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dc1454fea66f51e69160ce81c93dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a03dc1454fea66f51e69160ce81c93dad">C_DSPR</a> (char uplo, int n, double alpha, double *x, int incx, double *ap)</td></tr>
<tr class="separator:a03dc1454fea66f51e69160ce81c93dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802f990824aac31392726f25ae485dfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a802f990824aac31392726f25ae485dfb">C_DSPR2</a> (char uplo, int n, double alpha, double *x, int incx, double *y, int incy, double *ap)</td></tr>
<tr class="separator:a802f990824aac31392726f25ae485dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e145bee7a002ac8c18e937785bd9458"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0e145bee7a002ac8c18e937785bd9458">C_DSYMM</a> (char side, char uplo, int m, int n, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc)</td></tr>
<tr class="separator:a0e145bee7a002ac8c18e937785bd9458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdb48b49b81618559003ca88bba0fd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aacdb48b49b81618559003ca88bba0fd7">C_DSYMV</a> (char uplo, int n, double alpha, double *a, int lda, double *x, int incx, double beta, double *y, int incy)</td></tr>
<tr class="separator:aacdb48b49b81618559003ca88bba0fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d05ad2ab40ece27f2c94bec3657934a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5d05ad2ab40ece27f2c94bec3657934a">C_DSYR</a> (char uplo, int n, double alpha, double *x, int incx, double *a, int lda)</td></tr>
<tr class="separator:a5d05ad2ab40ece27f2c94bec3657934a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aedb5dd9fe6d44750869f3be82bc046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8aedb5dd9fe6d44750869f3be82bc046">C_DSYR2</a> (char uplo, int n, double alpha, double *x, int incx, double *y, int incy, double *a, int lda)</td></tr>
<tr class="separator:a8aedb5dd9fe6d44750869f3be82bc046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b3243d6eabf332ee415467850ef4d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a10b3243d6eabf332ee415467850ef4d8">C_DSYR2K</a> (char uplo, char trans, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc)</td></tr>
<tr class="separator:a10b3243d6eabf332ee415467850ef4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c68c2448c385f06cfa6c742ce07a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af0c68c2448c385f06cfa6c742ce07a73">C_DSYRK</a> (char uplo, char trans, int n, int k, double alpha, double *a, int lda, double beta, double *c, int ldc)</td></tr>
<tr class="separator:af0c68c2448c385f06cfa6c742ce07a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f17a8c5a84c684b22abf73bb511201d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0f17a8c5a84c684b22abf73bb511201d">C_DTBMV</a> (char uplo, char trans, char diag, int n, int k, double *a, int lda, double *x, int incx)</td></tr>
<tr class="separator:a0f17a8c5a84c684b22abf73bb511201d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f17f7a08338252e157868c4d66d7db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2f17f7a08338252e157868c4d66d7db0">C_DTBSV</a> (char uplo, char trans, char diag, int n, int k, double *a, int lda, double *x, int incx)</td></tr>
<tr class="separator:a2f17f7a08338252e157868c4d66d7db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db6b9a025813c7aea8455a75567dbee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0db6b9a025813c7aea8455a75567dbee">C_DTPMV</a> (char uplo, char trans, char diag, int n, double *ap, double *x, int incx)</td></tr>
<tr class="separator:a0db6b9a025813c7aea8455a75567dbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5b5ba0433df8294c0def4896b138c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#acd5b5ba0433df8294c0def4896b138c7">C_DTPSV</a> (char uplo, char trans, char diag, int n, double *ap, double *x, int incx)</td></tr>
<tr class="separator:acd5b5ba0433df8294c0def4896b138c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b620f8268d58b37f94c9fc266a0358b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3b620f8268d58b37f94c9fc266a0358b">C_DTRMM</a> (char side, char uplo, char transa, char diag, int m, int n, double alpha, double *a, int lda, double *b, int ldb)</td></tr>
<tr class="separator:a3b620f8268d58b37f94c9fc266a0358b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c4e138f4d0df19978ce97df5c883d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a55c4e138f4d0df19978ce97df5c883d7">C_DTRMV</a> (char uplo, char trans, char diag, int n, double *a, int lda, double *x, int incx)</td></tr>
<tr class="separator:a55c4e138f4d0df19978ce97df5c883d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0225f4475c4669d9cc5fcd37de83df4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa0225f4475c4669d9cc5fcd37de83df4">C_DTRSM</a> (char side, char uplo, char transa, char diag, int m, int n, double alpha, double *a, int lda, double *b, int ldb)</td></tr>
<tr class="separator:aa0225f4475c4669d9cc5fcd37de83df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d133d20ff03aade192008e23ec5c592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0d133d20ff03aade192008e23ec5c592">C_DTRSV</a> (char uplo, char trans, char diag, int n, double *a, int lda, double *x, int incx)</td></tr>
<tr class="separator:a0d133d20ff03aade192008e23ec5c592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7dba6467743ab41c4e2efbb9bba5595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gac7dba6467743ab41c4e2efbb9bba5595">cc_excited</a> (const char *wfn)</td></tr>
<tr class="separator:gac7dba6467743ab41c4e2efbb9bba5595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ed72ce0e58f61793f21acb5fe0c244"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad3ed72ce0e58f61793f21acb5fe0c244">cc_excited</a> (std::string wfn)</td></tr>
<tr class="separator:gad3ed72ce0e58f61793f21acb5fe0c244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4348565874a4f55aa86efe4ef336cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad4348565874a4f55aa86efe4ef336cde">cc_wfn</a> (const char *wfn)</td></tr>
<tr class="separator:gad4348565874a4f55aa86efe4ef336cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9287456500de60c9fa5b733b633340b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga9287456500de60c9fa5b733b633340b3">cc_wfn</a> (std::string wfn)</td></tr>
<tr class="separator:ga9287456500de60c9fa5b733b633340b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5897677944b94d2ec0555dd9cdd0a8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaa5897677944b94d2ec0555dd9cdd0a8e">ci_wfn</a> (char *wfn)</td></tr>
<tr class="separator:gaa5897677944b94d2ec0555dd9cdd0a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa457150c780cf1438b4b7f859e3205cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaa457150c780cf1438b4b7f859e3205cd">ci_wfn</a> (std::string wfn)</td></tr>
<tr class="separator:gaa457150c780cf1438b4b7f859e3205cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c6345ae60fb29588e8d1064f8f53d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaf4c6345ae60fb29588e8d1064f8f53d1">david</a> (double **A, int N, int M, double *eps, double **v, double cutoff, int print)</td></tr>
<tr class="separator:gaf4c6345ae60fb29588e8d1064f8f53d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67e10fae2a18289df311c94705919d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaf67e10fae2a18289df311c94705919d8">dirprd_block</a> (double **A, double **B, int rows, int cols)</td></tr>
<tr class="separator:gaf67e10fae2a18289df311c94705919d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc510b7f8d584d53d58a2d7a92e71c4d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gabc510b7f8d584d53d58a2d7a92e71c4d">dot_block</a> (double **A, double **B, int rows, int cols, double alpha)</td></tr>
<tr class="separator:gabc510b7f8d584d53d58a2d7a92e71c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa15d12a712baae0fc3b85e2a8653d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fa15d12a712baae0fc3b85e2a8653d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dx_read</b> (double **V_eff, double *phi_ao, double *phi_so, int nao, int nso, double **u)</td></tr>
<tr class="separator:a1fa15d12a712baae0fc3b85e2a8653d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d90c21faf720484006af6bc578665fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d90c21faf720484006af6bc578665fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compute_delta</b> (double **delta, double x, double y, double z)</td></tr>
<tr class="separator:a9d90c21faf720484006af6bc578665fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8a37469940eb8dfcbd114d498bbf9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba8a37469940eb8dfcbd114d498bbf9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dx_write</b> (<a class="el" href="classpsi_1_1Options.html">Options</a> &amp;options, double **D)</td></tr>
<tr class="separator:aba8a37469940eb8dfcbd114d498bbf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcbafb11f8276be426b80299e25ff45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaedcbafb11f8276be426b80299e25ff45">fill_sym_matrix</a> (double **A, int size)</td></tr>
<tr class="separator:gaedcbafb11f8276be426b80299e25ff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad18063cef37be3eef59d317e7a26e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga6ad18063cef37be3eef59d317e7a26e4">filter</a> (double *input, double *output, int *ioff, int norbs, int nfzc, int nfzv)</td></tr>
<tr class="separator:ga6ad18063cef37be3eef59d317e7a26e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa00bb931504d4953c047ee58e7ba317"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaaa00bb931504d4953c047ee58e7ba317">invert_matrix</a> (double **a, double **y, int N, FILE *outfile)</td></tr>
<tr class="separator:gaaa00bb931504d4953c047ee58e7ba317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66862c945488d9fa731dfa4eeb10e544"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a66862c945488d9fa731dfa4eeb10e544">C_DBDSDC</a> (char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq, double *work, int *iwork)</td></tr>
<tr class="separator:a66862c945488d9fa731dfa4eeb10e544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e826a4309944c7c2f2a0a54be9f266e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5e826a4309944c7c2f2a0a54be9f266e">C_DBDSQR</a> (char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc, double *work)</td></tr>
<tr class="separator:a5e826a4309944c7c2f2a0a54be9f266e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b5dce6c9d8bb417e5c2e2b61c1c1a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af2b5dce6c9d8bb417e5c2e2b61c1c1a9">C_DDISNA</a> (char job, int m, int n, double *d, double *sep)</td></tr>
<tr class="separator:af2b5dce6c9d8bb417e5c2e2b61c1c1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6ff6ab338614b293754546378e4b72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#acd6ff6ab338614b293754546378e4b72">C_DGBBRD</a> (char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc, double *work)</td></tr>
<tr class="separator:acd6ff6ab338614b293754546378e4b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f5101c304b7cf551a3ad44c8330d9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a28f5101c304b7cf551a3ad44c8330d9e">C_DGBCON</a> (char norm, int n, int kl, int ku, double *ab, int ldab, int *ipiv, double anorm, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:a28f5101c304b7cf551a3ad44c8330d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f312a622525a4eaea0609776481f27e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0f312a622525a4eaea0609776481f27e">C_DGBEQU</a> (int m, int n, int kl, int ku, double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)</td></tr>
<tr class="separator:a0f312a622525a4eaea0609776481f27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b509a7495f0d4bc6158441d1115372"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a82b509a7495f0d4bc6158441d1115372">C_DGBRFS</a> (char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:a82b509a7495f0d4bc6158441d1115372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a8df061a0b1a33450d0a9c19447e6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a88a8df061a0b1a33450d0a9c19447e6e">C_DGBSV</a> (int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)</td></tr>
<tr class="separator:a88a8df061a0b1a33450d0a9c19447e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63385e7d7c88932ef51cde58a8cb0974"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a63385e7d7c88932ef51cde58a8cb0974">C_DGBSVX</a> (char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:a63385e7d7c88932ef51cde58a8cb0974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ca3f546fc02acf6d7e20dc7c5aaf22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a10ca3f546fc02acf6d7e20dc7c5aaf22">C_DGBTRF</a> (int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)</td></tr>
<tr class="separator:a10ca3f546fc02acf6d7e20dc7c5aaf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f51c1820e98cd0e24aa3a96c2ab8e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a58f51c1820e98cd0e24aa3a96c2ab8e6">C_DGBTRS</a> (char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)</td></tr>
<tr class="separator:a58f51c1820e98cd0e24aa3a96c2ab8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfd16c6bbc8316035d220196e5e0c00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3dfd16c6bbc8316035d220196e5e0c00">C_DGEBAK</a> (char job, char side, int n, int ilo, int ihi, double *scale, int m, double *v, int ldv)</td></tr>
<tr class="separator:a3dfd16c6bbc8316035d220196e5e0c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f8a4e849d16f43e4826f8735208cc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab2f8a4e849d16f43e4826f8735208cc9">C_DGEBAL</a> (char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)</td></tr>
<tr class="separator:ab2f8a4e849d16f43e4826f8735208cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dc60774827c9e2241ce9f78e7c6dc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a85dc60774827c9e2241ce9f78e7c6dc1">C_DGEBRD</a> (int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup, double *work, int lwork)</td></tr>
<tr class="separator:a85dc60774827c9e2241ce9f78e7c6dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104f1e5d60b16a9556508a96b9191fd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a104f1e5d60b16a9556508a96b9191fd4">C_DGECON</a> (char norm, int n, double *a, int lda, double anorm, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:a104f1e5d60b16a9556508a96b9191fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710b863e6df45494ceff011da30c4341"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a710b863e6df45494ceff011da30c4341">C_DGEEQU</a> (int m, int n, double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)</td></tr>
<tr class="separator:a710b863e6df45494ceff011da30c4341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af386bbdadc1fe835e09e097c4b29342d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af386bbdadc1fe835e09e097c4b29342d">C_DGEES</a> (char jobvs, char sort, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *work, int lwork)</td></tr>
<tr class="separator:af386bbdadc1fe835e09e097c4b29342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12683d5082ac02ad9aaf5fec8b74b38a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a12683d5082ac02ad9aaf5fec8b74b38a">C_DGEESX</a> (char jobvs, char sort, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:a12683d5082ac02ad9aaf5fec8b74b38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8816e166e757946ffc3ffda87ce7dc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab8816e166e757946ffc3ffda87ce7dc7">C_DGEEV</a> (char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)</td></tr>
<tr class="separator:ab8816e166e757946ffc3ffda87ce7dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2e64034cadb451e6eb150f7bf3a9bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1d2e64034cadb451e6eb150f7bf3a9bc">C_DGEEVX</a> (char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork)</td></tr>
<tr class="separator:a1d2e64034cadb451e6eb150f7bf3a9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d5ceaca8b8229dff92d656a015a1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a6f8d5ceaca8b8229dff92d656a015a1e">C_DGEGS</a> (char jobvsl, char jobvsr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork)</td></tr>
<tr class="separator:a6f8d5ceaca8b8229dff92d656a015a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeeef8553a3df870d2401154745a386"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2aeeef8553a3df870d2401154745a386">C_DGEGV</a> (char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)</td></tr>
<tr class="separator:a2aeeef8553a3df870d2401154745a386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4268adae718a19acfddd3b0e634d589"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa4268adae718a19acfddd3b0e634d589">C_DGEHRD</a> (int n, int ilo, int ihi, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:aa4268adae718a19acfddd3b0e634d589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f394133d870da8f2cd6dd7b2093ab76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0f394133d870da8f2cd6dd7b2093ab76">C_DGELQF</a> (int m, int n, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:a0f394133d870da8f2cd6dd7b2093ab76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123439d31f9576acf588a2a19269a9e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a123439d31f9576acf588a2a19269a9e5">C_DGELS</a> (char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)</td></tr>
<tr class="separator:a123439d31f9576acf588a2a19269a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eadbebece8fa1afb07d8ecb35188d90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7eadbebece8fa1afb07d8ecb35188d90">C_DGELSD</a> (int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork, int *iwork)</td></tr>
<tr class="separator:a7eadbebece8fa1afb07d8ecb35188d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf94e88ad977b6051ea4c879f55f6ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aeaf94e88ad977b6051ea4c879f55f6ac">C_DGELSS</a> (int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork)</td></tr>
<tr class="separator:aeaf94e88ad977b6051ea4c879f55f6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418cc23eb0505cc6da7e6bdb1c05ef87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a418cc23eb0505cc6da7e6bdb1c05ef87">C_DGELSX</a> (int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank, double *work)</td></tr>
<tr class="separator:a418cc23eb0505cc6da7e6bdb1c05ef87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716a475ae7a4d53c272dfaf1b2b4f484"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a716a475ae7a4d53c272dfaf1b2b4f484">C_DGELSY</a> (int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank, double *work, int lwork)</td></tr>
<tr class="separator:a716a475ae7a4d53c272dfaf1b2b4f484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dc38039a8fad7ead68e36c3c6b3a59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae8dc38039a8fad7ead68e36c3c6b3a59">C_DGEQLF</a> (int m, int n, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:ae8dc38039a8fad7ead68e36c3c6b3a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177094575b64845a2e142a79b1a4fa37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a177094575b64845a2e142a79b1a4fa37">C_DGEQP3</a> (int m, int n, double *a, int lda, int *jpvt, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:a177094575b64845a2e142a79b1a4fa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7b1bf710faa0effed2123e38759485"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0c7b1bf710faa0effed2123e38759485">C_DGEQPF</a> (int m, int n, double *a, int lda, int *jpvt, double *tau, double *work)</td></tr>
<tr class="separator:a0c7b1bf710faa0effed2123e38759485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4774c9554c816b3d040bf10a31248fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae4774c9554c816b3d040bf10a31248fc">C_DGEQRF</a> (int m, int n, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:ae4774c9554c816b3d040bf10a31248fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b81cd2301924a351c6c5bd7f1ec7c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a98b81cd2301924a351c6c5bd7f1ec7c2">C_DGERFS</a> (char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:a98b81cd2301924a351c6c5bd7f1ec7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ad4b8597e2b4e81089f1bef5779bc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a00ad4b8597e2b4e81089f1bef5779bc1">C_DGERQF</a> (int m, int n, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:a00ad4b8597e2b4e81089f1bef5779bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694b74f34cfc82e3bb2bc573b3bbb9bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a694b74f34cfc82e3bb2bc573b3bbb9bf">C_DGESDD</a> (char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)</td></tr>
<tr class="separator:a694b74f34cfc82e3bb2bc573b3bbb9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f4d27a7f03785e2090e82f51df475f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga61f4d27a7f03785e2090e82f51df475f">C_DGESV</a> (int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)</td></tr>
<tr class="separator:ga61f4d27a7f03785e2090e82f51df475f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75592ae4cf9f1cc964de8086146df0fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a75592ae4cf9f1cc964de8086146df0fc">C_DGESVX</a> (char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:a75592ae4cf9f1cc964de8086146df0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a32fab1a77d1ea47a9145a8e124ea9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga5a32fab1a77d1ea47a9145a8e124ea9c">C_DGETRF</a> (int m, int n, double *a, int lda, int *ipiv)</td></tr>
<tr class="separator:ga5a32fab1a77d1ea47a9145a8e124ea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6c02fc0a629aea55fa3ea94885e2ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gacf6c02fc0a629aea55fa3ea94885e2ec">C_DGETRI</a> (int n, double *a, int lda, int *ipiv, double *work, int lwork)</td></tr>
<tr class="separator:gacf6c02fc0a629aea55fa3ea94885e2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4297da7ca4fc2c7aa1234927a5bb111"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa4297da7ca4fc2c7aa1234927a5bb111">C_DGETRS</a> (char trans, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)</td></tr>
<tr class="separator:aa4297da7ca4fc2c7aa1234927a5bb111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44dfe07a23e79c1ac034b65d50f39b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa44dfe07a23e79c1ac034b65d50f39b7">C_DGGBAK</a> (char job, char side, int n, int ilo, int ihi, double *lscale, double *rscale, int m, double *v, int ldv)</td></tr>
<tr class="separator:aa44dfe07a23e79c1ac034b65d50f39b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa436205e359ff4b15b7a7c62afbba9d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa436205e359ff4b15b7a7c62afbba9d5">C_DGGBAL</a> (char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)</td></tr>
<tr class="separator:aa436205e359ff4b15b7a7c62afbba9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7babb072640ba2fda26440d1d5d7735a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7babb072640ba2fda26440d1d5d7735a">C_DGGES</a> (char jobvsl, char jobvsr, char sort, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork)</td></tr>
<tr class="separator:a7babb072640ba2fda26440d1d5d7735a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7f1325fc6882fb79110a23ff4e8e13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5e7f1325fc6882fb79110a23ff4e8e13">C_DGGESX</a> (char jobvsl, char jobvsr, char sort, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:a5e7f1325fc6882fb79110a23ff4e8e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaeec7f98dffa1357f2fb803e586c49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#abeaeec7f98dffa1357f2fb803e586c49">C_DGGEV</a> (char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)</td></tr>
<tr class="separator:abeaeec7f98dffa1357f2fb803e586c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d405d44f7f53f87f94421236062fce8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8d405d44f7f53f87f94421236062fce8">C_DGGEVX</a> (char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork)</td></tr>
<tr class="separator:a8d405d44f7f53f87f94421236062fce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a25b99190d84886d4037fa09c86f9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a56a25b99190d84886d4037fa09c86f9c">C_DGGGLM</a> (int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y, double *work, int lwork)</td></tr>
<tr class="separator:a56a25b99190d84886d4037fa09c86f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6e4407d2b59a7915c4e536d489d709"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8f6e4407d2b59a7915c4e536d489d709">C_DGGHRD</a> (char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)</td></tr>
<tr class="separator:a8f6e4407d2b59a7915c4e536d489d709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86040bfafdb726b01f7cfe5afebef987"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a86040bfafdb726b01f7cfe5afebef987">C_DGGLSE</a> (int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x, double *work, int lwork)</td></tr>
<tr class="separator:a86040bfafdb726b01f7cfe5afebef987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180f6035e86ceb038e3ca6f06fce6edc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a180f6035e86ceb038e3ca6f06fce6edc">C_DGGQRF</a> (int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)</td></tr>
<tr class="separator:a180f6035e86ceb038e3ca6f06fce6edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e71b43f2237b766cf3ab8a5817f683e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5e71b43f2237b766cf3ab8a5817f683e">C_DGGRQF</a> (int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)</td></tr>
<tr class="separator:a5e71b43f2237b766cf3ab8a5817f683e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c47752512130b7701d02342068c247a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5c47752512130b7701d02342068c247a">C_DGGSVD</a> (char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *iwork)</td></tr>
<tr class="separator:a5c47752512130b7701d02342068c247a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ffa89e8a5538ddb36a49be7add1a15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a73ffa89e8a5538ddb36a49be7add1a15">C_DGGSVP</a> (char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work)</td></tr>
<tr class="separator:a73ffa89e8a5538ddb36a49be7add1a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735bfd6706e202a9d743312539aa8e4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a735bfd6706e202a9d743312539aa8e4e">C_DGTCON</a> (char norm, int n, double *dl, double *d, double *du, double *du2, int *ipiv, double anorm, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:a735bfd6706e202a9d743312539aa8e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c57ef02e174f2bc07c0cb591cb635a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a84c57ef02e174f2bc07c0cb591cb635a">C_DGTRFS</a> (char trans, int n, int nrhs, double *dl, double *d, double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:a84c57ef02e174f2bc07c0cb591cb635a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f3c73d2b7d53e209439172f18401b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a76f3c73d2b7d53e209439172f18401b1">C_DGTSV</a> (int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)</td></tr>
<tr class="separator:a76f3c73d2b7d53e209439172f18401b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41c192f1b7e35baef951254c68acb56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad41c192f1b7e35baef951254c68acb56">C_DGTSVX</a> (char fact, char trans, int n, int nrhs, double *dl, double *d, double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, double *b, int ldb, double *x, int ldx, double *rcond)</td></tr>
<tr class="separator:ad41c192f1b7e35baef951254c68acb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a04949ec96b0a4d026c649fcdadc84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad7a04949ec96b0a4d026c649fcdadc84">C_DGTTRF</a> (int n, double *dl, double *d, double *du, double *du2, int *ipiv)</td></tr>
<tr class="separator:ad7a04949ec96b0a4d026c649fcdadc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00a34294880feefe4cfe8bb47fceb13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad00a34294880feefe4cfe8bb47fceb13">C_DGTTRS</a> (char trans, int n, int nrhs, double *dl, double *d, double *du, double *du2, int *ipiv, double *b, int ldb)</td></tr>
<tr class="separator:ad00a34294880feefe4cfe8bb47fceb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fb743c17dc2781d93ef400eb311d15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a67fb743c17dc2781d93ef400eb311d15">C_DHGEQZ</a> (char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, double *work, int lwork)</td></tr>
<tr class="separator:a67fb743c17dc2781d93ef400eb311d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a026d1fa8b2c995079b644e1c3064a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a33a026d1fa8b2c995079b644e1c3064a">C_DHSEIN</a> (char side, char eigsrc, char initv, int n, double *h, int ldh, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work, int *ifaill, int *ifailr)</td></tr>
<tr class="separator:a33a026d1fa8b2c995079b644e1c3064a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2a864036d76935f43d7c4be662b7c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#acf2a864036d76935f43d7c4be662b7c2">C_DHSEQR</a> (char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz, double *work, int lwork)</td></tr>
<tr class="separator:acf2a864036d76935f43d7c4be662b7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6e60d755abd22f120a83a17b7deca1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3f6e60d755abd22f120a83a17b7deca1">C_DOPGTR</a> (char uplo, int n, double *ap, double *tau, double *q, int ldq, double *work)</td></tr>
<tr class="separator:a3f6e60d755abd22f120a83a17b7deca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accad2aadf66d22b75355708708af0e82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#accad2aadf66d22b75355708708af0e82">C_DOPMTR</a> (char side, char uplo, char trans, int m, int n, double *ap, double *tau, double *c, int ldc, double *work)</td></tr>
<tr class="separator:accad2aadf66d22b75355708708af0e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbe7aee87fe8c038d294b1d825bb430"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8cbe7aee87fe8c038d294b1d825bb430">C_DORGBR</a> (char vect, int m, int n, int k, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:a8cbe7aee87fe8c038d294b1d825bb430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5583bf43b296577c37dd9591f0c9914c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5583bf43b296577c37dd9591f0c9914c">C_DORGHR</a> (int n, int ilo, int ihi, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:a5583bf43b296577c37dd9591f0c9914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cf75a4ae3299a216b09eb6f4b4b737"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a26cf75a4ae3299a216b09eb6f4b4b737">C_DORGLQ</a> (int m, int n, int k, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:a26cf75a4ae3299a216b09eb6f4b4b737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5df55e56031164c7edc6bdb65113853"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa5df55e56031164c7edc6bdb65113853">C_DORGQL</a> (int m, int n, int k, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:aa5df55e56031164c7edc6bdb65113853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd2223a663dcda9dcc7816d2058f8d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3bd2223a663dcda9dcc7816d2058f8d6">C_DORGQR</a> (int m, int n, int k, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:a3bd2223a663dcda9dcc7816d2058f8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23b845911f25755ce43d73a1b077696"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac23b845911f25755ce43d73a1b077696">C_DORGRQ</a> (int m, int n, int k, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:ac23b845911f25755ce43d73a1b077696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b4cb4f1243709349d405f6b2b48453"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad4b4cb4f1243709349d405f6b2b48453">C_DORGTR</a> (char uplo, int n, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:ad4b4cb4f1243709349d405f6b2b48453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cdfdfc88e99834da9b4f7edcc7836c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a45cdfdfc88e99834da9b4f7edcc7836c">C_DORMBR</a> (char vect, char side, char trans, int m, int n, int k, double *a, int lda, double *tau, double *c, int ldc, double *work, int lwork)</td></tr>
<tr class="separator:a45cdfdfc88e99834da9b4f7edcc7836c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53d61822fda02062379e781b25a8d9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa53d61822fda02062379e781b25a8d9b">C_DORMHR</a> (char side, char trans, int m, int n, int ilo, int ihi, double *a, int lda, double *tau, double *c, int ldc, double *work, int lwork)</td></tr>
<tr class="separator:aa53d61822fda02062379e781b25a8d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad0337d93f2db21ef79672f50e1a96b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a6ad0337d93f2db21ef79672f50e1a96b">C_DORMLQ</a> (char side, char trans, int m, int n, int k, double *a, int lda, double *tau, double *c, int ldc, double *work, int lwork)</td></tr>
<tr class="separator:a6ad0337d93f2db21ef79672f50e1a96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32e51ae6609550f6cf95eece4b99228"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab32e51ae6609550f6cf95eece4b99228">C_DORMQL</a> (char side, char trans, int m, int n, int k, double *a, int lda, double *tau, double *c, int ldc, double *work, int lwork)</td></tr>
<tr class="separator:ab32e51ae6609550f6cf95eece4b99228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e7926eb5e51eaae7d8f71e03e4745e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab0e7926eb5e51eaae7d8f71e03e4745e">C_DORMQR</a> (char side, char trans, int m, int n, int k, double *a, int lda, double *tau, double *c, int ldc, double *work, int lwork)</td></tr>
<tr class="separator:ab0e7926eb5e51eaae7d8f71e03e4745e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d3d206966481e688f72436691c129a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a24d3d206966481e688f72436691c129a">C_DORMR3</a> (char side, char trans, int m, int n, int k, int l, double *a, int lda, double *tau, double *c, int ldc, double *work)</td></tr>
<tr class="separator:a24d3d206966481e688f72436691c129a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3652160e0a4dfadeb7671065e18bdd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac3652160e0a4dfadeb7671065e18bdd7">C_DORMRQ</a> (char side, char trans, int m, int n, int k, double *a, int lda, double *tau, double *c, int ldc, double *work, int lwork)</td></tr>
<tr class="separator:ac3652160e0a4dfadeb7671065e18bdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66158a3bbe19d7864ddd9688cdfde9d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a66158a3bbe19d7864ddd9688cdfde9d2">C_DORMRZ</a> (char side, char trans, int m, int n, int k, int l, double *a, int lda, double *tau, double *c, int ldc, double *work, int lwork)</td></tr>
<tr class="separator:a66158a3bbe19d7864ddd9688cdfde9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2246cbbd73e6ccab2a431eb824e03a0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2246cbbd73e6ccab2a431eb824e03a0b">C_DORMTR</a> (char side, char uplo, char trans, int m, int n, double *a, int lda, double *tau, double *c, int ldc, double *work, int lwork)</td></tr>
<tr class="separator:a2246cbbd73e6ccab2a431eb824e03a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3140c5434e011b0250ab605254e411fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3140c5434e011b0250ab605254e411fa">C_DPBCON</a> (char uplo, int n, int kd, double *ab, int ldab, double anorm, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:a3140c5434e011b0250ab605254e411fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005c6545bfe68019a7eb490a721edc87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a005c6545bfe68019a7eb490a721edc87">C_DPBEQU</a> (char uplo, int n, int kd, double *ab, int ldab, double *s, double *scond, double *amax)</td></tr>
<tr class="separator:a005c6545bfe68019a7eb490a721edc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fb9381f8029a310e4286c64fe13801"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a59fb9381f8029a310e4286c64fe13801">C_DPBRFS</a> (char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:a59fb9381f8029a310e4286c64fe13801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997e83088744ddb8941ed686c5455bfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a997e83088744ddb8941ed686c5455bfa">C_DPBSTF</a> (char uplo, int n, int kd, double *ab, int ldab)</td></tr>
<tr class="separator:a997e83088744ddb8941ed686c5455bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf538a4c8f96441272a9d72986222d35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#acf538a4c8f96441272a9d72986222d35">C_DPBSV</a> (char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)</td></tr>
<tr class="separator:acf538a4c8f96441272a9d72986222d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35a456d1d4286c6527d82295172515a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa35a456d1d4286c6527d82295172515a">C_DPBSVX</a> (char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:aa35a456d1d4286c6527d82295172515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4e603468da3b258aa4aeef583062eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#afe4e603468da3b258aa4aeef583062eb">C_DPBTRF</a> (char uplo, int n, int kd, double *ab, int ldab)</td></tr>
<tr class="separator:afe4e603468da3b258aa4aeef583062eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e52e17ca03fc8a2f3bd0f22690e6d44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7e52e17ca03fc8a2f3bd0f22690e6d44">C_DPBTRS</a> (char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)</td></tr>
<tr class="separator:a7e52e17ca03fc8a2f3bd0f22690e6d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94115d396126beb0323fe47d71a1b12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa94115d396126beb0323fe47d71a1b12">C_DPOCON</a> (char uplo, int n, double *a, int lda, double anorm, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:aa94115d396126beb0323fe47d71a1b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3bc0fe1281e840ef397a6b3aaef296"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8f3bc0fe1281e840ef397a6b3aaef296">C_DPOEQU</a> (int n, double *a, int lda, double *s, double *scond, double *amax)</td></tr>
<tr class="separator:a8f3bc0fe1281e840ef397a6b3aaef296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd6a5b6e2484454ac7d558a2593e820"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#acfd6a5b6e2484454ac7d558a2593e820">C_DPORFS</a> (char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:acfd6a5b6e2484454ac7d558a2593e820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b9c97630f4e0804dde850a64bc07d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a844b9c97630f4e0804dde850a64bc07d">C_DPOSV</a> (char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)</td></tr>
<tr class="separator:a844b9c97630f4e0804dde850a64bc07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60ae04b0340d0fcdff4a1bd9b74774b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab60ae04b0340d0fcdff4a1bd9b74774b">C_DPOSVX</a> (char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:ab60ae04b0340d0fcdff4a1bd9b74774b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53680dc5cf2b74b21d23aed254e09eec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga53680dc5cf2b74b21d23aed254e09eec">C_DPOTRF</a> (char uplo, int n, double *a, int lda)</td></tr>
<tr class="separator:ga53680dc5cf2b74b21d23aed254e09eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369ad7d6d71f540b359347b1b70b4e21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga369ad7d6d71f540b359347b1b70b4e21">C_DPOTRI</a> (char uplo, int n, double *a, int lda)</td></tr>
<tr class="separator:ga369ad7d6d71f540b359347b1b70b4e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9140c52de648ece9bdf664b8770365ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga9140c52de648ece9bdf664b8770365ef">C_DPOTRS</a> (char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)</td></tr>
<tr class="separator:ga9140c52de648ece9bdf664b8770365ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660e6adeae6b80ff8f9c707f4fe7fe33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a660e6adeae6b80ff8f9c707f4fe7fe33">C_DPPCON</a> (char uplo, int n, double *ap, double anorm, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:a660e6adeae6b80ff8f9c707f4fe7fe33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae671a89eb1d7b3c56ba38a20c2c3b6bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae671a89eb1d7b3c56ba38a20c2c3b6bc">C_DPPEQU</a> (char uplo, int n, double *ap, double *s, double *scond, double *amax)</td></tr>
<tr class="separator:ae671a89eb1d7b3c56ba38a20c2c3b6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80d660766514be955218f1b4cd07fa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae80d660766514be955218f1b4cd07fa0">C_DPPRFS</a> (char uplo, int n, int nrhs, double *ap, double *afp, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:ae80d660766514be955218f1b4cd07fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85251589adc7788dc939b2031f2f3850"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a85251589adc7788dc939b2031f2f3850">C_DPPSV</a> (char uplo, int n, int nrhs, double *ap, double *b, int ldb)</td></tr>
<tr class="separator:a85251589adc7788dc939b2031f2f3850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab346569aaa90a9319753e5f5ac5e5c13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab346569aaa90a9319753e5f5ac5e5c13">C_DPPSVX</a> (char fact, char uplo, int n, int nrhs, double *ap, double *afp, char equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:ab346569aaa90a9319753e5f5ac5e5c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ee4eb52472b2fb5d6245bde81aacd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a13ee4eb52472b2fb5d6245bde81aacd5">C_DPPTRF</a> (char uplo, int n, double *ap)</td></tr>
<tr class="separator:a13ee4eb52472b2fb5d6245bde81aacd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852877f1114766bcd0651c7d2358a7ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a852877f1114766bcd0651c7d2358a7ec">C_DPPTRI</a> (char uplo, int n, double *ap)</td></tr>
<tr class="separator:a852877f1114766bcd0651c7d2358a7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488ec73fb354c46086658a5a81db0ad9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a488ec73fb354c46086658a5a81db0ad9">C_DPPTRS</a> (char uplo, int n, int nrhs, double *ap, double *b, int ldb)</td></tr>
<tr class="separator:a488ec73fb354c46086658a5a81db0ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55abe8cd8a5a69abf978dbf72829e4e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a55abe8cd8a5a69abf978dbf72829e4e0">C_DPTCON</a> (int n, double *d, double *e, double anorm, double *rcond, double *work)</td></tr>
<tr class="separator:a55abe8cd8a5a69abf978dbf72829e4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1b70e86ee6317042ac73c6afad4c2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2b1b70e86ee6317042ac73c6afad4c2d">C_DPTEQR</a> (char compz, int n, double *d, double *e, double *z, int ldz, double *work)</td></tr>
<tr class="separator:a2b1b70e86ee6317042ac73c6afad4c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc9f6c41708d22ebb9a9613608d5f6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8cc9f6c41708d22ebb9a9613608d5f6b">C_DPTRFS</a> (int n, int nrhs, double *d, double *e, double *df, double *ef, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work)</td></tr>
<tr class="separator:a8cc9f6c41708d22ebb9a9613608d5f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f7f9c2328fd0604879a4f46a995716"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a57f7f9c2328fd0604879a4f46a995716">C_DPTSV</a> (int n, int nrhs, double *d, double *e, double *b, int ldb)</td></tr>
<tr class="separator:a57f7f9c2328fd0604879a4f46a995716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0e36e3511b6aa9272132465988ceed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aaf0e36e3511b6aa9272132465988ceed">C_DPTSVX</a> (char fact, int n, int nrhs, double *d, double *e, double *df, double *ef, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work)</td></tr>
<tr class="separator:aaf0e36e3511b6aa9272132465988ceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721c8451a91e178b2e5a96205338fe25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a721c8451a91e178b2e5a96205338fe25">C_DPTTRF</a> (int n, double *d, double *e)</td></tr>
<tr class="separator:a721c8451a91e178b2e5a96205338fe25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fc446a6cfd00aaf9691d5625922f4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a68fc446a6cfd00aaf9691d5625922f4d">C_DPTTRS</a> (int n, int nrhs, double *d, double *e, double *b, int ldb)</td></tr>
<tr class="separator:a68fc446a6cfd00aaf9691d5625922f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060b8bee208f53b00d094d33b3e5d113"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a060b8bee208f53b00d094d33b3e5d113">C_DSBEV</a> (char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work)</td></tr>
<tr class="separator:a060b8bee208f53b00d094d33b3e5d113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23fe05be014c8f6b875dcaccab54594"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac23fe05be014c8f6b875dcaccab54594">C_DSBEVD</a> (char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:ac23fe05be014c8f6b875dcaccab54594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64b1e06707e6a9ed9cb5e7fbc549fa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac64b1e06707e6a9ed9cb5e7fbc549fa0">C_DSBEVX</a> (char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)</td></tr>
<tr class="separator:ac64b1e06707e6a9ed9cb5e7fbc549fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5950a185909fd0893a782e7e16d671"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#adb5950a185909fd0893a782e7e16d671">C_DSBGST</a> (char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *x, int ldx, double *work)</td></tr>
<tr class="separator:adb5950a185909fd0893a782e7e16d671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3eb22d1cae3c55df3a6c840bb21d672"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa3eb22d1cae3c55df3a6c840bb21d672">C_DSBGV</a> (char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work)</td></tr>
<tr class="separator:aa3eb22d1cae3c55df3a6c840bb21d672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca486852733a72044e767f25ce1571e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aaca486852733a72044e767f25ce1571e">C_DSBGVD</a> (char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:aaca486852733a72044e767f25ce1571e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45536e6e57bc1e077d5ff7518ac46e7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a45536e6e57bc1e077d5ff7518ac46e7f">C_DSBGVX</a> (char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)</td></tr>
<tr class="separator:a45536e6e57bc1e077d5ff7518ac46e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9471f67f2d911f87d0f884dc5bc6a5fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9471f67f2d911f87d0f884dc5bc6a5fa">C_DSBTRD</a> (char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *work)</td></tr>
<tr class="separator:a9471f67f2d911f87d0f884dc5bc6a5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3344df9539b9b6eed9c3969818eb7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aef3344df9539b9b6eed9c3969818eb7f">C_DSGESV</a> (int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, double *work, int *iter)</td></tr>
<tr class="separator:aef3344df9539b9b6eed9c3969818eb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079f302685332edb74db4e2b399bdd43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a079f302685332edb74db4e2b399bdd43">C_DSPCON</a> (char uplo, int n, double *ap, int *ipiv, double anorm, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:a079f302685332edb74db4e2b399bdd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979eb3cbb7c080a18ee092680c1e0982"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a979eb3cbb7c080a18ee092680c1e0982">C_DSPEV</a> (char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work)</td></tr>
<tr class="separator:a979eb3cbb7c080a18ee092680c1e0982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e6125652b2dd217328e1851cc65bed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a17e6125652b2dd217328e1851cc65bed">C_DSPEVD</a> (char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:a17e6125652b2dd217328e1851cc65bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e080eaebf68024c7753e52b94b804b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad8e080eaebf68024c7753e52b94b804b">C_DSPEVX</a> (char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)</td></tr>
<tr class="separator:ad8e080eaebf68024c7753e52b94b804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0531dcae3e59b9ec2acbb5aee2e916e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad0531dcae3e59b9ec2acbb5aee2e916e">C_DSPGST</a> (int itype, char uplo, int n, double *ap, double *bp)</td></tr>
<tr class="separator:ad0531dcae3e59b9ec2acbb5aee2e916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9cc01d070543fa81c5ab0a0ad65116"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3a9cc01d070543fa81c5ab0a0ad65116">C_DSPGV</a> (int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work)</td></tr>
<tr class="separator:a3a9cc01d070543fa81c5ab0a0ad65116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb3db557e88b7ff4e174d4ff581af44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a1fb3db557e88b7ff4e174d4ff581af44">C_DSPGVD</a> (int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:a1fb3db557e88b7ff4e174d4ff581af44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92ec5119f779bf6beab320323c5d8b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae92ec5119f779bf6beab320323c5d8b7">C_DSPGVX</a> (int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)</td></tr>
<tr class="separator:ae92ec5119f779bf6beab320323c5d8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23efc11886c1bd29767bc02d06e9f925"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a23efc11886c1bd29767bc02d06e9f925">C_DSPRFS</a> (char uplo, int n, int nrhs, double *ap, double *afp, int *ipiv, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:a23efc11886c1bd29767bc02d06e9f925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1052626c015581134620245f7b9dde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#afd1052626c015581134620245f7b9dde">C_DSPSV</a> (char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)</td></tr>
<tr class="separator:afd1052626c015581134620245f7b9dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c9dd2a9d0c7938487e3004543e49ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a43c9dd2a9d0c7938487e3004543e49ed">C_DSPSVX</a> (char fact, char uplo, int n, int nrhs, double *ap, double *afp, int *ipiv, double *b, int ldb, double *x, int ldx, double *rcond)</td></tr>
<tr class="separator:a43c9dd2a9d0c7938487e3004543e49ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774be5cf4c97977ee0fbf6d1c9ee6867"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a774be5cf4c97977ee0fbf6d1c9ee6867">C_DSPTRD</a> (char uplo, int n, double *ap, double *d, double *e, double *tau)</td></tr>
<tr class="separator:a774be5cf4c97977ee0fbf6d1c9ee6867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6937933d11e3fd69ef24a18cd506763f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a6937933d11e3fd69ef24a18cd506763f">C_DSPTRF</a> (char uplo, int n, double *ap, int *ipiv)</td></tr>
<tr class="separator:a6937933d11e3fd69ef24a18cd506763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b29cf443eeaaed9505c4de7b2864613"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8b29cf443eeaaed9505c4de7b2864613">C_DSPTRI</a> (char uplo, int n, double *ap, int *ipiv, double *work)</td></tr>
<tr class="separator:a8b29cf443eeaaed9505c4de7b2864613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3779f0894c0dfb14147efa365c7878fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3779f0894c0dfb14147efa365c7878fa">C_DSPTRS</a> (char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)</td></tr>
<tr class="separator:a3779f0894c0dfb14147efa365c7878fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccdb2cc0bdadd686c605da111dd32f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9ccdb2cc0bdadd686c605da111dd32f7">C_DSTEBZ</a> (char range, char order, int n, double vl, double vu, int il, int iu, double abstol, double *d, double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork)</td></tr>
<tr class="separator:a9ccdb2cc0bdadd686c605da111dd32f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fcb3a924dac52b996f73bbb389fc19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a12fcb3a924dac52b996f73bbb389fc19">C_DSTEDC</a> (char compz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:a12fcb3a924dac52b996f73bbb389fc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c2f4488a32b7a0d137300a5f052b32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad6c2f4488a32b7a0d137300a5f052b32">C_DSTEGR</a> (char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:ad6c2f4488a32b7a0d137300a5f052b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade618e86ec14c482f06a940503d5f4db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ade618e86ec14c482f06a940503d5f4db">C_DSTEIN</a> (int n, double *d, double *e, int m, double *w, int *iblock, int *isplit, double *z, int ldz, double *work, int *iwork, int *ifail)</td></tr>
<tr class="separator:ade618e86ec14c482f06a940503d5f4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849a6e07d46f18b6f3f77bf1ee1cd2b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a849a6e07d46f18b6f3f77bf1ee1cd2b0">C_DSTEQR</a> (char compz, int n, double *d, double *e, double *z, int ldz, double *work)</td></tr>
<tr class="separator:a849a6e07d46f18b6f3f77bf1ee1cd2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3208e0c14fb60d2616eee866b52d2345"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a3208e0c14fb60d2616eee866b52d2345">C_DSTERF</a> (int n, double *d, double *e)</td></tr>
<tr class="separator:a3208e0c14fb60d2616eee866b52d2345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ee20a7469bddcbbdb23004fd00eec2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a09ee20a7469bddcbbdb23004fd00eec2">C_DSTEV</a> (char jobz, int n, double *d, double *e, double *z, int ldz, double *work)</td></tr>
<tr class="separator:a09ee20a7469bddcbbdb23004fd00eec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0053713408e9efb4c356ad2385b957d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0053713408e9efb4c356ad2385b957d9">C_DSTEVD</a> (char jobz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:a0053713408e9efb4c356ad2385b957d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662f3a711c2da8007259f3bb307880f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a662f3a711c2da8007259f3bb307880f5">C_DSTEVR</a> (char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:a662f3a711c2da8007259f3bb307880f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6fcd02cab491aac4ca96996b9eda50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8b6fcd02cab491aac4ca96996b9eda50">C_DSTEVX</a> (char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)</td></tr>
<tr class="separator:a8b6fcd02cab491aac4ca96996b9eda50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389a81cbc866e8dee641f73d681da8c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a389a81cbc866e8dee641f73d681da8c2">C_DSYCON</a> (char uplo, int n, double *a, int lda, int *ipiv, double anorm, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:a389a81cbc866e8dee641f73d681da8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f1317f08bd64d633f20935ba5d8547"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaf4f1317f08bd64d633f20935ba5d8547">C_DSYEV</a> (char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)</td></tr>
<tr class="separator:gaf4f1317f08bd64d633f20935ba5d8547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2fc4438a32f99205642062ddafe9d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a0f2fc4438a32f99205642062ddafe9d0">C_DSYEVD</a> (char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:a0f2fc4438a32f99205642062ddafe9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4621af093a70f5fb7b86c2a11012c721"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a4621af093a70f5fb7b86c2a11012c721">C_DSYEVR</a> (char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:a4621af093a70f5fb7b86c2a11012c721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ac2a767e860128c10ac1e11a0ef6c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa2ac2a767e860128c10ac1e11a0ef6c9">C_DSYEVX</a> (char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)</td></tr>
<tr class="separator:aa2ac2a767e860128c10ac1e11a0ef6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9863ad1a7ebcd3b94c5bf287f70df75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac9863ad1a7ebcd3b94c5bf287f70df75">C_DSYGST</a> (int itype, char uplo, int n, double *a, int lda, double *b, int ldb)</td></tr>
<tr class="separator:ac9863ad1a7ebcd3b94c5bf287f70df75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af232942c441a9b4cfcba6b00bafbe718"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af232942c441a9b4cfcba6b00bafbe718">C_DSYGV</a> (int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)</td></tr>
<tr class="separator:af232942c441a9b4cfcba6b00bafbe718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac469286f3ac08952591a8d29349f9d1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac469286f3ac08952591a8d29349f9d1b">C_DSYGVD</a> (int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:ac469286f3ac08952591a8d29349f9d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ea3c58ae33fe5b6813a080c5f52f7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab4ea3c58ae33fe5b6813a080c5f52f7b">C_DSYGVX</a> (int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)</td></tr>
<tr class="separator:ab4ea3c58ae33fe5b6813a080c5f52f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711b203e28514a83b002697670287db8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a711b203e28514a83b002697670287db8">C_DSYRFS</a> (char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:a711b203e28514a83b002697670287db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251178e9ccd92bb186e845f7d0378a14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a251178e9ccd92bb186e845f7d0378a14">C_DSYSV</a> (char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)</td></tr>
<tr class="separator:a251178e9ccd92bb186e845f7d0378a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27161d1f90c9fac873dbec55fbc3d79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab27161d1f90c9fac873dbec55fbc3d79">C_DSYSVX</a> (char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, double *b, int ldb, double *x, int ldx, double *rcond)</td></tr>
<tr class="separator:ab27161d1f90c9fac873dbec55fbc3d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ec09e6ab99d78995daf7d11e418b64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a94ec09e6ab99d78995daf7d11e418b64">C_DSYTRD</a> (char uplo, int n, double *a, int lda, double *d, double *e, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:a94ec09e6ab99d78995daf7d11e418b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae382cb8b4eab672cc21afc743c293e9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae382cb8b4eab672cc21afc743c293e9c">C_DSYTRF</a> (char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)</td></tr>
<tr class="separator:ae382cb8b4eab672cc21afc743c293e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686c5afc306530113b3e5108f198bce9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a686c5afc306530113b3e5108f198bce9">C_DSYTRI</a> (char uplo, int n, double *a, int lda, int *ipiv, double *work)</td></tr>
<tr class="separator:a686c5afc306530113b3e5108f198bce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ecdaf384b08b4da7a46e175ec2c051"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa9ecdaf384b08b4da7a46e175ec2c051">C_DSYTRS</a> (char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)</td></tr>
<tr class="separator:aa9ecdaf384b08b4da7a46e175ec2c051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fcb194ae0e30df62cbd1d6ea8dc2f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a84fcb194ae0e30df62cbd1d6ea8dc2f4">C_DTBCON</a> (char norm, char uplo, char diag, int n, int kd, double *ab, int ldab, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:a84fcb194ae0e30df62cbd1d6ea8dc2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8934b7e2d896e58abea1467c70ddacb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac8934b7e2d896e58abea1467c70ddacb">C_DTBRFS</a> (char uplo, char trans, char diag, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:ac8934b7e2d896e58abea1467c70ddacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04d529bdd5bec94ea3b217ce8d74377"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab04d529bdd5bec94ea3b217ce8d74377">C_DTBTRS</a> (char uplo, char trans, char diag, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)</td></tr>
<tr class="separator:ab04d529bdd5bec94ea3b217ce8d74377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e968e64f80edc37c74ec9bd5e83dbfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2e968e64f80edc37c74ec9bd5e83dbfa">C_DTGEVC</a> (char side, char howmny, int n, double *s, int lds, double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)</td></tr>
<tr class="separator:a2e968e64f80edc37c74ec9bd5e83dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ea0cd9464014247bbdfd4eab7361a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a78ea0cd9464014247bbdfd4eab7361a5">C_DTGEXC</a> (int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst, double *work, int lwork)</td></tr>
<tr class="separator:a78ea0cd9464014247bbdfd4eab7361a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547b8b07e9484fd80a073cdf0e5eb4b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a547b8b07e9484fd80a073cdf0e5eb4b9">C_DTGSEN</a> (int ijob, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:a547b8b07e9484fd80a073cdf0e5eb4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7d7c0f7de40de4084bcb693322e582"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#adb7d7c0f7de40de4084bcb693322e582">C_DTGSJA</a> (char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *ncycle)</td></tr>
<tr class="separator:adb7d7c0f7de40de4084bcb693322e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aacde015922e60e4c9dc0a3c513a02c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a2aacde015922e60e4c9dc0a3c513a02c">C_DTGSNA</a> (char job, char howmny, int n, double *a, int lda, double *b, int ldb, double *vl, int ldvl, double *vr, int ldvr, double *s, double *dif, int mm, int *m, double *work, int lwork, int *iwork)</td></tr>
<tr class="separator:a2aacde015922e60e4c9dc0a3c513a02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34329b47cf967d5a2e199527098ad965"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a34329b47cf967d5a2e199527098ad965">C_DTGSYL</a> (char trans, int ijob, int m, int n, double *a, int lda, double *b, int ldb, double *c, int ldc, double *d, int ldd, double *e, int lde, double *f, int ldf, double *dif, double *scale, double *work, int lwork, int *iwork)</td></tr>
<tr class="separator:a34329b47cf967d5a2e199527098ad965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60011294324d6ff0548f89cc31eb8618"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a60011294324d6ff0548f89cc31eb8618">C_DTPCON</a> (char norm, char uplo, char diag, int n, double *ap, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:a60011294324d6ff0548f89cc31eb8618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bc863b8ea536f7e92227f30bed11e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae1bc863b8ea536f7e92227f30bed11e8">C_DTPRFS</a> (char uplo, char trans, char diag, int n, int nrhs, double *ap, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:ae1bc863b8ea536f7e92227f30bed11e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7cd4d684f88bbd6f502102bdef366a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8f7cd4d684f88bbd6f502102bdef366a">C_DTPTRI</a> (char uplo, char diag, int n, double *ap)</td></tr>
<tr class="separator:a8f7cd4d684f88bbd6f502102bdef366a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad668ca911939ffd5dca320a977aadbf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ad668ca911939ffd5dca320a977aadbf7">C_DTPTRS</a> (char uplo, char trans, char diag, int n, int nrhs, double *ap, double *b, int ldb)</td></tr>
<tr class="separator:ad668ca911939ffd5dca320a977aadbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2cdead61919a224c281f5ef09a859e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aac2cdead61919a224c281f5ef09a859e">C_DTRCON</a> (char norm, char uplo, char diag, int n, double *a, int lda, double *rcond, double *work, int *iwork)</td></tr>
<tr class="separator:aac2cdead61919a224c281f5ef09a859e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8206214f832343fea2981c4664423bc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8206214f832343fea2981c4664423bc7">C_DTREVC</a> (char side, char howmny, int n, double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)</td></tr>
<tr class="separator:a8206214f832343fea2981c4664423bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7721141f3a8c20f09dcd068c84bd96c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7721141f3a8c20f09dcd068c84bd96c1">C_DTREXC</a> (char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst, double *work)</td></tr>
<tr class="separator:a7721141f3a8c20f09dcd068c84bd96c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41dba57c69e75118353923fa54063b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ab41dba57c69e75118353923fa54063b9">C_DTRRFS</a> (char uplo, char trans, char diag, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)</td></tr>
<tr class="separator:ab41dba57c69e75118353923fa54063b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf52b26732c3b34af0bdd6359c0645da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#abf52b26732c3b34af0bdd6359c0645da">C_DTRSEN</a> (char job, char compq, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int lwork, int *iwork, int liwork)</td></tr>
<tr class="separator:abf52b26732c3b34af0bdd6359c0645da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea4b53f1ad543a69e5a61289ef8418e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aaea4b53f1ad543a69e5a61289ef8418e">C_DTRSNA</a> (char job, char howmny, int n, double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, double *s, double *sep, int mm, int *m, double *work, int ldwork, int *iwork)</td></tr>
<tr class="separator:aaea4b53f1ad543a69e5a61289ef8418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d6da95b336f6c9d2ddc31d2e2ec84b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ae1d6da95b336f6c9d2ddc31d2e2ec84b">C_DTRSYL</a> (char trana, char tranb, int isgn, int m, int n, double *a, int lda, double *b, int ldb, double *c, int ldc, double *scale)</td></tr>
<tr class="separator:ae1d6da95b336f6c9d2ddc31d2e2ec84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b67156c545443cecd4cb5dd39624d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a14b67156c545443cecd4cb5dd39624d4">C_DTRTRI</a> (char uplo, char diag, int n, double *a, int lda)</td></tr>
<tr class="separator:a14b67156c545443cecd4cb5dd39624d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d8f23a9ecda29501fe484f920bd56d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a72d8f23a9ecda29501fe484f920bd56d">C_DTRTRS</a> (char uplo, char trans, char diag, int n, int nrhs, double *a, int lda, double *b, int ldb)</td></tr>
<tr class="separator:a72d8f23a9ecda29501fe484f920bd56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852a98b9e94d27a132dbfa1f5275504f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a852a98b9e94d27a132dbfa1f5275504f">C_DTZRQF</a> (int m, int n, double *a, int lda, double *tau)</td></tr>
<tr class="separator:a852a98b9e94d27a132dbfa1f5275504f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36df44bdb427860560878e9640ed075f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a36df44bdb427860560878e9640ed075f">C_DTZRZF</a> (int m, int n, double *a, int lda, double *tau, double *work, int lwork)</td></tr>
<tr class="separator:a36df44bdb427860560878e9640ed075f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff155bee61b99ac5017e11b8ffd407b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaff155bee61b99ac5017e11b8ffd407b7">C_DGEEV</a> (int n, double **a, int lda, double *wr, double *wi, double **vl, int ldvl, double **vr, int ldvr, double *work, int lwork, int info)</td></tr>
<tr class="separator:gaff155bee61b99ac5017e11b8ffd407b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8cf22efdf98af11db327b33bde7f849"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaa8cf22efdf98af11db327b33bde7f849">C_DGESVD</a> (char jobu, char jobvt, int m, int n, double *A, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork)</td></tr>
<tr class="separator:gaa8cf22efdf98af11db327b33bde7f849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc97b741ca6812939c071abd119cd070"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gacc97b741ca6812939c071abd119cd070">mat_in</a> (FILE *fp, double **array, int width, int max_length, int *stat)</td></tr>
<tr class="separator:gacc97b741ca6812939c071abd119cd070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8e72c38144a8e2abfc051b870492d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga9e8e72c38144a8e2abfc051b870492d1">mat_print</a> (double **matrix, int rows, int cols, FILE *outfile)</td></tr>
<tr class="separator:ga9e8e72c38144a8e2abfc051b870492d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5832eff676d52455aba300521a5416d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5832eff676d52455aba300521a5416d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>newmm_rking</b> (double **A, int transa, double **B, int transb, double **C, int num_rows, int num_links, int num_cols, double alpha, double beta)</td></tr>
<tr class="separator:ab5832eff676d52455aba300521a5416d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5778ea82c6c597a45373797ea698dc1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga5778ea82c6c597a45373797ea698dc1c">normalize</a> (double **A, int rows, int cols)</td></tr>
<tr class="separator:ga5778ea82c6c597a45373797ea698dc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b544274426bf74c40fc23581aac77a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92b544274426bf74c40fc23581aac77a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>orient_fragment</b> (int natom_A, int natom_B, int P_A, int P_B, double **geom_A, double **geom_B, double **ref_coeff_A, double **ref_coeff_B, double R_AB, double theta_A, double theta_B, double tau, double phi_A, double phi_B, FILE *outfile)</td></tr>
<tr class="separator:a92b544274426bf74c40fc23581aac77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc5435261bcef5693d54a4913e0864f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga7dc5435261bcef5693d54a4913e0864f">pople</a> (double **A, double *x, int dimen, int, double tolerance, FILE *outfile, int print_lvl)</td></tr>
<tr class="separator:ga7dc5435261bcef5693d54a4913e0864f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6c5e50bb519f541ce97a049a11f36c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gabc6c5e50bb519f541ce97a049a11f36c">combinations</a> (int n, int k)</td></tr>
<tr class="separator:gabc6c5e50bb519f541ce97a049a11f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad2ce5f70c7e5d9743c22ce05d647b4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga9ad2ce5f70c7e5d9743c22ce05d647b4">factorial</a> (int n)</td></tr>
<tr class="separator:ga9ad2ce5f70c7e5d9743c22ce05d647b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43680fa9286ea2dedee13fc24abd81f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga43680fa9286ea2dedee13fc24abd81f3">schmidt</a> (double **A, int rows, int cols, FILE *outfile)</td></tr>
<tr class="separator:ga43680fa9286ea2dedee13fc24abd81f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58cc29b51212aa4d022ee0fbe39a3f90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga58cc29b51212aa4d022ee0fbe39a3f90">schmidt_add</a> (double **A, int rows, int cols, double *v)</td></tr>
<tr class="separator:ga58cc29b51212aa4d022ee0fbe39a3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96d6244853b8d555cb6102d9cf3e3eb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga96d6244853b8d555cb6102d9cf3e3eb5">solve_2x2_pep</a> (double **H, double S, double *evals, double **evecs)</td></tr>
<tr class="separator:ga96d6244853b8d555cb6102d9cf3e3eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f8e6d4ea44ce054f9729f2ceda3107e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga0f8e6d4ea44ce054f9729f2ceda3107e">reorder_qt</a> (int *docc_in, int *socc_in, int *frozen_docc_in, int *frozen_uocc_in, int *order, int *orbs_per_irrep, int nirreps)</td></tr>
<tr class="separator:ga0f8e6d4ea44ce054f9729f2ceda3107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87b453ce47998937967e1b4d0336fc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad87b453ce47998937967e1b4d0336fc9">reorder_qt_uhf</a> (int *docc, int *socc, int *frozen_docc, int *frozen_uocc, int *order_alpha, int *order_beta, int *orbspi, int nirreps)</td></tr>
<tr class="separator:gad87b453ce47998937967e1b4d0336fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41a1ea3adc5fe12ffb699e37b3e1380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa41a1ea3adc5fe12ffb699e37b3e1380"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reorder_ras</b> (int *docc_in, int *socc_in, int *frozen_docc_in, int *frozen_uocc_in, int *order, int *orbs_per_irrep, int *ras1, int *ras2, int *ras3, int *ras4, int do_ras4, int nirreps)</td></tr>
<tr class="separator:aa41a1ea3adc5fe12ffb699e37b3e1380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c167969990fc460b4f776081eda1511"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c167969990fc460b4f776081eda1511"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reorder_ras2</b> (int *docc_in, int *socc_in, int *frozen_docc_in, int *frozen_uocc_in, int *order, int *orbs_per_irrep, int *ras1, int *ras2, int *ras3, int *ras4, int parsed_ras1, int parsed_ras2, int do_ras4, int nirreps)</td></tr>
<tr class="separator:a2c167969990fc460b4f776081eda1511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd746c0469f6028198246aa188960c51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gabd746c0469f6028198246aa188960c51">ras_set</a> (int nirreps, int nbfso, int freeze_core, int *orbspi, int *docc, int *socc, int *frdocc, int *fruocc, int **ras_opi, int *order, int ras_type)</td></tr>
<tr class="separator:gabd746c0469f6028198246aa188960c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0920198d52591837122f0c9f5e37b9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gac0920198d52591837122f0c9f5e37b9e">ras_set2</a> (int nirreps, int nbfso, int delete_fzdocc, int delete_restrdocc, int *orbspi, int *docc, int *socc, int *frdocc, int *fruocc, int *restrdocc, int *restruocc, int **ras_opi, int *order, int ras_type, int hoffmann, <a class="el" href="classpsi_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:gac0920198d52591837122f0c9f5e37b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177c6a6db04325eae4c5d5c6fb9bec02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga177c6a6db04325eae4c5d5c6fb9bec02">timer_init</a> (void)</td></tr>
<tr class="separator:ga177c6a6db04325eae4c5d5c6fb9bec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c3713e536790b780749da4f5279e436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga3c3713e536790b780749da4f5279e436">timer_done</a> (void)</td></tr>
<tr class="separator:ga3c3713e536790b780749da4f5279e436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e23a17ad31a5648f238a8ddce4d41a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga76e23a17ad31a5648f238a8ddce4d41a">timer_on</a> (const char *key)</td></tr>
<tr class="separator:ga76e23a17ad31a5648f238a8ddce4d41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1479e3f831fb539222f1ba2c5fa0452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gae1479e3f831fb539222f1ba2c5fa0452">timer_off</a> (const char *key)</td></tr>
<tr class="separator:gae1479e3f831fb539222f1ba2c5fa0452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af557967595dd0367ec3c363294a610b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af557967595dd0367ec3c363294a610b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_block</b> (double *, int, int, FILE *)</td></tr>
<tr class="separator:af557967595dd0367ec3c363294a610b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12b7df6cb528f490fb9fc155ecc1d1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae12b7df6cb528f490fb9fc155ecc1d1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort</b> (double *A, double **B, int n)</td></tr>
<tr class="separator:ae12b7df6cb528f490fb9fc155ecc1d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82d2ef8f162aa6bdf8fe1a1d64ede27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad82d2ef8f162aa6bdf8fe1a1d64ede27">sort_vector</a> (double *A, int n)</td></tr>
<tr class="separator:gad82d2ef8f162aa6bdf8fe1a1d64ede27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955388943fcbc2f37a8cbccb22d331bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a955388943fcbc2f37a8cbccb22d331bf"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>get_frzcpi</b> ()</td></tr>
<tr class="separator:a955388943fcbc2f37a8cbccb22d331bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d74d3f3d76b7e727fc752f5fd462d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64d74d3f3d76b7e727fc752f5fd462d3"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>get_frzvpi</b> ()</td></tr>
<tr class="separator:a64d74d3f3d76b7e727fc752f5fd462d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c3f6a2c6ef8c8ac41cb185632f6223"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65c3f6a2c6ef8c8ac41cb185632f6223"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmat_point</b> (double *A, double *B, double *C, double R_CD, double theta_BCD, double phi_ABCD, double *D)</td></tr>
<tr class="separator:a65c3f6a2c6ef8c8ac41cb185632f6223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0791de30e92995cb033b1914bf8cc38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0791de30e92995cb033b1914bf8cc38"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rotate_vecs</b> (double *axis, double phi, double **vectors, int num_vectors)</td></tr>
<tr class="separator:ab0791de30e92995cb033b1914bf8cc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d765f00223b3e7d05020d7e4e91e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7d765f00223b3e7d05020d7e4e91e24"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dot_prod</b> (double *v1, double *v2)</td></tr>
<tr class="separator:ab7d765f00223b3e7d05020d7e4e91e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d74aad1a226bd5c16eb2782238c9bc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d74aad1a226bd5c16eb2782238c9bc8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cross_prod</b> (double *v1, double *v2, double *out)</td></tr>
<tr class="separator:a6d74aad1a226bd5c16eb2782238c9bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0b4196db516d6e85a3b3148fd912d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e0b4196db516d6e85a3b3148fd912d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unit_vec</b> (double *B, double *A, double *AB)</td></tr>
<tr class="separator:a2e0b4196db516d6e85a3b3148fd912d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3a891c486a6de00fdb7e85ce849e96"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5f3a891c486a6de00fdb7e85ce849e96">strncpy</a> (char *dest, const char *source, size_t n)</td></tr>
<tr class="memdesc:a5f3a891c486a6de00fdb7e85ce849e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="namespacepsi.html#a5f3a891c486a6de00fdb7e85ce849e96" title="Same as strncpy(), but make sure that dest ends in \0.">strncpy()</a>, but make sure that dest ends in \0.  <a href="#a5f3a891c486a6de00fdb7e85ce849e96">More...</a><br/></td></tr>
<tr class="separator:a5f3a891c486a6de00fdb7e85ce849e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19cb5d0d6eea56f06ed5c5f70136af6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gae19cb5d0d6eea56f06ed5c5f70136af6">bisect</a> (double(*function)(double), double low, double high, double tolerance, int maxiter, int printflag)</td></tr>
<tr class="separator:gae19cb5d0d6eea56f06ed5c5f70136af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40f9710ebd1018e9161a07f4d346358"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaa40f9710ebd1018e9161a07f4d346358">newton</a> (double(*F)(double), double(*dF)(double), double x, double tolerance, int maxiter, int printflag)</td></tr>
<tr class="separator:gaa40f9710ebd1018e9161a07f4d346358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977f97f88a9d2b3e1df588b8b33c9b57"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga977f97f88a9d2b3e1df588b8b33c9b57">secant</a> (double(*F)(double), double x0, double x1, double tolerance, int maxiter, int printflag)</td></tr>
<tr class="separator:ga977f97f88a9d2b3e1df588b8b33c9b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafada6de1652da33accacc15f68333d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gafada6de1652da33accacc15f68333d5b">stringset_init</a> (<a class="el" href="structpsi_1_1StringSet.html">StringSet</a> *sset, int size, int nelec, int nfzc, short int *frozen_occ)</td></tr>
<tr class="separator:gafada6de1652da33accacc15f68333d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f8571e95ec167f1a11afdf7b216f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gae5f8571e95ec167f1a11afdf7b216f3a">stringset_delete</a> (<a class="el" href="structpsi_1_1StringSet.html">StringSet</a> *sset)</td></tr>
<tr class="separator:gae5f8571e95ec167f1a11afdf7b216f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb5d78c936c34a1bff25de237c499f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga1eb5d78c936c34a1bff25de237c499f0">stringset_add</a> (<a class="el" href="structpsi_1_1StringSet.html">StringSet</a> *sset, int index, unsigned char *Occ)</td></tr>
<tr class="separator:ga1eb5d78c936c34a1bff25de237c499f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad699d26dd571c528fa87f1dfb3182144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad699d26dd571c528fa87f1dfb3182144">stringset_reindex</a> (<a class="el" href="structpsi_1_1StringSet.html">StringSet</a> *sset, short int *mo_map)</td></tr>
<tr class="separator:gad699d26dd571c528fa87f1dfb3182144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf365a9600d2d5b4a83eb37faa58b1d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaf365a9600d2d5b4a83eb37faa58b1d34">stringset_write</a> (ULI unit, const char *prefix, <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> *sset)</td></tr>
<tr class="separator:gaf365a9600d2d5b4a83eb37faa58b1d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac15eb8e301802fa8f61e31f6a4b0b3c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gac15eb8e301802fa8f61e31f6a4b0b3c2">stringset_read</a> (ULI unit, const char *prefix, <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> **stringset)</td></tr>
<tr class="separator:gac15eb8e301802fa8f61e31f6a4b0b3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cbaa8b39c036ee7aaef4c9bd40e8361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga0cbaa8b39c036ee7aaef4c9bd40e8361">slaterdetset_init</a> (<a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> *sdset, int size, <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> *alphastrings, <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> *betastrings)</td></tr>
<tr class="separator:ga0cbaa8b39c036ee7aaef4c9bd40e8361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0601e4d7e98acc68dcc937310497b820"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga0601e4d7e98acc68dcc937310497b820">slaterdetset_delete</a> (<a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> *sdset)</td></tr>
<tr class="separator:ga0601e4d7e98acc68dcc937310497b820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf99ef26d644c66cc20b449c6aa12455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gabf99ef26d644c66cc20b449c6aa12455">slaterdetset_delete_full</a> (<a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> *sdset)</td></tr>
<tr class="separator:gabf99ef26d644c66cc20b449c6aa12455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ceae3c7f3337f3c04648d58091336f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga63ceae3c7f3337f3c04648d58091336f">slaterdetset_add</a> (<a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> *sdset, int index, int alphastring, int betastring)</td></tr>
<tr class="separator:ga63ceae3c7f3337f3c04648d58091336f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7821e5bc1ee8563d8284274163c9eb9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga7821e5bc1ee8563d8284274163c9eb9e">slaterdetset_write</a> (ULI unit, const char *prefix, <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> *sdset)</td></tr>
<tr class="separator:ga7821e5bc1ee8563d8284274163c9eb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2d65a1290e904986d93f3436848ab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga4a2d65a1290e904986d93f3436848ab0">slaterdetset_read</a> (ULI unit, const char *prefix, <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> **slaterdetset)</td></tr>
<tr class="separator:ga4a2d65a1290e904986d93f3436848ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92f6aaa81bb1d58628d4789be57d1d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad92f6aaa81bb1d58628d4789be57d1d4">slaterdetvector_init</a> (<a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> *sdvector, <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> *sdset)</td></tr>
<tr class="separator:gad92f6aaa81bb1d58628d4789be57d1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd2c106d795cdb373645726bbbc1ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga2bd2c106d795cdb373645726bbbc1ccd">slaterdetvector_delete</a> (<a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> *sdvector)</td></tr>
<tr class="separator:ga2bd2c106d795cdb373645726bbbc1ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90db736f729453581b078f727856f432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga90db736f729453581b078f727856f432">slaterdetvector_delete_full</a> (<a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> *sdvector)</td></tr>
<tr class="separator:ga90db736f729453581b078f727856f432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65981e9e946fca7adc3e44e6212da8ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga65981e9e946fca7adc3e44e6212da8ed">slaterdetvector_add</a> (<a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> *sdvector, int index, double coeff)</td></tr>
<tr class="separator:ga65981e9e946fca7adc3e44e6212da8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609f6f82ffadb8fed1d312ce92635244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga609f6f82ffadb8fed1d312ce92635244">slaterdetvector_set</a> (<a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> *sdvector, double *coeffs)</td></tr>
<tr class="separator:ga609f6f82ffadb8fed1d312ce92635244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46021bca516a5b4b429384151036ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gac46021bca516a5b4b429384151036ed8">slaterdetvector_write</a> (ULI unit, const char *prefix, <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> *vector)</td></tr>
<tr class="separator:gac46021bca516a5b4b429384151036ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab353180af2fc2bcd3e513d37a3425fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gab353180af2fc2bcd3e513d37a3425fbd">slaterdetset_write_vect</a> (ULI unit, const char *prefix, double *coeffs, int size, int vectnum)</td></tr>
<tr class="separator:gab353180af2fc2bcd3e513d37a3425fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67eca5299660efcf885f7bd743b587f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga67eca5299660efcf885f7bd743b587f9">slaterdetvector_read</a> (ULI unit, const char *prefix, <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> **sdvector)</td></tr>
<tr class="separator:ga67eca5299660efcf885f7bd743b587f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0d9992fdf633f70982de16d3021933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga1c0d9992fdf633f70982de16d3021933">slaterdetset_read_vect</a> (ULI unit, const char *prefix, double *coeffs, int size, int vectnum)</td></tr>
<tr class="separator:ga1c0d9992fdf633f70982de16d3021933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ba9a6fa70806080a0e81eb75a32f73"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpsi_1_1timer.html">timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga86ba9a6fa70806080a0e81eb75a32f73">timer_scan</a> (const char *key)</td></tr>
<tr class="separator:ga86ba9a6fa70806080a0e81eb75a32f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d117bc027524c4c54193d70b70c77aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d117bc027524c4c54193d70b70c77aa"></a>
struct <a class="el" href="structpsi_1_1timer.html">timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>timer_last</b> (void)</td></tr>
<tr class="separator:a1d117bc027524c4c54193d70b70c77aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac786b9c919ea6fcf644b7e39808b09"><td class="memTemplParams" colspan="2"><a class="anchor" id="afac786b9c919ea6fcf644b7e39808b09"></a>
template&lt;class DPDFunctor , class FockFunctor &gt; </td></tr>
<tr class="memitem:afac786b9c919ea6fcf644b7e39808b09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iwl_integrals</b> (<a class="el" href="classpsi_1_1IWL.html">IWL</a> *iwl, DPDFunctor &amp;dpd, FockFunctor &amp;fock)</td></tr>
<tr class="separator:afac786b9c919ea6fcf644b7e39808b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606ca1816a4c81be0b012a273d2b645b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a606ca1816a4c81be0b012a273d2b645b">generate_combinations</a> (int n, int k, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;<a class="el" href="group__QT.html#gabc6c5e50bb519f541ce97a049a11f36c">combinations</a>)</td></tr>
<tr class="separator:a606ca1816a4c81be0b012a273d2b645b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8ed713f810463c1b3962aeab109d88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e8ed713f810463c1b3962aeab109d88"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>file_to_string</b> (std::string const &amp;name)</td></tr>
<tr class="separator:a0e8ed713f810463c1b3962aeab109d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b4e1e6d3a94b40dae83995ec4f4956"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53b4e1e6d3a94b40dae83995ec4f4956"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>space</b> (char c)</td></tr>
<tr class="separator:a53b4e1e6d3a94b40dae83995ec4f4956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c921290edf3bab679ea50006a0cd57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03c921290edf3bab679ea50006a0cd57"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>not_space</b> (char c)</td></tr>
<tr class="separator:a03c921290edf3bab679ea50006a0cd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0271200fc76cc1b2dcca709603356c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a0271200fc76cc1b2dcca709603356c"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a3a0271200fc76cc1b2dcca709603356c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244dde215a6a957090c76da047ac4ccf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a244dde215a6a957090c76da047ac4ccf"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split_indices</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a244dde215a6a957090c76da047ac4ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bc539fa1eff187e7258fdf4a6779a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6bc539fa1eff187e7258fdf4a6779a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>to_lower</b> (std::string &amp;str)</td></tr>
<tr class="separator:ad6bc539fa1eff187e7258fdf4a6779a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83d8405959083f13895f2804024830a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa83d8405959083f13895f2804024830a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>to_upper</b> (std::string &amp;str)</td></tr>
<tr class="separator:aa83d8405959083f13895f2804024830a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ca187174d00d0de1f6281e264db1a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1ca187174d00d0de1f6281e264db1a4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const int val)</td></tr>
<tr class="separator:ab1ca187174d00d0de1f6281e264db1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebb9470105fcb3ec1c77cc6ab7c67da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abebb9470105fcb3ec1c77cc6ab7c67da"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const double val)</td></tr>
<tr class="separator:abebb9470105fcb3ec1c77cc6ab7c67da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc48d4a18c0d86c79db6fec7817c383"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bc48d4a18c0d86c79db6fec7817c383"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>to_double</b> (const std::string str)</td></tr>
<tr class="separator:a0bc48d4a18c0d86c79db6fec7817c383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97061973a32411dd7e12052a672c5e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad97061973a32411dd7e12052a672c5e8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>ToDouble</b> (const std::string inString)</td></tr>
<tr class="separator:ad97061973a32411dd7e12052a672c5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576871ad813ee220d1763ff9ab0c1e75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a576871ad813ee220d1763ff9ab0c1e75"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>string_to_integer</b> (const std::string inString)</td></tr>
<tr class="separator:a576871ad813ee220d1763ff9ab0c1e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23050498d6b4161d67b6010a279058ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23050498d6b4161d67b6010a279058ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>append_reference</b> (std::string &amp;str, int reference)</td></tr>
<tr class="separator:a23050498d6b4161d67b6010a279058ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7e9da1ff93d41a090699161f45f40d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d7e9da1ff93d41a090699161f45f40d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>add_reference</b> (std::string &amp;str, int reference)</td></tr>
<tr class="separator:a9d7e9da1ff93d41a090699161f45f40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e21bed68e628f563d944023b02ed29b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e21bed68e628f563d944023b02ed29b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>find_and_replace</b> (std::string &amp;source, const std::string &amp;target, const std::string &amp;replace)</td></tr>
<tr class="separator:a3e21bed68e628f563d944023b02ed29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c56964082e37014f60ffbaf49ea4fdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c56964082e37014f60ffbaf49ea4fdf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>trim_spaces</b> (std::string &amp;str)</td></tr>
<tr class="separator:a8c56964082e37014f60ffbaf49ea4fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5277cf32f1d0defe02dde86b5dd36afd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a5277cf32f1d0defe02dde86b5dd36afd">edit_distance</a> (const std::string &amp;s1, const std::string &amp;s2)</td></tr>
<tr class="memdesc:a5277cf32f1d0defe02dde86b5dd36afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Levenshtein distance between two strings.  <a href="#a5277cf32f1d0defe02dde86b5dd36afd">More...</a><br/></td></tr>
<tr class="separator:a5277cf32f1d0defe02dde86b5dd36afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336f5b1d3f701ae1b6778817dbc8c08b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a336f5b1d3f701ae1b6778817dbc8c08b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_to_MiB</b> (size_t n)</td></tr>
<tr class="separator:a336f5b1d3f701ae1b6778817dbc8c08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5a3d1c71b488e775f1b021fb663b24"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e5a3d1c71b488e775f1b021fb663b24"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e5a3d1c71b488e775f1b021fb663b24"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_to_MiB</b> (size_t n)</td></tr>
<tr class="separator:a4e5a3d1c71b488e775f1b021fb663b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d418e22999cca83a58c7b57446c0483"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d418e22999cca83a58c7b57446c0483"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>opening_square_bracket</b> (char c)</td></tr>
<tr class="separator:a6d418e22999cca83a58c7b57446c0483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b8e6ab7b67a5483ea4f2666bfcf7d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3b8e6ab7b67a5483ea4f2666bfcf7d8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>closing_square_bracket</b> (char c)</td></tr>
<tr class="separator:aa3b8e6ab7b67a5483ea4f2666bfcf7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbf84374d9759eaa86f809a20f0cee0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a7cbf84374d9759eaa86f809a20f0cee0">to_MB</a> (size_t n)</td></tr>
<tr class="separator:a7cbf84374d9759eaa86f809a20f0cee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d1b5fa724a3feeddcec07f16c9ba2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44d1b5fa724a3feeddcec07f16c9ba2f"></a>
unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><b>init_smatrix</b> (short **&amp;matrix, int size1, int size2)</td></tr>
<tr class="separator:a44d1b5fa724a3feeddcec07f16c9ba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ddab6d4cfadf1e54107b37cc9e25ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34ddab6d4cfadf1e54107b37cc9e25ac"></a>
unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><b>free_smatrix</b> (short **&amp;matrix, int size1, int size2)</td></tr>
<tr class="separator:a34ddab6d4cfadf1e54107b37cc9e25ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a020c7912b821219d256411e58b14b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31a020c7912b821219d256411e58b14b"></a>
unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><b>init_smatrix</b> (short ***&amp;matrix, int size1, int size2, int size3)</td></tr>
<tr class="separator:a31a020c7912b821219d256411e58b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c37f587c750c5c15898cc0932379dea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c37f587c750c5c15898cc0932379dea"></a>
unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><b>free_smatrix</b> (short ***matrix, int size1, int size2, int size3)</td></tr>
<tr class="separator:a0c37f587c750c5c15898cc0932379dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1243531ac7460a7b69504789f99bf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aae1243531ac7460a7b69504789f99bf3">psiclean</a> (void)</td></tr>
<tr class="separator:aae1243531ac7460a7b69504789f99bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93516a5215e70af197cf030e7652cd3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93516a5215e70af197cf030e7652cd3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>create_new_plugin</b> (std::string name, const std::string &amp;template_name)</td></tr>
<tr class="separator:a93516a5215e70af197cf030e7652cd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga588c61c7d42cb14c9acff5f88825a355"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PSI4.html#ga588c61c7d42cb14c9acff5f88825a355">psi_start</a> (int argc, char *argv[])</td></tr>
<tr class="separator:ga588c61c7d42cb14c9acff5f88825a355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d4683ce326e4e77eba2ef4892b2683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#af0d4683ce326e4e77eba2ef4892b2683">print_version</a> (FILE *)</td></tr>
<tr class="separator:af0d4683ce326e4e77eba2ef4892b2683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade25133ac572647d03ad24678053ef75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade25133ac572647d03ad24678053ef75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_memory</b> (FILE *outfile)</td></tr>
<tr class="separator:ade25133ac572647d03ad24678053ef75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31580ee41b2ce55c8d9988ee01757e3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31580ee41b2ce55c8d9988ee01757e3d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>psi4_driver</b> ()</td></tr>
<tr class="separator:a31580ee41b2ce55c8d9988ee01757e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6896b86eeac552e4c28f6dac7732d19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac6896b86eeac552e4c28f6dac7732d19">read_options</a> (const std::string &amp;name, <a class="el" href="classpsi_1_1Options.html">Options</a> &amp;options, bool suppress_printing=false)</td></tr>
<tr class="separator:ac6896b86eeac552e4c28f6dac7732d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbfba5ae305624db512f9fe2a3e58a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a9cbfba5ae305624db512f9fe2a3e58a0">print_usage</a> ()</td></tr>
<tr class="separator:a9cbfba5ae305624db512f9fe2a3e58a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac9990653803aa8a6b0fae70177cbfaf2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9990653803aa8a6b0fae70177cbfaf2"></a>
int **&#160;</td><td class="memItemRight" valign="bottom"><b>compute_atom_map</b> (const <a class="el" href="classpsi_1_1Molecule.html">Molecule</a> *molecule)</td></tr>
<tr class="separator:ac9990653803aa8a6b0fae70177cbfaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c90070bfb99a22978e02642d093bdab"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a4c90070bfb99a22978e02642d093bdab">compute_atom_map</a> (const <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Molecule.html">Molecule</a> &gt; &amp;molecule)</td></tr>
<tr class="separator:a4c90070bfb99a22978e02642d093bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aebca1f9e20b6e3bc59dba1bafb56a471"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebca1f9e20b6e3bc59dba1bafb56a471"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delete_atom_map</b> (int **atom_map, const <a class="el" href="classpsi_1_1Molecule.html">Molecule</a> *molecule)</td></tr>
<tr class="separator:aebca1f9e20b6e3bc59dba1bafb56a471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c7337031dbbfa63d72a81b93c80b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a61c7337031dbbfa63d72a81b93c80b77">delete_atom_map</a> (int **atom_map, const <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Molecule.html">Molecule</a> &gt; &amp;molecule)</td></tr>
<tr class="separator:a61c7337031dbbfa63d72a81b93c80b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae8d958efff28350f83e0eabe9709c44c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8d958efff28350f83e0eabe9709c44c"></a>
<a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Chkpt.html">Chkpt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_default_chkpt_lib_</b></td></tr>
<tr class="separator:ae8d958efff28350f83e0eabe9709c44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c2d1b59f70d7cf553dff8a0a94c13d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1c2d1b59f70d7cf553dff8a0a94c13d"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>psi_file_prefix</b></td></tr>
<tr class="separator:aa1c2d1b59f70d7cf553dff8a0a94c13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c0ab3e6b6b95d202b1f458121c89d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07c0ab3e6b6b95d202b1f458121c89d4"></a>
FILE *&#160;</td><td class="memItemRight" valign="bottom"><b>outfile</b></td></tr>
<tr class="separator:a07c0ab3e6b6b95d202b1f458121c89d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca49d498424fa127ff5883b311f55fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abca49d498424fa127ff5883b311f55fa"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>time_start</b></td></tr>
<tr class="separator:abca49d498424fa127ff5883b311f55fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a51a0cfc4bd9104377cd4f2de9efc6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a51a0cfc4bd9104377cd4f2de9efc6c"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>time_end</b></td></tr>
<tr class="separator:a8a51a0cfc4bd9104377cd4f2de9efc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b200aeb72a4b26c5976d084ff330e98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b200aeb72a4b26c5976d084ff330e98"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>time_start_overall</b></td></tr>
<tr class="separator:a8b200aeb72a4b26c5976d084ff330e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6694e7dd1d4b7bad854fb83afd5e1ac6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6694e7dd1d4b7bad854fb83afd5e1ac6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>running</b> = 0</td></tr>
<tr class="separator:a6694e7dd1d4b7bad854fb83afd5e1ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd772ad5fb46548d7e0bb6e0e23c726b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd772ad5fb46548d7e0bb6e0e23c726b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>user_start</b></td></tr>
<tr class="separator:acd772ad5fb46548d7e0bb6e0e23c726b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa47af3fd1b9ecaef44275298c89e66e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa47af3fd1b9ecaef44275298c89e66e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>sys_start</b></td></tr>
<tr class="separator:afa47af3fd1b9ecaef44275298c89e66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e84e7af643b6b0c70518ef20592189e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e84e7af643b6b0c70518ef20592189e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>user_start_overall</b></td></tr>
<tr class="separator:a6e84e7af643b6b0c70518ef20592189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eabfaaa67ecbc683d2b2ca05b8048c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eabfaaa67ecbc683d2b2ca05b8048c6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>sys_start_overall</b></td></tr>
<tr class="separator:a3eabfaaa67ecbc683d2b2ca05b8048c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79f9efc648083bb810e9f411c0aa8cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af79f9efc648083bb810e9f411c0aa8cf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>user_stop</b></td></tr>
<tr class="separator:af79f9efc648083bb810e9f411c0aa8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0236727fac78e27989f2d2091d364fdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0236727fac78e27989f2d2091d364fdd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>sys_stop</b></td></tr>
<tr class="separator:a0236727fac78e27989f2d2091d364fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2de5d6c7b38956ec9bae7fdd44c5436"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2de5d6c7b38956ec9bae7fdd44c5436"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>RvdW_D1_</b> []</td></tr>
<tr class="separator:aa2de5d6c7b38956ec9bae7fdd44c5436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8865f75257806a6f76b3348bffb7e558"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8865f75257806a6f76b3348bffb7e558"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>C6_D1_</b> []</td></tr>
<tr class="separator:a8865f75257806a6f76b3348bffb7e558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cff7f50d03073313c2110ca830d13c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cff7f50d03073313c2110ca830d13c0"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>RvdW_D2_</b> []</td></tr>
<tr class="separator:a0cff7f50d03073313c2110ca830d13c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c3e96844e8e1d71188dca8dc27d94c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0c3e96844e8e1d71188dca8dc27d94c"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>C6_D2_</b> []</td></tr>
<tr class="separator:ac0c3e96844e8e1d71188dca8dc27d94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648fa8b97c496ac4906bf8308aaf4b43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a648fa8b97c496ac4906bf8308aaf4b43"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>R_cov_</b> []</td></tr>
<tr class="separator:a648fa8b97c496ac4906bf8308aaf4b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024aaaf5eabc0b03449ed2bd8ca0f4e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a024aaaf5eabc0b03449ed2bd8ca0f4e0"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>C6_Das2009_</b> []</td></tr>
<tr class="separator:a024aaaf5eabc0b03449ed2bd8ca0f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6272c9a0f425868722da0bc6e2e2e432"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6272c9a0f425868722da0bc6e2e2e432"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>C8_Das2009_</b> []</td></tr>
<tr class="separator:a6272c9a0f425868722da0bc6e2e2e432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15005f5bee4eb19806447e7b289d3907"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15005f5bee4eb19806447e7b289d3907"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>Beta_Das2009_</b> []</td></tr>
<tr class="separator:a15005f5bee4eb19806447e7b289d3907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb75c826320bfa144306e724a0fda21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bb75c826320bfa144306e724a0fda21"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>A_Das2009_</b> []</td></tr>
<tr class="separator:a6bb75c826320bfa144306e724a0fda21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f54c255fca1396446cd98beba35bf9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f54c255fca1396446cd98beba35bf9b"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>C6_Das2010_</b> []</td></tr>
<tr class="separator:a5f54c255fca1396446cd98beba35bf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2009ae08a2f75db70f285d39e5be7ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2009ae08a2f75db70f285d39e5be7ab"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>C8_Das2010_</b> []</td></tr>
<tr class="separator:af2009ae08a2f75db70f285d39e5be7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf23e062c7d5ec199d7f5ff995f3945"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf23e062c7d5ec199d7f5ff995f3945"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>Beta_Das2010_</b> []</td></tr>
<tr class="separator:a2cf23e062c7d5ec199d7f5ff995f3945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017e964c7a0cfac6a02aabbb22008b02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a017e964c7a0cfac6a02aabbb22008b02"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>R_0_AB_</b> []</td></tr>
<tr class="separator:a017e964c7a0cfac6a02aabbb22008b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1d79810fa7e1528bdff45e7d88d503"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa1d79810fa7e1528bdff45e7d88d503"></a>
<a class="el" href="structpsi_1_1dpd__gbl.html">dpd_gbl</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dpd_main</b></td></tr>
<tr class="separator:afa1d79810fa7e1528bdff45e7d88d503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42cfa84ff292dec6152aa6f6ab96364"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac42cfa84ff292dec6152aa6f6ab96364"></a>
<a class="el" href="classpsi_1_1DPD.html">DPD</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>global_dpd_</b> = NULL</td></tr>
<tr class="separator:ac42cfa84ff292dec6152aa6f6ab96364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b1ae1e53223ef25ca58220156acf55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16b1ae1e53223ef25ca58220156acf55"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dpd_default</b> = 0</td></tr>
<tr class="separator:a16b1ae1e53223ef25ca58220156acf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c57e097140c011ff21c25e7b1dedf50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c57e097140c011ff21c25e7b1dedf50"></a>
<a class="el" href="classpsi_1_1DPD.html">DPD</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>dpd_list</b> [2] = {NULL, NULL}</td></tr>
<tr class="separator:a6c57e097140c011ff21c25e7b1dedf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6375e48020e50a326419884666c11062"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6375e48020e50a326419884666c11062"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>counter</b></td></tr>
<tr class="separator:a6375e48020e50a326419884666c11062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076f1e4eafb7dfdd7c93c22b981e31d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a076f1e4eafb7dfdd7c93c22b981e31d9"></a>
boost::smatch&#160;</td><td class="memItemRight" valign="bottom"><b>reMatches_</b></td></tr>
<tr class="separator:a076f1e4eafb7dfdd7c93c22b981e31d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8de8a28e0686b5933f00d847a83cd7"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>RotorTypeList</b> []</td></tr>
<tr class="separator:adc8de8a28e0686b5933f00d847a83cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c093cae362342b3d80520c5b94fb4a"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>FullPointGroupList</b> []</td></tr>
<tr class="separator:a72c093cae362342b3d80520c5b94fb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f653ae7eee5a58671c9fb98acfde5d8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>labels</b> []</td></tr>
<tr class="separator:a9f653ae7eee5a58671c9fb98acfde5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70f35879864dfa2ad4baca1077e626f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac70f35879864dfa2ad4baca1077e626f"></a>
<a class="el" href="classpsi_1_1ModelSpace.html">ModelSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>model_space</b></td></tr>
<tr class="separator:ac70f35879864dfa2ad4baca1077e626f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050067c192b1171d4aaf65d325411b8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a050067c192b1171d4aaf65d325411b8d"></a>
<a class="el" href="classpsi_1_1MOInfoSCF.html">MOInfoSCF</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>moinfo_scf</b> = 0</td></tr>
<tr class="separator:a050067c192b1171d4aaf65d325411b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c2d70ac342edaa411983df9a10fae4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64c2d70ac342edaa411983df9a10fae4"></a>
<a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1LocalCommWrapper.html">worldcomm</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WorldComm</b></td></tr>
<tr class="separator:a64c2d70ac342edaa411983df9a10fae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c94efed12faf73b3441abb7634a11f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpsi_1_1psio__address.html">psio_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8c94efed12faf73b3441abb7634a11f4">PSIO_ZERO</a> = { 0, 0 }</td></tr>
<tr class="separator:a8c94efed12faf73b3441abb7634a11f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239a55f5309e3fc7b16342247e2d50b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a239a55f5309e3fc7b16342247e2d50b1"></a>
<a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1PSIO.html">PSIO</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_default_psio_lib_</b></td></tr>
<tr class="separator:a239a55f5309e3fc7b16342247e2d50b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0eb78c426199d5484818deab8bc002"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e0eb78c426199d5484818deab8bc002"></a>
<a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1PSIOManager.html">PSIOManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_default_psio_manager_</b></td></tr>
<tr class="separator:a6e0eb78c426199d5484818deab8bc002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0706f741de71c6be28c2eab5d4cf120b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0706f741de71c6be28c2eab5d4cf120b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nmo</b></td></tr>
<tr class="separator:a0706f741de71c6be28c2eab5d4cf120b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564464877c74d345ab08d5f05985a411"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a564464877c74d345ab08d5f05985a411"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nso</b></td></tr>
<tr class="separator:a564464877c74d345ab08d5f05985a411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a2302556f5e31b994750e86a5e2b31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1a2302556f5e31b994750e86a5e2b31"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nao</b></td></tr>
<tr class="separator:aa1a2302556f5e31b994750e86a5e2b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556c9b2332823a45614d6961442a2e26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a556c9b2332823a45614d6961442a2e26"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>scf</b></td></tr>
<tr class="separator:a556c9b2332823a45614d6961442a2e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c38c8f737de92810b150884db41aeb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c38c8f737de92810b150884db41aeb7"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>u</b></td></tr>
<tr class="separator:a3c38c8f737de92810b150884db41aeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f31b8171f2ae15aaae6655beb3473d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6f31b8171f2ae15aaae6655beb3473d"></a>
<a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Molecule.html">Molecule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>molecule</b></td></tr>
<tr class="separator:ae6f31b8171f2ae15aaae6655beb3473d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6ed21a0fcd1d50ccab104cc872b9c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c6ed21a0fcd1d50ccab104cc872b9c7"></a>
<a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1BasisSet.html">BasisSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>basis</b></td></tr>
<tr class="separator:a8c6ed21a0fcd1d50ccab104cc872b9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a32882ec9764f56be605bc350aba86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88a32882ec9764f56be605bc350aba86"></a>
<a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; <a class="el" href="classpsi_1_1Wavefunction.html">Wavefunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>wfn</b></td></tr>
<tr class="separator:a88a32882ec9764f56be605bc350aba86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab3403b57c09377d60f6fa804f5f616"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abab3403b57c09377d60f6fa804f5f616"></a>
struct <a class="el" href="structpsi_1_1timer.html">timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>global_timer</b></td></tr>
<tr class="separator:abab3403b57c09377d60f6fa804f5f616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21811f0cdc21a8eb8e6bdf745f14f920"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21811f0cdc21a8eb8e6bdf745f14f920"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>timer_start</b></td></tr>
<tr class="separator:a21811f0cdc21a8eb8e6bdf745f14f920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b8cc9cc2bccae7e0f33f869fdf2923"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3b8cc9cc2bccae7e0f33f869fdf2923"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>timer_end</b></td></tr>
<tr class="separator:ad3b8cc9cc2bccae7e0f33f869fdf2923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548e2bbcaba8b1632c17c3217404fa0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a548e2bbcaba8b1632c17c3217404fa0b"></a>
<a class="el" href="classpsi_1_1Chkpt.html">Chkpt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>chkpt_</b></td></tr>
<tr class="separator:a548e2bbcaba8b1632c17c3217404fa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e31a9d26bc239411314ee80ea94a2fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e31a9d26bc239411314ee80ea94a2fa"></a>
<a class="el" href="classpsi_1_1PSIO.html">PSIO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>psio</b> = NULL</td></tr>
<tr class="separator:a9e31a9d26bc239411314ee80ea94a2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac695e1157b9fba301853f7ee785ac3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afac695e1157b9fba301853f7ee785ac3"></a>
EXT FILE *&#160;</td><td class="memItemRight" valign="bottom"><b>infile</b></td></tr>
<tr class="separator:afac695e1157b9fba301853f7ee785ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa327f1f5df8505d1e6e7a69bfe4c344c"><td class="memItemLeft" align="right" valign="top">EXT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aa327f1f5df8505d1e6e7a69bfe4c344c">infile_directory</a></td></tr>
<tr class="separator:aa327f1f5df8505d1e6e7a69bfe4c344c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eeb423fdd687175fee5149ee448f27b"><td class="memItemLeft" align="right" valign="top">EXT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a8eeb423fdd687175fee5149ee448f27b">verbose</a></td></tr>
<tr class="separator:a8eeb423fdd687175fee5149ee448f27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add629624c145fff88641b7b7b3bc9382"><td class="memItemLeft" align="right" valign="top">EXT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#add629624c145fff88641b7b7b3bc9382">check_only</a></td></tr>
<tr class="separator:add629624c145fff88641b7b7b3bc9382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c399241015be2f4d81d6cc06531ac5"><td class="memItemLeft" align="right" valign="top">EXT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#ac3c399241015be2f4d81d6cc06531ac5">messy</a></td></tr>
<tr class="separator:ac3c399241015be2f4d81d6cc06531ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a558f999450c5be8cf9cda2f4c6751"><td class="memItemLeft" align="right" valign="top">EXT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a00a558f999450c5be8cf9cda2f4c6751">clean_only</a></td></tr>
<tr class="separator:a00a558f999450c5be8cf9cda2f4c6751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe0a6e64f9005f6c2f6f4f195bec003"><td class="memItemLeft" align="right" valign="top">EXT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#aefe0a6e64f9005f6c2f6f4f195bec003">skip_input_preprocess</a></td></tr>
<tr class="separator:aefe0a6e64f9005f6c2f6f4f195bec003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614891df433e7f7d5cae8d3c84aadc42"><td class="memItemLeft" align="right" valign="top">EXT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html#a614891df433e7f7d5cae8d3c84aadc42">interactive_python</a></td></tr>
<tr class="separator:a614891df433e7f7d5cae8d3c84aadc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0ca57c6036bd3e396da51d2bbd27b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f0ca57c6036bd3e396da51d2bbd27b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>outfile_name</b></td></tr>
<tr class="separator:a1f0ca57c6036bd3e396da51d2bbd27b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7fd068af33dcf37525eb3cb195ab59"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Z_to_element</b> []</td></tr>
<tr class="separator:ace7fd068af33dcf37525eb3cb195ab59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Rotate a set of vectors around an arbitrary axis Vectors are rows of input matrix. </p>
<p><a class="el" href="jk__independent_8h_source.html">jk_independent.h</a></p>
<p>Created by Bill March, 2/25/13</p>
<p>This is a version of the <a class="el" href="classpsi_1_1JK.html">JK</a> class that takes two classes as template arguments and uses them to create the J and K matrices. This allows us to specify two different methods for the two matrices, such as CFMM and <a class="el" href="classpsi_1_1LinK.html">LinK</a>.</p>
<p>Problem with this: how do I instantiate it? I'll have to add to RHF or where ever this happens.</p>
<p>rotate_vecs(): Rotate a set of vectors around an arbitrary axis</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>double * : axis to rotate around (wx, wy, wz) - gets normalized here </td></tr>
    <tr><td class="paramname">phi</td><td>double : magnitude of rotation </td></tr>
    <tr><td class="paramname">v</td><td>double ** : points to rotate - column dim is 3; overwritten on exit </td></tr>
    <tr><td class="paramname">num_v</td><td>int :</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none</p>
<p>Rollin King, Feb. 2008</p>
<p>AEL() computes the approximate excitation level according to Stanton and Bartlett, JCP, 98, 1993, 7034. Trace [rho(excited) - rho(ground)] = AEL where both densities are expressed in the basis that diagonalizes the ground-state CCSD density. I was never able to get these results to agree with those of JFS or the current ACES2 so I'm not going to use this right now. &ndash;RAK </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae94898dbde057458f7f55480abd1ef90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::benchmark_blas1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a benchmark traverse of BLAS 1 routines on the current hardware </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>maximum dimension exponent (requires ~ 3 (2^N x 2^N) double matrices </td></tr>
    <tr><td class="paramname">min_time</td><td>minimum amount of time to run each routine [s] </td></tr>
    <tr><td class="paramname">nthread</td><td>maximum number of threads to use </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ae94898dbde057458f7f55480abd1ef90_cgraph.svg" width="323" height="342"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4f4e9e11a4a771b54e65f2223ceba66b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::benchmark_blas2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a benchmark traverse of BLAS 2 routines on the current hardware </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>maximum dimension exponent (requires ~ 3 (2^N x 2^N) double matrices </td></tr>
    <tr><td class="paramname">min_time</td><td>minimum amount of time to run each routine [s] </td></tr>
    <tr><td class="paramname">nthread</td><td>maximum number of threads to use </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a4f4e9e11a4a771b54e65f2223ceba66b_cgraph.svg" width="323" height="139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7fe743339b4c555d69aa96c0bdea7474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::benchmark_blas3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthread</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a benchmark traverse of BLAS 3 and LAPACK routines on the current hardware </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>maximum dimension exponent (requires ~ 4 (2^N x 2^N) double matrices </td></tr>
    <tr><td class="paramname">min_time</td><td>minimum amount of time to run each routine [s] </td></tr>
    <tr><td class="paramname">nthread</td><td>maximum number of threads to use </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacepsi_a7fe743339b4c555d69aa96c0bdea7474_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad2d2b10d46e85d8d8389d849b2c24607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::benchmark_disk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a benchmark of <a class="el" href="classpsi_1_1PSIO.html">PSIO</a> disk performance on the current hardware </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>maximum dimension exponent (requires 1 (2^N x 2^N) double matrices </td></tr>
    <tr><td class="paramname">min_time</td><td>minimum amount of time to run each routine [s] </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ad2d2b10d46e85d8d8389d849b2c24607_cgraph.svg" width="371" height="139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a10438bc4af3d0303663c48f3c3cfe32a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::benchmark_integrals </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_am</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a benchmark of psi integrals (of libmints type) on the current hardware All integrals will be called from different centers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_am</td><td>maximum am to consider </td></tr>
    <tr><td class="paramname">min_time</td><td>minimum time to run each shell combination of each integral type </td></tr>
  </table>
  </dd>
</dl>
<p>Poisson Ints this_type = "2C Poisson"; this_ncenter = 2; boost::shared_ptr&lt;OneBodyAOInt&gt; p2c(bbbb-&gt;poisson_overlap()); for (int P = 0, index = 0; P &lt; max_shell; P++) { for (int Q = 0; Q &lt; max_shell; Q++, index++) { T = 0.0; rounds = 0L; qq = new Timer(); while (T &lt; min_time) { p2c-&gt;compute_shell(P, Q + max_shell); T = qq-&gt;get(); rounds++; } delete qq; t = T / (double) (rounds * n_per_combination[this_ncenter][index]); timings[this_type][index] = t; } } </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a10438bc4af3d0303663c48f3c3cfe32a_cgraph.svg" width="502" height="168"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2aba6c665f535235a3b3377baf8fd08c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::benchmark_math </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a benchmark of common double floating point operations, including most of cmath </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_time</td><td>minimum amount of time to run each routine [s] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66862c945488d9fa731dfa4eeb10e544"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DBDSDC </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DBDSDC computes the singular value decomposition (SVD) of a real N-by-N (upper or lower) bidiagonal matrix B: B = U * S * VT, using a divide and conquer method, where S is a diagonal matrix with non-negative diagonal elements (the singular values of B), and U and VT are orthogonal matrices of left and right singular vectors, respectively. DBDSDC can be used to compute all singular values, and optionally, singular vectors or singular vectors in compact form.</p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See DLASD3 for details.</p>
<p>The code currently calls DLASDQ if singular values only are desired. However, it can be slightly modified to compute singular values using the divide and conquer method.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': B is upper bidiagonal. = 'L': B is lower bidiagonal.</p>
<p>COMPQ (input) CHARACTER*1 Specifies whether singular vectors are to be computed as follows: = 'N': Compute singular values only; = 'P': Compute singular values and compute singular vectors in compact form; = 'I': Compute singular values and singular vectors.</p>
<p>N (input) INTEGER The order of the matrix B. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the n diagonal elements of the bidiagonal matrix B. On exit, if INFO=0, the singular values of B.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, the elements of E contain the offdiagonal elements of the bidiagonal matrix whose SVD is desired. On exit, E has been destroyed.</p>
<p>U (output) DOUBLE PRECISION array, dimension (LDU,N) If COMPQ = 'I', then: On exit, if INFO = 0, U contains the left singular vectors of the bidiagonal matrix. For other values of COMPQ, U is not referenced.</p>
<p>LDU (input) INTEGER The leading dimension of the array U. LDU &gt;= 1. If singular vectors are desired, then LDU &gt;= max( 1, N ).</p>
<p>VT (output) DOUBLE PRECISION array, dimension (LDVT,N) If COMPQ = 'I', then: On exit, if INFO = 0, VT' contains the right singular vectors of the bidiagonal matrix. For other values of COMPQ, VT is not referenced.</p>
<p>LDVT (input) INTEGER The leading dimension of the array VT. LDVT &gt;= 1. If singular vectors are desired, then LDVT &gt;= max( 1, N ).</p>
<p>Q (output) DOUBLE PRECISION array, dimension (LDQ) If COMPQ = 'P', then: On exit, if INFO = 0, Q and IQ contain the left and right singular vectors in a compact form, requiring O(N log N) space instead of 2*N**2. In particular, Q contains all the DOUBLE PRECISION data in LDQ &gt;= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1)))) words of memory, where SMLSIZ is returned by ILAENV and is equal to the maximum size of the subproblems at the bottom of the computation tree (usually about 25). For other values of COMPQ, Q is not referenced.</p>
<p>IQ (output) INTEGER array, dimension (LDIQ) If COMPQ = 'P', then: On exit, if INFO = 0, Q and IQ contain the left and right singular vectors in a compact form, requiring O(N log N) space instead of 2*N**2. In particular, IQ contains all INTEGER data in LDIQ &gt;= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1)))) words of memory, where SMLSIZ is returned by ILAENV and is equal to the maximum size of the subproblems at the bottom of the computation tree (usually about 25). For other values of COMPQ, IQ is not referenced.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) If COMPQ = 'N' then LWORK &gt;= (4 * N). If COMPQ = 'P' then LWORK &gt;= (6 * N). If COMPQ = 'I' then LWORK &gt;= (3 * N**2 + 4 * N).</p>
<p>IWORK (workspace) INTEGER array, dimension (8*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: The algorithm failed to compute a singular value. The update process of divide and conquer failed.</p>
<h1>Further Details</h1>
<p>Based on contributions by Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </p>
<hr/>
<p> Changed dimension statement in comment describing E from (N) to </p>
<h1>(N-1). Sven, 17 Feb 05.</h1>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a66862c945488d9fa731dfa4eeb10e544_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5e826a4309944c7c2f2a0a54be9f266e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DBDSQR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DBDSQR computes the singular values and, optionally, the right and/or left singular vectors from the singular value decomposition (SVD) of a real N-by-N (upper or lower) bidiagonal matrix B using the implicit zero-shift <a class="el" href="classpsi_1_1QR.html">QR</a> algorithm. The SVD of B has the form</p>
<p>B = Q * S * P**T</p>
<p>where S is the diagonal matrix of singular values, Q is an orthogonal matrix of left singular vectors, and P is an orthogonal matrix of right singular vectors. If left singular vectors are requested, this subroutine actually returns U*Q instead of Q, and, if right singular vectors are requested, this subroutine returns P**T*VT instead of P**T, for given real input matrices U and VT. When U and VT are the orthogonal matrices that reduce a general matrix A to bidiagonal form: A = U*B*VT, as computed by DGEBRD, then</p>
<p>A = (U*Q) * S * (P**T*VT)</p>
<p>is the SVD of A. Optionally, the subroutine may also compute Q**T*C for a given real input matrix C.</p>
<p>See "Computing  Small Singular Values of Bidiagonal Matrices With
Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan, LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11, no. 5, pp. 873-912, Sept 1990) and "Accurate singular values and differential qd algorithms," by B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics Department, University of California at Berkeley, July 1992 for a detailed description of the algorithm.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': B is upper bidiagonal; = 'L': B is lower bidiagonal.</p>
<p>N (input) INTEGER The order of the matrix B. N &gt;= 0.</p>
<p>NCVT (input) INTEGER The number of columns of the matrix VT. NCVT &gt;= 0.</p>
<p>NRU (input) INTEGER The number of rows of the matrix U. NRU &gt;= 0.</p>
<p>NCC (input) INTEGER The number of columns of the matrix C. NCC &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the n diagonal elements of the bidiagonal matrix B. On exit, if INFO=0, the singular values of B in decreasing order.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, the N-1 offdiagonal elements of the bidiagonal matrix B. On exit, if INFO = 0, E is destroyed; if INFO &gt; 0, D and E will contain the diagonal and superdiagonal elements of a bidiagonal matrix orthogonally equivalent to the one given as input.</p>
<p>VT (input/output) DOUBLE PRECISION array, dimension (LDVT, NCVT) On entry, an N-by-NCVT matrix VT. On exit, VT is overwritten by P**T * VT. Not referenced if NCVT = 0.</p>
<p>LDVT (input) INTEGER The leading dimension of the array VT. LDVT &gt;= max(1,N) if NCVT &gt; 0; LDVT &gt;= 1 if NCVT = 0.</p>
<p>U (input/output) DOUBLE PRECISION array, dimension (LDU, N) On entry, an NRU-by-N matrix U. On exit, U is overwritten by U * Q. Not referenced if NRU = 0.</p>
<p>LDU (input) INTEGER The leading dimension of the array U. LDU &gt;= max(1,NRU).</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC, NCC) On entry, an N-by-NCC matrix C. On exit, C is overwritten by Q**T * C. Not referenced if NCC = 0.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,N) if NCC &gt; 0; LDC &gt;=1 if NCC = 0.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (4*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: If INFO = -i, the i-th argument had an illegal value &gt; 0: if NCVT = NRU = NCC = 0, = 1, a split was marked by a positive value in E = 2, current block of Z not diagonalized after 30*N iterations (in inner while loop) = 3, termination criterion of outer while loop not met (program created more than N unreduced blocks) else NCVT = NRU = NCC = 0, the algorithm did not converge; D and E contain the elements of a bidiagonal matrix which is orthogonally similar to the input matrix B; if INFO = i, i elements of E have not converged to zero.</p>
<h1>Internal Parameters</h1>
<p>TOLMUL DOUBLE PRECISION, default = max(10,min(100,EPS**(-1/8))) TOLMUL controls the convergence criterion of the <a class="el" href="classpsi_1_1QR.html">QR</a> loop. If it is positive, TOLMUL*EPS is the desired relative precision in the computed singular values. If it is negative, abs(TOLMUL*EPS*sigma_max) is the desired absolute accuracy in the computed singular values (corresponds to relative accuracy abs(TOLMUL*EPS) in the largest singular value. abs(TOLMUL) should be between 1 and 1/EPS, and preferably between 10 (for fast convergence) and .1/EPS (for there to be some accuracy in the results). Default is to lose at either one eighth or 2 of the available decimal digits in each computed singular value (whichever is smaller).</p>
<p>MAXITR INTEGER, default = 6 MAXITR controls the maximum number of passes of the algorithm through its inner loop. The algorithms stops (and so fails to converge) if the number of passes through the inner loop exceeds MAXITR*N**2. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a5e826a4309944c7c2f2a0a54be9f266e_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="af2b5dce6c9d8bb417e5c2e2b61c1c1a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DDISNA </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DDISNA computes the reciprocal condition numbers for the eigenvectors of a real symmetric or complex Hermitian matrix or for the left or right singular vectors of a general m-by-n matrix. The reciprocal condition number is the 'gap' between the corresponding eigenvalue or singular value and the nearest other one.</p>
<p>The bound on the error, measured by angle in radians, in the I-th computed vector is given by </p>
<pre class="fragment">   DLAMCH( 'E' ) * ( ANORM / SEP( I ) )
</pre><p>where ANORM = 2-norm(A) = max( abs( D(j) ) ). SEP(I) is not allowed to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of the error bound.</p>
<p>DDISNA may also be used to compute error bounds for eigenvectors of the generalized symmetric definite eigenproblem.</p>
<h1>Arguments</h1>
<p>JOB (input) CHARACTER*1 Specifies for which problem the reciprocal condition numbers should be computed: = 'E': the eigenvectors of a symmetric/Hermitian matrix; = 'L': the left singular vectors of a general matrix; = 'R': the right singular vectors of a general matrix.</p>
<p>M (input) INTEGER The number of rows of the matrix. M &gt;= 0.</p>
<p>N (input) INTEGER If JOB = 'L' or 'R', the number of columns of the matrix, in which case N &gt;= 0. Ignored if JOB = 'E'.</p>
<p>D (input) DOUBLE PRECISION array, dimension (M) if JOB = 'E' dimension (min(M,N)) if JOB = 'L' or 'R' The eigenvalues (if JOB = 'E') or singular values (if JOB = 'L' or 'R') of the matrix, in either increasing or decreasing order. If singular values, they must be non-negative.</p>
<p>SEP (output) DOUBLE PRECISION array, dimension (M) if JOB = 'E' dimension (min(M,N)) if JOB = 'L' or 'R' The reciprocal condition numbers of the vectors.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_af2b5dce6c9d8bb417e5c2e2b61c1c1a9_icgraph.svg" width="304" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="acd6ff6ab338614b293754546378e4b72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGBBRD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGBBRD reduces a real general m-by-n band matrix A to upper bidiagonal form B by an orthogonal transformation: Q' * A * P = B.</p>
<p>The routine computes B, and optionally forms Q or P', or computes Q'*C for a given matrix C.</p>
<h1>Arguments</h1>
<p>VECT (input) CHARACTER*1 Specifies whether or not the matrices Q and P' are to be formed. = 'N': do not form Q or P'; = 'Q': form Q only; = 'P': form P' only; = 'B': form both.</p>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>NCC (input) INTEGER The number of columns of the matrix C. NCC &gt;= 0.</p>
<p>KL (input) INTEGER The number of subdiagonals of the matrix A. KL &gt;= 0.</p>
<p>KU (input) INTEGER The number of superdiagonals of the matrix A. KU &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB,N) On entry, the m-by-n band matrix A, stored in rows 1 to KL+KU+1. The j-th column of A is stored in the j-th column of the array AB as follows: AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl). On exit, A is overwritten by values generated during the reduction.</p>
<p>LDAB (input) INTEGER The leading dimension of the array A. LDAB &gt;= KL+KU+1.</p>
<p>D (output) DOUBLE PRECISION array, dimension (min(M,N)) The diagonal elements of the bidiagonal matrix B.</p>
<p>E (output) DOUBLE PRECISION array, dimension (min(M,N)-1) The superdiagonal elements of the bidiagonal matrix B.</p>
<p>Q (output) DOUBLE PRECISION array, dimension (LDQ,M) If VECT = 'Q' or 'B', the m-by-m orthogonal matrix Q. If VECT = 'N' or 'P', the array Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= max(1,M) if VECT = 'Q' or 'B'; LDQ &gt;= 1 otherwise.</p>
<p>PT (output) DOUBLE PRECISION array, dimension (LDPT,N) If VECT = 'P' or 'B', the n-by-n orthogonal matrix P'. If VECT = 'N' or 'Q', the array PT is not referenced.</p>
<p>LDPT (input) INTEGER The leading dimension of the array PT. LDPT &gt;= max(1,N) if VECT = 'P' or 'B'; LDPT &gt;= 1 otherwise.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,NCC) On entry, an m-by-ncc matrix C. On exit, C is overwritten by Q'*C. C is not referenced if NCC = 0.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M) if NCC &gt; 0; LDC &gt;= 1 if NCC = 0.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (2*max(M,N))</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_acd6ff6ab338614b293754546378e4b72_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a28f5101c304b7cf551a3ad44c8330d9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGBCON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGBCON estimates the reciprocal of the condition number of a real general band matrix A, in either the 1-norm or the infinity-norm, using the LU factorization computed by DGBTRF.</p>
<p>An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).</p>
<h1>Arguments</h1>
<p>NORM (input) CHARACTER*1 Specifies whether the 1-norm condition number or the infinity-norm condition number is required: = '1' or 'O': 1-norm; = 'I': Infinity-norm.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KL (input) INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</p>
<p>KU (input) INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) Details of the LU factorization of the band matrix A, as computed by DGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</p>
<p>IPIV (input) INTEGER array, dimension (N) The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was interchanged with row IPIV(i).</p>
<p>ANORM (input) DOUBLE PRECISION If NORM = '1' or 'O', the 1-norm of the original matrix A. If NORM = 'I', the infinity-norm of the original matrix A.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(norm(A) * norm(inv(A))).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a28f5101c304b7cf551a3ad44c8330d9e_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0f312a622525a4eaea0609776481f27e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGBEQU </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rowcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>colcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>amax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGBEQU computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its condition number. R returns the row scale factors and C the column scale factors, chosen to try to make the largest element in each row and column of the matrix B with elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.</p>
<p>R(i) and C(j) are restricted to be between SMLNUM = smallest safe number and BIGNUM = largest safe number. Use of these scaling factors is not guaranteed to reduce the condition number of A but works well in practice.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>KL (input) INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</p>
<p>KU (input) INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) The band matrix A, stored in rows 1 to KL+KU+1. The j-th column of A is stored in the j-th column of the array AB as follows: AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl).</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KL+KU+1.</p>
<p>R (output) DOUBLE PRECISION array, dimension (M) If INFO = 0, or INFO &gt; M, R contains the row scale factors for A.</p>
<p>C (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, C contains the column scale factors for A.</p>
<p>ROWCND (output) DOUBLE PRECISION If INFO = 0 or INFO &gt; M, ROWCND contains the ratio of the smallest R(i) to the largest R(i). If ROWCND &gt;= 0.1 and AMAX is neither too large nor too small, it is not worth scaling by R.</p>
<p>COLCND (output) DOUBLE PRECISION If INFO = 0, COLCND contains the ratio of the smallest C(i) to the largest C(i). If COLCND &gt;= 0.1, it is not worth scaling by C.</p>
<p>AMAX (output) DOUBLE PRECISION Absolute value of largest matrix element. If AMAX is very close to overflow or very close to underflow, the matrix should be scaled.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= M: the i-th row of A is exactly zero &gt; M: the (i-M)-th column of A is exactly zero </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a0f312a622525a4eaea0609776481f27e_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="adf72d8f7785638e11663c452949cd837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DGBMV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGBMV performs one of the matrix-vector operations</p>
<p>y := alpha*A*x + beta*y, or y := alpha*A'*x + beta*y,</p>
<p>where alpha and beta are scalars, x and y are vectors and A is an m by n band matrix, with kl sub-diagonals and ku super-diagonals.</p>
<h1>Arguments</h1>
<p>TRANS - CHARACTER*1. On entry, TRANS specifies the operation to be performed as follows:</p>
<p>TRANS = 'N' or 'n' y := alpha*A*x + beta*y.</p>
<p>TRANS = 'T' or 't' y := alpha*A'*x + beta*y.</p>
<p>TRANS = 'C' or 'c' y := alpha*A'*x + beta*y.</p>
<p>Unchanged on exit.</p>
<p>M - INTEGER. On entry, M specifies the number of rows of the matrix A. M must be at least zero. Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the number of columns of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>KL - INTEGER. On entry, KL specifies the number of sub-diagonals of the matrix A. KL must satisfy 0 .le. KL. Unchanged on exit.</p>
<p>KU - INTEGER. On entry, KU specifies the number of super-diagonals of the matrix A. KU must satisfy 0 .le. KU. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry, the leading ( kl + ku + 1 ) by n part of the array A must contain the matrix of coefficients, supplied column by column, with the leading diagonal of the matrix in row ( ku + 1 ) of the array, the first super-diagonal starting at position 2 in row ku, the first sub-diagonal starting at position 1 in row ( ku + 2 ), and so on. Elements in the array A that do not correspond to elements in the band matrix (such as the top left ku by ku triangle) are not referenced. The following program segment will transfer a band matrix from conventional full matrix storage to band storage: </p>
<pre class="fragment">  DO 20, J = 1, N
     K = KU + 1 - J
     DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
        A( K + I, J ) = matrix( I, J )
</pre><p> 10 CONTINUE 20 CONTINUE</p>
<p>Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least ( kl + ku + 1 ). Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of DIMENSION at least ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' and at least ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. Before entry, the incremented array X must contain the vector x. Unchanged on exit.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>BETA - DOUBLE PRECISION. On entry, BETA specifies the scalar beta. When BETA is supplied as zero then Y need not be set on input. Unchanged on exit.</p>
<p>Y - DOUBLE PRECISION array of DIMENSION at least ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' and at least ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. Before entry, the incremented array Y must contain the vector y. On exit, Y is overwritten by the updated vector y.</p>
<p>INCY - INTEGER. On entry, INCY specifies the increment for the elements of Y. INCY must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_adf72d8f7785638e11663c452949cd837_icgraph.svg" width="299" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a82b509a7495f0d4bc6158441d1115372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGBRFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>afb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldafb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGBRFS improves the computed solution to a system of linear equations when the coefficient matrix is banded, and provides error bounds and backward error estimates for the solution.</p>
<h1>Arguments</h1>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Conjugate transpose = Transpose)</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KL (input) INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</p>
<p>KU (input) INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) The original band matrix A, stored in rows 1 to KL+KU+1. The j-th column of A is stored in the j-th column of the array AB as follows: AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(n,j+kl).</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KL+KU+1.</p>
<p>AFB (input) DOUBLE PRECISION array, dimension (LDAFB,N) Details of the LU factorization of the band matrix A, as computed by DGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</p>
<p>LDAFB (input) INTEGER The leading dimension of the array AFB. LDAFB &gt;= 2*KL*KU+1.</p>
<p>IPIV (input) INTEGER array, dimension (N) The pivot indices from DGBTRF; for 1&lt;=i&lt;=N, row i of the matrix was interchanged with row IPIV(i).</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS) On entry, the solution matrix X, as computed by DGBTRS. On exit, the improved solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Internal Parameters</h1>
<p>ITMAX is the maximum number of steps of iterative refinement. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a82b509a7495f0d4bc6158441d1115372_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a88a8df061a0b1a33450d0a9c19447e6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGBSV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGBSV computes the solution to a real system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.</p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>KL (input) INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</p>
<p>KU (input) INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB,N) On entry, the matrix A in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)&lt;=i&lt;=min(N,j+KL) On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</p>
<p>IPIV (output) INTEGER array, dimension (N) The pivot indices that define the permutation matrix P; row i of the matrix was interchanged with row IPIV(i).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if INFO = 0, the N-by-NRHS solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and the solution has not been computed.</p>
<h1>Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p>
<pre class="fragment">*    *    *    +    +    +       *    *    *   u14  u25  u36
*    *    +    +    +    +       *    *   u13  u24  u35  u46
*   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p>
<ul>
<li><p class="startli">need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </p>
<hr/>
<p class="startli">.. External Subroutines .. </p>
</li>
</ul>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a88a8df061a0b1a33450d0a9c19447e6e_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a63385e7d7c88932ef51cde58a8cb0974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGBSVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>afb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldafb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGBSVX uses the LU factorization to compute the solution to a real system of linear equations A * X = B, A**T * X = B, or A**H * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.</p>
<p>Error bounds on the solution and a condition estimate are also provided.</p>
<h1>Description</h1>
<p>The following steps are performed by this subroutine:</p>
<ol type="1">
<li>If FACT = 'E', real scaling factors are computed to equilibrate the system: TRANS = 'N': diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B Whether or not the system will be equilibrated depends on the scaling of the matrix A, but if equilibration is used, A is overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N') or diag(C)*B (if TRANS = 'T' or 'C').</li>
</ol>
<ol type="1">
<li>If FACT = 'N' or 'E', the LU decomposition is used to factor the matrix A (after equilibration if FACT = 'E') as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals.</li>
</ol>
<ol type="1">
<li>If some U(i,i)=0, so that U is exactly singular, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A. If the reciprocal of the condition number is less than machine precision, C++ Return value: INFO (output) INTEGER to solve for X and compute error bounds as described below.</li>
</ol>
<ol type="1">
<li>The system of equations is solved for X using the factored form of A.</li>
</ol>
<ol type="1">
<li>Iterative refinement is applied to improve the computed solution matrix and calculate error bounds and backward error estimates for it.</li>
</ol>
<ol type="1">
<li>If equilibration was used, the matrix X is premultiplied by diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so that it solves the original system before equilibration.</li>
</ol>
<h1>Arguments</h1>
<p>FACT (input) CHARACTER*1 Specifies whether or not the factored form of the matrix A is supplied on entry, and if not, whether the matrix A should be equilibrated before it is factored. = 'F': On entry, AFB and IPIV contain the factored form of A. If EQUED is not 'N', the matrix A has been equilibrated with scaling factors given by R and C. AB, AFB, and IPIV are not modified. = 'N': The matrix A will be copied to AFB and factored. = 'E': The matrix A will be equilibrated if necessary, then copied to AFB and factored.</p>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations. = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Transpose)</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>KL (input) INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</p>
<p>KU (input) INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB,N) On entry, the matrix A in band storage, in rows 1 to KL+KU+1. The j-th column of A is stored in the j-th column of the array AB as follows: AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)&lt;=i&lt;=min(N,j+kl)</p>
<p>If FACT = 'F' and EQUED is not 'N', then A must have been equilibrated by the scaling factors in R and/or C. AB is not modified if FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.</p>
<p>On exit, if EQUED .ne. 'N', A is scaled as follows: EQUED = 'R': A := diag(R) * A EQUED = 'C': A := A * diag(C) EQUED = 'B': A := diag(R) * A * diag(C).</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KL+KU+1.</p>
<p>AFB (input or output) DOUBLE PRECISION array, dimension (LDAFB,N) If FACT = 'F', then AFB is an input argument and on entry contains details of the LU factorization of the band matrix A, as computed by DGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. If EQUED .ne. 'N', then AFB is the factored form of the equilibrated matrix A.</p>
<p>If FACT = 'N', then AFB is an output argument and on exit returns details of the LU factorization of A.</p>
<p>If FACT = 'E', then AFB is an output argument and on exit returns details of the LU factorization of the equilibrated matrix A (see the description of AB for the form of the equilibrated matrix).</p>
<p>LDAFB (input) INTEGER The leading dimension of the array AFB. LDAFB &gt;= 2*KL+KU+1.</p>
<p>IPIV (input or output) INTEGER array, dimension (N) If FACT = 'F', then IPIV is an input argument and on entry contains the pivot indices from the factorization A = L*U as computed by DGBTRF; row i of the matrix was interchanged with row IPIV(i).</p>
<p>If FACT = 'N', then IPIV is an output argument and on exit contains the pivot indices from the factorization A = L*U of the original matrix A.</p>
<p>If FACT = 'E', then IPIV is an output argument and on exit contains the pivot indices from the factorization A = L*U of the equilibrated matrix A.</p>
<p>EQUED (input or output) CHARACTER*1 Specifies the form of equilibration that was done. = 'N': No equilibration (always true if FACT = 'N'). = 'R': Row equilibration, i.e., A has been premultiplied by diag(R). = 'C': Column equilibration, i.e., A has been postmultiplied by diag(C). = 'B': Both row and column equilibration, i.e., A has been replaced by diag(R) * A * diag(C). EQUED is an input argument if FACT = 'F'; otherwise, it is an output argument.</p>
<p>R (input or output) DOUBLE PRECISION array, dimension (N) The row scale factors for A. If EQUED = 'R' or 'B', A is multiplied on the left by diag(R); if EQUED = 'N' or 'C', R is not accessed. R is an input argument if FACT = 'F'; otherwise, R is an output argument. If FACT = 'F' and EQUED = 'R' or 'B', each element of R must be positive.</p>
<p>C (input or output) DOUBLE PRECISION array, dimension (N) The column scale factors for A. If EQUED = 'C' or 'B', A is multiplied on the right by diag(C); if EQUED = 'N' or 'R', C is not accessed. C is an input argument if FACT = 'F'; otherwise, C is an output argument. If FACT = 'F' and EQUED = 'C' or 'B', each element of C must be positive.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, if EQUED = 'N', B is not modified; if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by diag(R)*B; if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is overwritten by diag(C)*B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,NRHS) If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to the original system of equations. Note that A and B are modified on exit if EQUED .ne. 'N', and the solution to the equilibrated system is inv(diag(C))*X if TRANS = 'N' and EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C' and EQUED = 'R' or 'B'.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>RCOND (output) DOUBLE PRECISION The estimate of the reciprocal condition number of the matrix A after equilibration (if done). If RCOND is less than the machine precision (in particular, if RCOND = 0), the matrix is singular to working precision. This condition is indicated by a return code of INFO &gt; 0.</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (3*N) On exit, WORK(1) contains the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If WORK(1) is much less than 1, then the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, condition estimator RCOND, and forward error bound FERR could be unreliable. If factorization fails with 0&lt;INFO&lt;=N, then WORK(1) contains the reciprocal pivot growth factor for the leading INFO columns of A.</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= N: U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution and error bounds could not be computed. RCOND = 0 is returned. = N+1: U is nonsingular, but RCOND is less than machine precision, meaning that the matrix is singular to working precision. Nevertheless, the solution and error bounds are computed because there are a number of situations where the computed solution can be more accurate than the value of RCOND would suggest. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a63385e7d7c88932ef51cde58a8cb0974_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a10ca3f546fc02acf6d7e20dc7c5aaf22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGBTRF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGBTRF computes an LU factorization of a real m-by-n band matrix A using partial pivoting with row interchanges.</p>
<p>This is the blocked version of the algorithm, calling Level 3 BLAS.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>KL (input) INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</p>
<p>KU (input) INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB,N) On entry, the matrix A in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</p>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</p>
<p>IPIV (output) INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</p>
<h1>Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p>
<pre class="fragment">*    *    *    +    +    +       *    *    *   u14  u25  u36
*    *    +    +    +    +       *    *   u13  u24  u35  u46
*   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p>
<ul>
<li><p class="startli">need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </p>
<hr/>
<p class="startli">.. Parameters .. </p>
</li>
</ul>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a10ca3f546fc02acf6d7e20dc7c5aaf22_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a58f51c1820e98cd0e24aa3a96c2ab8e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGBTRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGBTRS solves a system of linear equations A * X = B or A' * X = B with a general band matrix A using the LU factorization computed by DGBTRF.</p>
<h1>Arguments</h1>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations. = 'N': A * X = B (No transpose) = 'T': A'* X = B (Transpose) = 'C': A'* X = B (Conjugate transpose = Transpose)</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KL (input) INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</p>
<p>KU (input) INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) Details of the LU factorization of the band matrix A, as computed by DGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</p>
<p>IPIV (input) INTEGER array, dimension (N) The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was interchanged with row IPIV(i).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a58f51c1820e98cd0e24aa3a96c2ab8e6_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3dfd16c6bbc8316035d220196e5e0c00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEBAK </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEBAK forms the right or left eigenvectors of a real general matrix by backward transformation on the computed eigenvectors of the balanced matrix output by DGEBAL.</p>
<h1>Arguments</h1>
<p>JOB (input) CHARACTER*1 Specifies the type of backward transformation required: = 'N', do nothing, return immediately; = 'P', do backward transformation for permutation only; = 'S', do backward transformation for scaling only; = 'B', do backward transformations for both permutation and scaling. JOB must be the same as the argument JOB supplied to DGEBAL.</p>
<p>SIDE (input) CHARACTER*1 = 'R': V contains right eigenvectors; = 'L': V contains left eigenvectors.</p>
<p>N (input) INTEGER The number of rows of the matrix V. N &gt;= 0.</p>
<p>ILO (input) INTEGER IHI (input) INTEGER The integers ILO and IHI determined by DGEBAL. 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.</p>
<p>SCALE (input) DOUBLE PRECISION array, dimension (N) Details of the permutation and scaling factors, as returned by DGEBAL.</p>
<p>M (input) INTEGER The number of columns of the matrix V. M &gt;= 0.</p>
<p>V (input/output) DOUBLE PRECISION array, dimension (LDV,M) On entry, the matrix of right or left eigenvectors to be transformed, as returned by DHSEIN or DTREVC. On exit, V is overwritten by the transformed eigenvectors.</p>
<p>LDV (input) INTEGER The leading dimension of the array V. LDV &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a3dfd16c6bbc8316035d220196e5e0c00_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab2f8a4e849d16f43e4826f8735208cc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEBAL </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEBAL balances a general real matrix A. This involves, first, permuting A by a similarity transformation to isolate eigenvalues in the first 1 to ILO-1 and last IHI+1 to N elements on the diagonal; and second, applying a diagonal similarity transformation to rows and columns ILO to IHI to make the rows and columns as close in norm as possible. Both steps are optional.</p>
<p>Balancing may reduce the 1-norm of the matrix, and improve the accuracy of the computed eigenvalues and/or eigenvectors.</p>
<h1>Arguments</h1>
<p>JOB (input) CHARACTER*1 Specifies the operations to be performed on A: = 'N': none: simply set ILO = 1, IHI = N, SCALE(I) = 1.0 for i = 1,...,N; = 'P': permute only; = 'S': scale only; = 'B': both permute and scale.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the input matrix A. On exit, A is overwritten by the balanced matrix. If JOB = 'N', A is not referenced. See Further Details.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>ILO (output) INTEGER IHI (output) INTEGER ILO and IHI are set to integers such that on exit A(i,j) = 0 if i &gt; j and j = 1,...,ILO-1 or I = IHI+1,...,N. If JOB = 'N' or 'S', ILO = 1 and IHI = N.</p>
<p>SCALE (output) DOUBLE PRECISION array, dimension (N) Details of the permutations and scaling factors applied to A. If P(j) is the index of the row and column interchanged with row and column j and D(j) is the scaling factor applied to row and column j, then SCALE(j) = P(j) for j = 1,...,ILO-1 = D(j) for j = ILO,...,IHI = P(j) for j = IHI+1,...,N. The order in which the interchanges are made is N to IHI+1, then 1 to ILO-1.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>The permutations consist of row and column interchanges which put the matrix in the form </p>
<pre class="fragment">       ( T1   X   Y  )
</pre><p> P A P = ( 0 B Z ) ( 0 0 T2 )</p>
<p>where T1 and T2 are upper triangular matrices whose eigenvalues lie along the diagonal. The column indices ILO and IHI mark the starting and ending columns of the submatrix B. Balancing consists of applying a diagonal similarity transformation inv(D) * B * D to make the 1-norms of each row of B and its corresponding column nearly equal. The output matrix is</p>
<p>( T1 X*D Y ) ( 0 inv(D)*B*D inv(D)*Z ). ( 0 0 T2 )</p>
<p>Information about the permutations P and the diagonal matrix D is returned in the vector SCALE.</p>
<p>This subroutine is based on the EISPACK routine BALANC.</p>
<p>Modified by Tzu-Yi Chen, Computer Science Division, University of California at Berkeley, USA </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ab2f8a4e849d16f43e4826f8735208cc9_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a85dc60774827c9e2241ce9f78e7c6dc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEBRD </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tauq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>taup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEBRD reduces a general real M-by-N matrix A to upper or lower bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.</p>
<p>If m &gt;= n, B is upper bidiagonal; if m &lt; n, B is lower bidiagonal.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows in the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns in the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N general matrix to be reduced. On exit, if m &gt;= n, the diagonal and the first superdiagonal are overwritten with the upper bidiagonal matrix B; the elements below the diagonal, with the array TAUQ, represent the orthogonal matrix Q as a product of elementary reflectors, and the elements above the first superdiagonal, with the array TAUP, represent the orthogonal matrix P as a product of elementary reflectors; if m &lt; n, the diagonal and the first subdiagonal are overwritten with the lower bidiagonal matrix B; the elements below the first subdiagonal, with the array TAUQ, represent the orthogonal matrix Q as a product of elementary reflectors, and the elements above the diagonal, with the array TAUP, represent the orthogonal matrix P as a product of elementary reflectors. See Further Details.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>D (output) DOUBLE PRECISION array, dimension (min(M,N)) The diagonal elements of the bidiagonal matrix B: D(i) = A(i,i).</p>
<p>E (output) DOUBLE PRECISION array, dimension (min(M,N)-1) The off-diagonal elements of the bidiagonal matrix B: if m &gt;= n, E(i) = A(i,i+1) for i = 1,2,...,n-1; if m &lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.</p>
<p>TAUQ (output) DOUBLE PRECISION array dimension (min(M,N)) The scalar factors of the elementary reflectors which represent the orthogonal matrix Q. See Further Details.</p>
<p>TAUP (output) DOUBLE PRECISION array, dimension (min(M,N)) The scalar factors of the elementary reflectors which represent the orthogonal matrix P. See Further Details.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The length of the array WORK. LWORK &gt;= max(1,M,N). For optimum performance LWORK &gt;= (M+N)*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>The matrices Q and P are represented as products of elementary reflectors:</p>
<p>If m &gt;= n,</p>
<p>Q = H(1) H(2) . . . H(n) and P = G(1) G(2) . . . G(n-1)</p>
<p>Each H(i) and G(i) has the form:</p>
<p>H(i) = I - tauq * v * v' and G(i) = I - taup * u * u'</p>
<p>where tauq and taup are real scalars, and v and u are real vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).</p>
<p>If m &lt; n,</p>
<p>Q = H(1) H(2) . . . H(m-1) and P = G(1) G(2) . . . G(m)</p>
<p>Each H(i) and G(i) has the form:</p>
<p>H(i) = I - tauq * v * v' and G(i) = I - taup * u * u'</p>
<p>where tauq and taup are real scalars, and v and u are real vectors; v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).</p>
<p>The contents of A on exit are illustrated by the following examples:</p>
<p>m = 6 and n = 5 (m &gt; n): m = 5 and n = 6 (m &lt; n):</p>
<p>( d e u1 u1 u1 ) ( d u1 u1 u1 u1 u1 ) ( v1 d e u2 u2 ) ( e d u2 u2 u2 u2 ) ( v1 v2 d e u3 ) ( v1 e d u3 u3 u3 ) ( v1 v2 v3 d e ) ( v1 v2 e d u4 u4 ) ( v1 v2 v3 v4 d ) ( v1 v2 v3 e d u5 ) ( v1 v2 v3 v4 v5 )</p>
<p>where d and e denote diagonal and off-diagonal elements of B, vi denotes an element of the vector defining H(i), and ui an element of the vector defining G(i). </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a85dc60774827c9e2241ce9f78e7c6dc1_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a104f1e5d60b16a9556508a96b9191fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGECON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGECON estimates the reciprocal of the condition number of a general real matrix A, in either the 1-norm or the infinity-norm, using the LU factorization computed by DGETRF.</p>
<p>An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).</p>
<h1>Arguments</h1>
<p>NORM (input) CHARACTER*1 Specifies whether the 1-norm condition number or the infinity-norm condition number is required: = '1' or 'O': 1-norm; = 'I': Infinity-norm.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The factors L and U from the factorization A = P*L*U as computed by DGETRF.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>ANORM (input) DOUBLE PRECISION If NORM = '1' or 'O', the 1-norm of the original matrix A. If NORM = 'I', the infinity-norm of the original matrix A.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(norm(A) * norm(inv(A))).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (4*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a104f1e5d60b16a9556508a96b9191fd4_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a710b863e6df45494ceff011da30c4341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEEQU </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rowcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>colcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>amax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEEQU computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its condition number. R returns the row scale factors and C the column scale factors, chosen to try to make the largest element in each row and column of the matrix B with elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.</p>
<p>R(i) and C(j) are restricted to be between SMLNUM = smallest safe number and BIGNUM = largest safe number. Use of these scaling factors is not guaranteed to reduce the condition number of A but works well in practice.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The M-by-N matrix whose equilibration factors are to be computed.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>R (output) DOUBLE PRECISION array, dimension (M) If INFO = 0 or INFO &gt; M, R contains the row scale factors for A.</p>
<p>C (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, C contains the column scale factors for A.</p>
<p>ROWCND (output) DOUBLE PRECISION If INFO = 0 or INFO &gt; M, ROWCND contains the ratio of the smallest R(i) to the largest R(i). If ROWCND &gt;= 0.1 and AMAX is neither too large nor too small, it is not worth scaling by R.</p>
<p>COLCND (output) DOUBLE PRECISION If INFO = 0, COLCND contains the ratio of the smallest C(i) to the largest C(i). If COLCND &gt;= 0.1, it is not worth scaling by C.</p>
<p>AMAX (output) DOUBLE PRECISION Absolute value of largest matrix element. If AMAX is very close to overflow or very close to underflow, the matrix should be scaled.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= M: the i-th row of A is exactly zero &gt; M: the (i-M)-th column of A is exactly zero </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a710b863e6df45494ceff011da30c4341_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="af386bbdadc1fe835e09e097c4b29342d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEES </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEES computes for an N-by-N real nonsymmetric matrix A, the eigenvalues, the real Schur form T, and, optionally, the matrix of Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).</p>
<p>Optionally, it also orders the eigenvalues on the diagonal of the real Schur form so that selected eigenvalues are at the top left. The leading columns of Z then form an orthonormal basis for the invariant subspace corresponding to the selected eigenvalues.</p>
<p>A matrix is in real Schur form if it is upper quasi-triangular with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the form [ a b ] [ c a ]</p>
<p>where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).</p>
<h1>Arguments</h1>
<p>JOBVS (input) CHARACTER*1 = 'N': Schur vectors are not computed; = 'V': Schur vectors are computed.</p>
<p>SORT (input) CHARACTER*1 Specifies whether or not to order the eigenvalues on the diagonal of the Schur form. = 'N': Eigenvalues are not ordered; = 'S': Eigenvalues are ordered (see SELECT).</p>
<p>SELECT (external procedure) LOGICAL FUNCTION of two DOUBLE PRECISION arguments SELECT must be declared EXTERNAL in the calling subroutine. If SORT = 'S', SELECT is used to select eigenvalues to sort to the top left of the Schur form. If SORT = 'N', SELECT is not referenced. An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex conjugate pair of eigenvalues is selected, then both complex eigenvalues are selected. Note that a selected complex eigenvalue may no longer satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since ordering may change the value of complex eigenvalues (especially if the eigenvalue is ill-conditioned); in this case INFO is set to N+2 (see INFO below).</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the N-by-N matrix A. On exit, A has been overwritten by its real Schur form T.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>SDIM (output) INTEGER If SORT = 'N', SDIM = 0. If SORT = 'S', SDIM = number of eigenvalues (after sorting) for which SELECT is true. (Complex conjugate pairs for which SELECT is true for either eigenvalue count as 2.)</p>
<p>WR (output) DOUBLE PRECISION array, dimension (N) WI (output) DOUBLE PRECISION array, dimension (N) WR and WI contain the real and imaginary parts, respectively, of the computed eigenvalues in the same order that they appear on the diagonal of the output Schur form T. Complex conjugate pairs of eigenvalues will appear consecutively with the eigenvalue having the positive imaginary part first.</p>
<p>VS (output) DOUBLE PRECISION array, dimension (LDVS,N) If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur vectors. If JOBVS = 'N', VS is not referenced.</p>
<p>LDVS (input) INTEGER The leading dimension of the array VS. LDVS &gt;= 1; if JOBVS = 'V', LDVS &gt;= N.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) contains the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,3*N). For good performance, LWORK must generally be larger.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>BWORK (workspace) LOGICAL array, dimension (N) Not referenced if SORT = 'N'.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if INFO = i, and i is &lt;= N: the <a class="el" href="classpsi_1_1QR.html">QR</a> algorithm failed to compute all the eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI contain those eigenvalues which have converged; if JOBVS = 'V', VS contains the matrix which reduces A to its partially converged Schur form. = N+1: the eigenvalues could not be reordered because some eigenvalues were too close to separate (the problem is very ill-conditioned); = N+2: after reordering, roundoff changed values of some complex eigenvalues so that leading eigenvalues in the Schur form no longer satisfy SELECT=.TRUE. This could also be caused by underflow due to scaling. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_af386bbdadc1fe835e09e097c4b29342d_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a12683d5082ac02ad9aaf5fec8b74b38a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEESX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rconde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcondv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEESX computes for an N-by-N real nonsymmetric matrix A, the eigenvalues, the real Schur form T, and, optionally, the matrix of Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).</p>
<p>Optionally, it also orders the eigenvalues on the diagonal of the real Schur form so that selected eigenvalues are at the top left; computes a reciprocal condition number for the average of the selected eigenvalues (RCONDE); and computes a reciprocal condition number for the right invariant subspace corresponding to the selected eigenvalues (RCONDV). The leading columns of Z form an orthonormal basis for this invariant subspace.</p>
<p>For further explanation of the reciprocal condition numbers RCONDE and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where these quantities are called s and sep respectively).</p>
<p>A real matrix is in real Schur form if it is upper quasi-triangular with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the form [ a b ] [ c a ]</p>
<p>where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).</p>
<h1>Arguments</h1>
<p>JOBVS (input) CHARACTER*1 = 'N': Schur vectors are not computed; = 'V': Schur vectors are computed.</p>
<p>SORT (input) CHARACTER*1 Specifies whether or not to order the eigenvalues on the diagonal of the Schur form. = 'N': Eigenvalues are not ordered; = 'S': Eigenvalues are ordered (see SELECT).</p>
<p>SELECT (external procedure) LOGICAL FUNCTION of two DOUBLE PRECISION arguments SELECT must be declared EXTERNAL in the calling subroutine. If SORT = 'S', SELECT is used to select eigenvalues to sort to the top left of the Schur form. If SORT = 'N', SELECT is not referenced. An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex conjugate pair of eigenvalues is selected, then both are. Note that a selected complex eigenvalue may no longer satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since ordering may change the value of complex eigenvalues (especially if the eigenvalue is ill-conditioned); in this case INFO may be set to N+3 (see INFO below).</p>
<p>SENSE (input) CHARACTER*1 Determines which reciprocal condition numbers are computed. = 'N': None are computed; = 'E': Computed for average of selected eigenvalues only; = 'V': Computed for selected right invariant subspace only; = 'B': Computed for both. If SENSE = 'E', 'V' or 'B', SORT must equal 'S'.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the N-by-N matrix A. On exit, A is overwritten by its real Schur form T.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>SDIM (output) INTEGER If SORT = 'N', SDIM = 0. If SORT = 'S', SDIM = number of eigenvalues (after sorting) for which SELECT is true. (Complex conjugate pairs for which SELECT is true for either eigenvalue count as 2.)</p>
<p>WR (output) DOUBLE PRECISION array, dimension (N) WI (output) DOUBLE PRECISION array, dimension (N) WR and WI contain the real and imaginary parts, respectively, of the computed eigenvalues, in the same order that they appear on the diagonal of the output Schur form T. Complex conjugate pairs of eigenvalues appear consecutively with the eigenvalue having the positive imaginary part first.</p>
<p>VS (output) DOUBLE PRECISION array, dimension (LDVS,N) If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur vectors. If JOBVS = 'N', VS is not referenced.</p>
<p>LDVS (input) INTEGER The leading dimension of the array VS. LDVS &gt;= 1, and if JOBVS = 'V', LDVS &gt;= N.</p>
<p>RCONDE (output) DOUBLE PRECISION If SENSE = 'E' or 'B', RCONDE contains the reciprocal condition number for the average of the selected eigenvalues. Not referenced if SENSE = 'N' or 'V'.</p>
<p>RCONDV (output) DOUBLE PRECISION If SENSE = 'V' or 'B', RCONDV contains the reciprocal condition number for the selected right invariant subspace. Not referenced if SENSE = 'N' or 'E'.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,3*N). Also, if SENSE = 'E' or 'V' or 'B', LWORK &gt;= N+2*SDIM*(N-SDIM), where SDIM is the number of selected eigenvalues computed by this routine. Note that N+2*SDIM*(N-SDIM) &lt;= N+N*N/2. Note also that an error is only returned if LWORK &lt; max(1,3*N), but if SENSE = 'E' or 'V' or 'B' this may not be large enough. For good performance, LWORK must generally be larger.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates upper bounds on the optimal sizes of the arrays WORK and IWORK, returns these values as the first entries of the WORK and IWORK arrays, and no error messages related to LWORK or LIWORK are issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. LIWORK &gt;= 1; if SENSE = 'V' or 'B', LIWORK &gt;= SDIM*(N-SDIM). Note that SDIM*(N-SDIM) &lt;= N*N/4. Note also that an error is only returned if LIWORK &lt; 1, but if SENSE = 'V' or 'B' this may not be large enough.</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates upper bounds on the optimal sizes of the arrays WORK and IWORK, returns these values as the first entries of the WORK and IWORK arrays, and no error messages related to LWORK or LIWORK are issued by XERBLA.</p>
<p>BWORK (workspace) LOGICAL array, dimension (N) Not referenced if SORT = 'N'.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if INFO = i, and i is &lt;= N: the <a class="el" href="classpsi_1_1QR.html">QR</a> algorithm failed to compute all the eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI contain those eigenvalues which have converged; if JOBVS = 'V', VS contains the transformation which reduces A to its partially converged Schur form. = N+1: the eigenvalues could not be reordered because some eigenvalues were too close to separate (the problem is very ill-conditioned); = N+2: after reordering, roundoff changed values of some complex eigenvalues so that leading eigenvalues in the Schur form no longer satisfy SELECT=.TRUE. This could also be caused by underflow due to scaling. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a12683d5082ac02ad9aaf5fec8b74b38a_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab8816e166e757946ffc3ffda87ce7dc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEEV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEEV computes for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors.</p>
<p>The right eigenvector v(j) of A satisfies A * v(j) = lambda(j) * v(j) where lambda(j) is its eigenvalue. The left eigenvector u(j) of A satisfies u(j)**H * A = lambda(j) * u(j)**H where u(j)**H denotes the conjugate transpose of u(j).</p>
<p>The computed eigenvectors are normalized to have Euclidean norm equal to 1 and largest component real.</p>
<h1>Arguments</h1>
<p>JOBVL (input) CHARACTER*1 = 'N': left eigenvectors of A are not computed; = 'V': left eigenvectors of A are computed.</p>
<p>JOBVR (input) CHARACTER*1 = 'N': right eigenvectors of A are not computed; = 'V': right eigenvectors of A are computed.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the N-by-N matrix A. On exit, A has been overwritten.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>WR (output) DOUBLE PRECISION array, dimension (N) WI (output) DOUBLE PRECISION array, dimension (N) WR and WI contain the real and imaginary parts, respectively, of the computed eigenvalues. Complex conjugate pairs of eigenvalues appear consecutively with the eigenvalue having the positive imaginary part first.</p>
<p>VL (output) DOUBLE PRECISION array, dimension (LDVL,N) If JOBVL = 'V', the left eigenvectors u(j) are stored one after another in the columns of VL, in the same order as their eigenvalues. If JOBVL = 'N', VL is not referenced. If the j-th eigenvalue is real, then u(j) = VL(:,j), the j-th column of VL. If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and u(j+1) = VL(:,j) - i*VL(:,j+1).</p>
<p>LDVL (input) INTEGER The leading dimension of the array VL. LDVL &gt;= 1; if JOBVL = 'V', LDVL &gt;= N.</p>
<p>VR (output) DOUBLE PRECISION array, dimension (LDVR,N) If JOBVR = 'V', the right eigenvectors v(j) are stored one after another in the columns of VR, in the same order as their eigenvalues. If JOBVR = 'N', VR is not referenced. If the j-th eigenvalue is real, then v(j) = VR(:,j), the j-th column of VR. If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and v(j+1) = VR(:,j) - i*VR(:,j+1).</p>
<p>LDVR (input) INTEGER The leading dimension of the array VR. LDVR &gt;= 1; if JOBVR = 'V', LDVR &gt;= N.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,3*N), and if JOBVL = 'V' or JOBVR = 'V', LWORK &gt;= 4*N. For good performance, LWORK must generally be larger.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if INFO = i, the <a class="el" href="classpsi_1_1QR.html">QR</a> algorithm failed to compute all the eigenvalues, and no eigenvectors have been computed; elements i+1:N of WR and WI contain eigenvalues which have converged. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ab8816e166e757946ffc3ffda87ce7dc7_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1d2e64034cadb451e6eb150f7bf3a9bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEEVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>balanc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>abnrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rconde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcondv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEEVX computes for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors.</p>
<p>Optionally also, it computes a balancing transformation to improve the conditioning of the eigenvalues and eigenvectors (ILO, IHI, SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues (RCONDE), and reciprocal condition numbers for the right eigenvectors (RCONDV).</p>
<p>The right eigenvector v(j) of A satisfies A * v(j) = lambda(j) * v(j) where lambda(j) is its eigenvalue. The left eigenvector u(j) of A satisfies u(j)**H * A = lambda(j) * u(j)**H where u(j)**H denotes the conjugate transpose of u(j).</p>
<p>The computed eigenvectors are normalized to have Euclidean norm equal to 1 and largest component real.</p>
<p>Balancing a matrix means permuting the rows and columns to make it more nearly upper triangular, and applying a diagonal similarity transformation D * A * D**(-1), where D is a diagonal matrix, to make its rows and columns closer in norm and the condition numbers of its eigenvalues and eigenvectors smaller. The computed reciprocal condition numbers correspond to the balanced matrix. Permuting rows and columns will not change the condition numbers (in exact arithmetic) but diagonal scaling will. For further explanation of balancing, see section 4.10.2 of the LAPACK Users' Guide.</p>
<h1>Arguments</h1>
<p>BALANC (input) CHARACTER*1 Indicates how the input matrix should be diagonally scaled and/or permuted to improve the conditioning of its eigenvalues. = 'N': Do not diagonally scale or permute; = 'P': Perform permutations to make the matrix more nearly upper triangular. Do not diagonally scale; = 'S': Diagonally scale the matrix, i.e. replace A by D*A*D**(-1), where D is a diagonal matrix chosen to make the rows and columns of A more equal in norm. Do not permute; = 'B': Both diagonally scale and permute A.</p>
<p>Computed reciprocal condition numbers will be for the matrix after balancing and/or permuting. Permuting does not change condition numbers (in exact arithmetic), but balancing does.</p>
<p>JOBVL (input) CHARACTER*1 = 'N': left eigenvectors of A are not computed; = 'V': left eigenvectors of A are computed. If SENSE = 'E' or 'B', JOBVL must = 'V'.</p>
<p>JOBVR (input) CHARACTER*1 = 'N': right eigenvectors of A are not computed; = 'V': right eigenvectors of A are computed. If SENSE = 'E' or 'B', JOBVR must = 'V'.</p>
<p>SENSE (input) CHARACTER*1 Determines which reciprocal condition numbers are computed. = 'N': None are computed; = 'E': Computed for eigenvalues only; = 'V': Computed for right eigenvectors only; = 'B': Computed for eigenvalues and right eigenvectors.</p>
<p>If SENSE = 'E' or 'B', both left and right eigenvectors must also be computed (JOBVL = 'V' and JOBVR = 'V').</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the N-by-N matrix A. On exit, A has been overwritten. If JOBVL = 'V' or JOBVR = 'V', A contains the real Schur form of the balanced version of the input matrix A.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>WR (output) DOUBLE PRECISION array, dimension (N) WI (output) DOUBLE PRECISION array, dimension (N) WR and WI contain the real and imaginary parts, respectively, of the computed eigenvalues. Complex conjugate pairs of eigenvalues will appear consecutively with the eigenvalue having the positive imaginary part first.</p>
<p>VL (output) DOUBLE PRECISION array, dimension (LDVL,N) If JOBVL = 'V', the left eigenvectors u(j) are stored one after another in the columns of VL, in the same order as their eigenvalues. If JOBVL = 'N', VL is not referenced. If the j-th eigenvalue is real, then u(j) = VL(:,j), the j-th column of VL. If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and u(j+1) = VL(:,j) - i*VL(:,j+1).</p>
<p>LDVL (input) INTEGER The leading dimension of the array VL. LDVL &gt;= 1; if JOBVL = 'V', LDVL &gt;= N.</p>
<p>VR (output) DOUBLE PRECISION array, dimension (LDVR,N) If JOBVR = 'V', the right eigenvectors v(j) are stored one after another in the columns of VR, in the same order as their eigenvalues. If JOBVR = 'N', VR is not referenced. If the j-th eigenvalue is real, then v(j) = VR(:,j), the j-th column of VR. If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and v(j+1) = VR(:,j) - i*VR(:,j+1).</p>
<p>LDVR (input) INTEGER The leading dimension of the array VR. LDVR &gt;= 1, and if JOBVR = 'V', LDVR &gt;= N.</p>
<p>ILO (output) INTEGER IHI (output) INTEGER ILO and IHI are integer values determined when A was balanced. The balanced A(i,j) = 0 if I &gt; J and J = 1,...,ILO-1 or I = IHI+1,...,N.</p>
<p>SCALE (output) DOUBLE PRECISION array, dimension (N) Details of the permutations and scaling factors applied when balancing A. If P(j) is the index of the row and column interchanged with row and column j, and D(j) is the scaling factor applied to row and column j, then SCALE(J) = P(J), for J = 1,...,ILO-1 = D(J), for J = ILO,...,IHI = P(J) for J = IHI+1,...,N. The order in which the interchanges are made is N to IHI+1, then 1 to ILO-1.</p>
<p>ABNRM (output) DOUBLE PRECISION The one-norm of the balanced matrix (the maximum of the sum of absolute values of elements of any column).</p>
<p>RCONDE (output) DOUBLE PRECISION array, dimension (N) RCONDE(j) is the reciprocal condition number of the j-th eigenvalue.</p>
<p>RCONDV (output) DOUBLE PRECISION array, dimension (N) RCONDV(j) is the reciprocal condition number of the j-th right eigenvector.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If SENSE = 'N' or 'E', LWORK &gt;= max(1,2*N), and if JOBVL = 'V' or JOBVR = 'V', LWORK &gt;= 3*N. If SENSE = 'V' or 'B', LWORK &gt;= N*(N+6). For good performance, LWORK must generally be larger.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace) INTEGER array, dimension (2*N-2) If SENSE = 'N' or 'E', not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if INFO = i, the <a class="el" href="classpsi_1_1QR.html">QR</a> algorithm failed to compute all the eigenvalues, and no eigenvectors or condition numbers have been computed; elements 1:ILO-1 and i+1:N of WR and WI contain eigenvalues which have converged. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a1d2e64034cadb451e6eb150f7bf3a9bc_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6f8d5ceaca8b8229dff92d656a015a1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEGS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>This routine is deprecated and has been replaced by routine DGGES.</p>
<p>DGEGS computes the eigenvalues, real Schur form, and, optionally, left and or/right Schur vectors of a real matrix pair (A,B). Given two square matrices A and B, the generalized real Schur factorization has the form</p>
<p>A = Q*S*Z**T, B = Q*T*Z**T</p>
<p>where Q and Z are orthogonal matrices, T is upper triangular, and S is an upper quasi-triangular matrix with 1-by-1 and 2-by-2 diagonal blocks, the 2-by-2 blocks corresponding to complex conjugate pairs of eigenvalues of (A,B). The columns of Q are the left Schur vectors and the columns of Z are the right Schur vectors.</p>
<p>If only the eigenvalues of (A,B) are needed, the driver routine DGEGV should be used instead. See DGEGV for a description of the eigenvalues of the generalized nonsymmetric eigenvalue problem (GNEP).</p>
<h1>Arguments</h1>
<p>JOBVSL (input) CHARACTER*1 = 'N': do not compute the left Schur vectors; = 'V': compute the left Schur vectors (returned in VSL).</p>
<p>JOBVSR (input) CHARACTER*1 = 'N': do not compute the right Schur vectors; = 'V': compute the right Schur vectors (returned in VSR).</p>
<p>N (input) INTEGER The order of the matrices A, B, VSL, and VSR. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the matrix A. On exit, the upper quasi-triangular matrix S from the generalized real Schur factorization.</p>
<p>LDA (input) INTEGER The leading dimension of A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB, N) On entry, the matrix B. On exit, the upper triangular matrix T from the generalized real Schur factorization.</p>
<p>LDB (input) INTEGER The leading dimension of B. LDB &gt;= max(1,N).</p>
<p>ALPHAR (output) DOUBLE PRECISION array, dimension (N) The real parts of each scalar alpha defining an eigenvalue of GNEP.</p>
<p>ALPHAI (output) DOUBLE PRECISION array, dimension (N) The imaginary parts of each scalar alpha defining an eigenvalue of GNEP. If ALPHAI(j) is zero, then the j-th eigenvalue is real; if positive, then the j-th and (j+1)-st eigenvalues are a complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j).</p>
<p>BETA (output) DOUBLE PRECISION array, dimension (N) The scalars beta that define the eigenvalues of GNEP. Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and beta = BETA(j) represent the j-th eigenvalue of the matrix pair (A,B), in one of the forms lambda = alpha/beta or mu = beta/alpha. Since either lambda or mu may overflow, they should not, in general, be computed.</p>
<p>VSL (output) DOUBLE PRECISION array, dimension (LDVSL,N) If JOBVSL = 'V', the matrix of left Schur vectors Q. Not referenced if JOBVSL = 'N'.</p>
<p>LDVSL (input) INTEGER The leading dimension of the matrix VSL. LDVSL &gt;=1, and if JOBVSL = 'V', LDVSL &gt;= N.</p>
<p>VSR (output) DOUBLE PRECISION array, dimension (LDVSR,N) If JOBVSR = 'V', the matrix of right Schur vectors Z. Not referenced if JOBVSR = 'N'.</p>
<p>LDVSR (input) INTEGER The leading dimension of the matrix VSR. LDVSR &gt;= 1, and if JOBVSR = 'V', LDVSR &gt;= N.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,4*N). For good performance, LWORK must generally be larger. To compute the optimal value of LWORK, call ILAENV to get blocksizes (for DGEQRF, DORMQR, and DORGQR.) Then compute: NB &ndash; MAX of the blocksizes for DGEQRF, DORMQR, and DORGQR The optimal LWORK is 2*N + N*(NB+1).</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. = 1,...,N: The QZ iteration failed. (A,B) are not in Schur form, but ALPHAR(j), ALPHAI(j), and BETA(j) should be correct for j=INFO+1,...,N. &gt; N: errors that usually indicate LAPACK problems: =N+1: error return from DGGBAL =N+2: error return from DGEQRF =N+3: error return from DORMQR =N+4: error return from DORGQR =N+5: error return from DGGHRD =N+6: error return from DHGEQZ (other than failed iteration) =N+7: error return from DGGBAK (computing VSL) =N+8: error return from DGGBAK (computing VSR) =N+9: error return from DLASCL (various places) </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a6f8d5ceaca8b8229dff92d656a015a1e_icgraph.svg" width="296" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2aeeef8553a3df870d2401154745a386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEGV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>This routine is deprecated and has been replaced by routine DGGEV.</p>
<p>DGEGV computes the eigenvalues and, optionally, the left and/or right eigenvectors of a real matrix pair (A,B). Given two square matrices A and B, the generalized nonsymmetric eigenvalue problem (GNEP) is to find the eigenvalues lambda and corresponding (non-zero) eigenvectors x such that</p>
<p>A*x = lambda*B*x.</p>
<p>An alternate form is to find the eigenvalues mu and corresponding eigenvectors y such that</p>
<p>mu*A*y = B*y.</p>
<p>These two forms are equivalent with mu = 1/lambda and x = y if neither lambda nor mu is zero. In order to deal with the case that lambda or mu is zero or small, two values alpha and beta are returned for each eigenvalue, such that lambda = alpha/beta and mu = beta/alpha.</p>
<p>The vectors x and y in the above equations are right eigenvectors of the matrix pair (A,B). Vectors u and v satisfying</p>
<p>u**H*A = lambda*u**H*B or mu*v**H*A = v**H*B</p>
<p>are left eigenvectors of (A,B).</p>
<p>Note: this routine performs "full balancing" on A and B &ndash; see "Further Details", below.</p>
<h1>Arguments</h1>
<p>JOBVL (input) CHARACTER*1 = 'N': do not compute the left generalized eigenvectors; = 'V': compute the left generalized eigenvectors (returned in VL).</p>
<p>JOBVR (input) CHARACTER*1 = 'N': do not compute the right generalized eigenvectors; = 'V': compute the right generalized eigenvectors (returned in VR).</p>
<p>N (input) INTEGER The order of the matrices A, B, VL, and VR. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the matrix A. If JOBVL = 'V' or JOBVR = 'V', then on exit A contains the real Schur form of A from the generalized Schur factorization of the pair (A,B) after balancing. If no eigenvectors were computed, then only the diagonal blocks from the Schur form will be correct. See DGGHRD and DHGEQZ for details.</p>
<p>LDA (input) INTEGER The leading dimension of A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB, N) On entry, the matrix B. If JOBVL = 'V' or JOBVR = 'V', then on exit B contains the upper triangular matrix obtained from B in the generalized Schur factorization of the pair (A,B) after balancing. If no eigenvectors were computed, then only those elements of B corresponding to the diagonal blocks from the Schur form of A will be correct. See DGGHRD and DHGEQZ for details.</p>
<p>LDB (input) INTEGER The leading dimension of B. LDB &gt;= max(1,N).</p>
<p>ALPHAR (output) DOUBLE PRECISION array, dimension (N) The real parts of each scalar alpha defining an eigenvalue of GNEP.</p>
<p>ALPHAI (output) DOUBLE PRECISION array, dimension (N) The imaginary parts of each scalar alpha defining an eigenvalue of GNEP. If ALPHAI(j) is zero, then the j-th eigenvalue is real; if positive, then the j-th and (j+1)-st eigenvalues are a complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j).</p>
<p>BETA (output) DOUBLE PRECISION array, dimension (N) The scalars beta that define the eigenvalues of GNEP.</p>
<p>Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and beta = BETA(j) represent the j-th eigenvalue of the matrix pair (A,B), in one of the forms lambda = alpha/beta or mu = beta/alpha. Since either lambda or mu may overflow, they should not, in general, be computed.</p>
<p>VL (output) DOUBLE PRECISION array, dimension (LDVL,N) If JOBVL = 'V', the left eigenvectors u(j) are stored in the columns of VL, in the same order as their eigenvalues. If the j-th eigenvalue is real, then u(j) = VL(:,j). If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and u(j+1) = VL(:,j) - i*VL(:,j+1).</p>
<p>Each eigenvector is scaled so that its largest component has abs(real part) + abs(imag. part) = 1, except for eigenvectors corresponding to an eigenvalue with alpha = beta = 0, which are set to zero. Not referenced if JOBVL = 'N'.</p>
<p>LDVL (input) INTEGER The leading dimension of the matrix VL. LDVL &gt;= 1, and if JOBVL = 'V', LDVL &gt;= N.</p>
<p>VR (output) DOUBLE PRECISION array, dimension (LDVR,N) If JOBVR = 'V', the right eigenvectors x(j) are stored in the columns of VR, in the same order as their eigenvalues. If the j-th eigenvalue is real, then x(j) = VR(:,j). If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then x(j) = VR(:,j) + i*VR(:,j+1) and x(j+1) = VR(:,j) - i*VR(:,j+1).</p>
<p>Each eigenvector is scaled so that its largest component has abs(real part) + abs(imag. part) = 1, except for eigenvalues corresponding to an eigenvalue with alpha = beta = 0, which are set to zero. Not referenced if JOBVR = 'N'.</p>
<p>LDVR (input) INTEGER The leading dimension of the matrix VR. LDVR &gt;= 1, and if JOBVR = 'V', LDVR &gt;= N.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,8*N). For good performance, LWORK must generally be larger. To compute the optimal value of LWORK, call ILAENV to get blocksizes (for DGEQRF, DORMQR, and DORGQR.) Then compute: NB &ndash; MAX of the blocksizes for DGEQRF, DORMQR, and DORGQR; The optimal LWORK is: 2*N + MAX( 6*N, N*(NB+1) ).</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. = 1,...,N: The QZ iteration failed. No eigenvectors have been calculated, but ALPHAR(j), ALPHAI(j), and BETA(j) should be correct for j=INFO+1,...,N. &gt; N: errors that usually indicate LAPACK problems: =N+1: error return from DGGBAL =N+2: error return from DGEQRF =N+3: error return from DORMQR =N+4: error return from DORGQR =N+5: error return from DGGHRD =N+6: error return from DHGEQZ (other than failed iteration) =N+7: error return from DTGEVC =N+8: error return from DGGBAK (computing VL) =N+9: error return from DGGBAK (computing VR) =N+10: error return from DLASCL (various calls)</p>
<h1>Further Details</h1>
<h2>Balancing</h2>
<p>This driver calls DGGBAL to both permute and scale rows and columns of A and B. The permutations PL and PR are chosen so that PL*A*PR and PL*B*R will be upper triangular except for the diagonal blocks A(i:j,i:j) and B(i:j,i:j), with i and j as close together as possible. The diagonal scaling matrices DL and DR are chosen so that the pair DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to one (except for the elements that start out zero.)</p>
<p>After the eigenvalues and eigenvectors of the balanced matrices have been computed, DGGBAK transforms the eigenvectors back to what they would have been (in perfect arithmetic) if they had not been balanced.</p>
<p>Contents of A and B on Exit </p>
<hr/>
<p>If any eigenvectors are computed (either JOBVL='V' or JOBVR='V' or both), then on exit the arrays A and B will contain the real Schur form[*] of the "balanced" versions of A and B. If no eigenvectors are computed, then only the diagonal blocks will be correct.</p>
<p>[*] See DHGEQZ, DGEGS, or read the book "Matrix Computations", by Golub &amp; van Loan, pub. by Johns Hopkins U. Press. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a2aeeef8553a3df870d2401154745a386_icgraph.svg" width="296" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa4268adae718a19acfddd3b0e634d589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEHRD </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEHRD reduces a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation: Q' * A * Q = H .</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>ILO (input) INTEGER IHI (input) INTEGER It is assumed that A is already upper triangular in rows and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally set by a previous call to DGEBAL; otherwise they should be set to 1 and N respectively. See Further Details. 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the N-by-N general matrix to be reduced. On exit, the upper triangle and the first subdiagonal of A are overwritten with the upper Hessenberg matrix H, and the elements below the first subdiagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (N-1) The scalar factors of the elementary reflectors (see Further Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to zero.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (LWORK) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The length of the array WORK. LWORK &gt;= max(1,N). For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>The matrix Q is represented as a product of (ihi-ilo) elementary reflectors</p>
<p>Q = H(ilo) H(ilo+1) . . . H(ihi-1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on exit in A(i+2:ihi,i), and tau in TAU(i).</p>
<p>The contents of A are illustrated by the following example, with n = 7, ilo = 2 and ihi = 6:</p>
<p>on entry, on exit,</p>
<p>( a a a a a a a ) ( a a h h h h a ) ( a a a a a a ) ( a h h h h a ) ( a a a a a a ) ( h h h h h h ) ( a a a a a a ) ( v2 h h h h h ) ( a a a a a a ) ( v2 v3 h h h h ) ( a a a a a a ) ( v2 v3 v4 h h h ) ( a ) ( a )</p>
<p>where a denotes an element of the original matrix A, h denotes a modified element of the upper Hessenberg matrix H, and vi denotes an element of the vector defining H(i).</p>
<p>This file is a slight modification of LAPACK-3.0's DGEHRD subroutine incorporating improvements proposed by Quintana-Orti and Van de Geijn (2006). (See DLAHR2.) </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa4268adae718a19acfddd3b0e634d589_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0f394133d870da8f2cd6dd7b2093ab76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGELQF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGELQF computes an LQ factorization of a real M-by-N matrix A: A = L * Q.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, the elements on and below the diagonal of the array contain the m-by-min(m,n) lower trapezoidal matrix L (L is lower triangular if m &lt;= n); the elements above the diagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors (see Further Details).</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (min(M,N)) The scalar factors of the elementary reflectors (see Further Details).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= M*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>The matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(k) . . . H(2) H(1), where k = min(m,n).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n), and tau in TAU(i). </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a0f394133d870da8f2cd6dd7b2093ab76_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a123439d31f9576acf588a2a19269a9e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGELS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGELS solves overdetermined or underdetermined real linear systems involving an M-by-N matrix A, or its transpose, using a <a class="el" href="classpsi_1_1QR.html">QR</a> or LQ factorization of A. It is assumed that A has full rank.</p>
<p>The following options are provided:</p>
<ol type="1">
<li>If TRANS = 'N' and m &gt;= n: find the least squares solution of an overdetermined system, i.e., solve the least squares problem minimize || B - A*X ||.</li>
</ol>
<ol type="1">
<li>If TRANS = 'N' and m &lt; n: find the minimum norm solution of an underdetermined system A * X = B.</li>
</ol>
<ol type="1">
<li>If TRANS = 'T' and m &gt;= n: find the minimum norm solution of an undetermined system A**T * X = B.</li>
</ol>
<ol type="1">
<li>If TRANS = 'T' and m &lt; n: find the least squares solution of an overdetermined system, i.e., solve the least squares problem minimize || B - A**T * X ||.</li>
</ol>
<p>Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.</p>
<h1>Arguments</h1>
<p>TRANS (input) CHARACTER*1 = 'N': the linear system involves A; = 'T': the linear system involves A**T.</p>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;=0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, if M &gt;= N, A is overwritten by details of its <a class="el" href="classpsi_1_1QR.html">QR</a> factorization as returned by DGEQRF; if M &lt; N, A is overwritten by details of its LQ factorization as returned by DGELQF.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the matrix B of right hand side vectors, stored columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS if TRANS = 'T'. On exit, if INFO = 0, B is overwritten by the solution vectors, stored columnwise: if TRANS = 'N' and m &gt;= n, rows 1 to n of B contain the least squares solution vectors; the residual sum of squares for the solution in each column is given by the sum of squares of elements N+1 to M in that column; if TRANS = 'N' and m &lt; n, rows 1 to N of B contain the minimum norm solution vectors; if TRANS = 'T' and m &gt;= n, rows 1 to M of B contain the minimum norm solution vectors; if TRANS = 'T' and m &lt; n, rows 1 to M of B contain the least squares solution vectors; the residual sum of squares for the solution in each column is given by the sum of squares of elements M+1 to N in that column.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= MAX(1,M,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max( 1, MN + max( MN, NRHS ) ). For optimal performance, LWORK &gt;= max( 1, MN + max( MN, NRHS )*NB ). where MN = min(M,N) and NB is the optimum block size.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the i-th diagonal element of the triangular factor of A is zero, so that A does not have full rank; the least squares solution could not be computed. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a123439d31f9576acf588a2a19269a9e5_icgraph.svg" width="291" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7eadbebece8fa1afb07d8ecb35188d90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGELSD </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGELSD computes the minimum-norm solution to a real linear least squares problem: minimize 2-norm(| b - A*x |) using the singular value decomposition (SVD) of A. A is an M-by-N matrix which may be rank-deficient.</p>
<p>Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.</p>
<p>The problem is solved in three steps: (1) Reduce the coefficient matrix A to bidiagonal form with Householder transformations, reducing the original problem into a "bidiagonal least squares problem" (BLS) (2) Solve the BLS using a divide and conquer approach. (3) Apply back all the Householder tranformations to solve the original least squares problem.</p>
<p>The effective rank of A is determined by treating as zero those singular values which are less than RCOND times the largest singular value.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, A has been destroyed.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the M-by-NRHS right hand side matrix B. On exit, B is overwritten by the N-by-NRHS solution matrix X. If m &gt;= n and RANK = n, the residual sum-of-squares for the solution in the i-th column is given by the sum of squares of elements n+1:m in that column.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,max(M,N)).</p>
<p>S (output) DOUBLE PRECISION array, dimension (min(M,N)) The singular values of A in decreasing order. The condition number of A in the 2-norm = S(1)/S(min(m,n)).</p>
<p>RCOND (input) DOUBLE PRECISION RCOND is used to determine the effective rank of A. Singular values S(i) &lt;= RCOND*S(1) are treated as zero. If RCOND &lt; 0, machine precision is used instead.</p>
<p>RANK (output) INTEGER The effective rank of A, i.e., the number of singular values which are greater than RCOND*S(1).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK must be at least 1. The exact minimum amount of workspace needed depends on M, N and NRHS. As long as LWORK is at least 12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2, if M is greater than or equal to N or 12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2, if M is less than N, the code will execute correctly. SMLSIZ is returned by ILAENV and is equal to the maximum size of the subproblems at the bottom of the computation tree (usually about 25), and NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 ) For good performance, LWORK should generally be larger.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace) INTEGER array, dimension (MAX(1,LIWORK)) LIWORK &gt;= max(1, 3 * MINMN * NLVL + 11 * MINMN), where MINMN = MIN( M,N ). On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: the algorithm for computing the SVD failed to converge; if INFO = i, i off-diagonal elements of an intermediate bidiagonal form did not converge to zero.</p>
<h1>Further Details</h1>
<p>Based on contributions by Ming Gu and Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA Osni Marques, LBNL/NERSC, USA </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a7eadbebece8fa1afb07d8ecb35188d90_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aeaf94e88ad977b6051ea4c879f55f6ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGELSS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGELSS computes the minimum norm solution to a real linear least squares problem:</p>
<p>Minimize 2-norm(| b - A*x |).</p>
<p>using the singular value decomposition (SVD) of A. A is an M-by-N matrix which may be rank-deficient.</p>
<p>Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.</p>
<p>The effective rank of A is determined by treating as zero those singular values which are less than RCOND times the largest singular value.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, the first min(m,n) rows of A are overwritten with its right singular vectors, stored rowwise.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the M-by-NRHS right hand side matrix B. On exit, B is overwritten by the N-by-NRHS solution matrix X. If m &gt;= n and RANK = n, the residual sum-of-squares for the solution in the i-th column is given by the sum of squares of elements n+1:m in that column.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,max(M,N)).</p>
<p>S (output) DOUBLE PRECISION array, dimension (min(M,N)) The singular values of A in decreasing order. The condition number of A in the 2-norm = S(1)/S(min(m,n)).</p>
<p>RCOND (input) DOUBLE PRECISION RCOND is used to determine the effective rank of A. Singular values S(i) &lt;= RCOND*S(1) are treated as zero. If RCOND &lt; 0, machine precision is used instead.</p>
<p>RANK (output) INTEGER The effective rank of A, i.e., the number of singular values which are greater than RCOND*S(1).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= 1, and also: LWORK &gt;= 3*min(M,N) + max( 2*min(M,N), max(M,N), NRHS ) For good performance, LWORK should generally be larger.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: the algorithm for computing the SVD failed to converge; if INFO = i, i off-diagonal elements of an intermediate bidiagonal form did not converge to zero. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aeaf94e88ad977b6051ea4c879f55f6ac_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a418cc23eb0505cc6da7e6bdb1c05ef87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGELSX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>jpvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>This routine is deprecated and has been replaced by routine DGELSY.</p>
<p>DGELSX computes the minimum-norm solution to a real linear least squares problem: minimize || A * X - B || using a complete orthogonal factorization of A. A is an M-by-N matrix which may be rank-deficient.</p>
<p>Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.</p>
<p>The routine first computes a <a class="el" href="classpsi_1_1QR.html">QR</a> factorization with column pivoting: A * P = Q * [ R11 R12 ] [ 0 R22 ] with R11 defined as the largest leading submatrix whose estimated condition number is less than 1/RCOND. The order of R11, RANK, is the effective rank of A.</p>
<p>Then, R22 is considered to be negligible, and R12 is annihilated by orthogonal transformations from the right, arriving at the complete orthogonal factorization: A * P = Q * [ T11 0 ] * Z [ 0 0 ] The minimum-norm solution is then X = P * Z' [ inv(T11)*Q1'*B ] [ 0 ] where Q1 consists of the first RANK columns of Q.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of matrices B and X. NRHS &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, A has been overwritten by details of its complete orthogonal factorization.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the M-by-NRHS right hand side matrix B. On exit, the N-by-NRHS solution matrix X. If m &gt;= n and RANK = n, the residual sum-of-squares for the solution in the i-th column is given by the sum of squares of elements N+1:M in that column.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,M,N).</p>
<p>JPVT (input/output) INTEGER array, dimension (N) On entry, if JPVT(i) .ne. 0, the i-th column of A is an initial column, otherwise it is a free column. Before the <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of A, all initial columns are permuted to the leading positions; only the remaining free columns are moved as a result of column pivoting during the factorization. On exit, if JPVT(i) = k, then the i-th column of A*P was the k-th column of A.</p>
<p>RCOND (input) DOUBLE PRECISION RCOND is used to determine the effective rank of A, which is defined as the order of the largest leading triangular submatrix R11 in the <a class="el" href="classpsi_1_1QR.html">QR</a> factorization with pivoting of A, whose estimated condition number &lt; 1/RCOND.</p>
<p>RANK (output) INTEGER The effective rank of A, i.e., the order of the submatrix R11. This is the same as the order of the submatrix T11 in the complete orthogonal factorization of A.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a418cc23eb0505cc6da7e6bdb1c05ef87_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a716a475ae7a4d53c272dfaf1b2b4f484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGELSY </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>jpvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGELSY computes the minimum-norm solution to a real linear least squares problem: minimize || A * X - B || using a complete orthogonal factorization of A. A is an M-by-N matrix which may be rank-deficient.</p>
<p>Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.</p>
<p>The routine first computes a <a class="el" href="classpsi_1_1QR.html">QR</a> factorization with column pivoting: A * P = Q * [ R11 R12 ] [ 0 R22 ] with R11 defined as the largest leading submatrix whose estimated condition number is less than 1/RCOND. The order of R11, RANK, is the effective rank of A.</p>
<p>Then, R22 is considered to be negligible, and R12 is annihilated by orthogonal transformations from the right, arriving at the complete orthogonal factorization: A * P = Q * [ T11 0 ] * Z [ 0 0 ] The minimum-norm solution is then X = P * Z' [ inv(T11)*Q1'*B ] [ 0 ] where Q1 consists of the first RANK columns of Q.</p>
<p>This routine is basically identical to the original xGELSX except three differences: o The call to the subroutine xGEQPF has been substituted by the the call to the subroutine xGEQP3. This subroutine is a Blas-3 version of the <a class="el" href="classpsi_1_1QR.html">QR</a> factorization with column pivoting. o <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> B (the right hand side) is updated with Blas-3. o The permutation of matrix B (the right hand side) is faster and more simple.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of matrices B and X. NRHS &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, A has been overwritten by details of its complete orthogonal factorization.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the M-by-NRHS right hand side matrix B. On exit, the N-by-NRHS solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,M,N).</p>
<p>JPVT (input/output) INTEGER array, dimension (N) On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted to the front of AP, otherwise column i is a free column. On exit, if JPVT(i) = k, then the i-th column of AP was the k-th column of A.</p>
<p>RCOND (input) DOUBLE PRECISION RCOND is used to determine the effective rank of A, which is defined as the order of the largest leading triangular submatrix R11 in the <a class="el" href="classpsi_1_1QR.html">QR</a> factorization with pivoting of A, whose estimated condition number &lt; 1/RCOND.</p>
<p>RANK (output) INTEGER The effective rank of A, i.e., the order of the submatrix R11. This is the same as the order of the submatrix T11 in the complete orthogonal factorization of A.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. The unblocked strategy requires that: LWORK &gt;= MAX( MN+3*N+1, 2*MN+NRHS ), where MN = min( M, N ). The block algorithm requires that: LWORK &gt;= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ), where NB is an upper bound on the blocksize returned by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR, and DORMRZ.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: If INFO = -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>Based on contributions by A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA E. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a716a475ae7a4d53c272dfaf1b2b4f484_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1112df35ff9d2b780efb0c24662f4fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DGEMM </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>transa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>transb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEMM performs one of the matrix-matrix operations</p>
<p>C := alpha*op( A )*op( B ) + beta*C,</p>
<p>where op( X ) is one of</p>
<p>op( X ) = X or op( X ) = X',</p>
<p>alpha and beta are scalars, and A, B and C are matrices, with op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.</p>
<h1>Arguments</h1>
<p>TRANSA - CHARACTER*1. On entry, TRANSA specifies the form of op( A ) to be used in the matrix multiplication as follows:</p>
<p>TRANSA = 'N' or 'n', op( A ) = A.</p>
<p>TRANSA = 'T' or 't', op( A ) = A'.</p>
<p>TRANSA = 'C' or 'c', op( A ) = A'.</p>
<p>Unchanged on exit.</p>
<p>TRANSB - CHARACTER*1. On entry, TRANSB specifies the form of op( B ) to be used in the matrix multiplication as follows:</p>
<p>TRANSB = 'N' or 'n', op( B ) = B.</p>
<p>TRANSB = 'T' or 't', op( B ) = B'.</p>
<p>TRANSB = 'C' or 'c', op( B ) = B'.</p>
<p>Unchanged on exit.</p>
<p>M - INTEGER. On entry, M specifies the number of rows of the matrix op( A ) and of the matrix C. M must be at least zero. Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the number of columns of the matrix op( B ) and the number of columns of the matrix C. N must be at least zero. Unchanged on exit.</p>
<p>K - INTEGER. On entry, K specifies the number of columns of the matrix op( A ) and the number of rows of the matrix op( B ). K must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is k when TRANSA = 'N' or 'n', and is m otherwise. Before entry with TRANSA = 'N' or 'n', the leading m by k part of the array A must contain the matrix A, otherwise the leading k by m part of the array A must contain the matrix A. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. When TRANSA = 'N' or 'n' then LDA must be at least max( 1, m ), otherwise LDA must be at least max( 1, k ). Unchanged on exit.</p>
<p>B - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is n when TRANSB = 'N' or 'n', and is k otherwise. Before entry with TRANSB = 'N' or 'n', the leading k by n part of the array B must contain the matrix B, otherwise the leading n by k part of the array B must contain the matrix B. Unchanged on exit.</p>
<p>LDB - INTEGER. On entry, LDB specifies the first dimension of B as declared in the calling (sub) program. When TRANSB = 'N' or 'n' then LDB must be at least max( 1, k ), otherwise LDB must be at least max( 1, n ). Unchanged on exit.</p>
<p>BETA - DOUBLE PRECISION. On entry, BETA specifies the scalar beta. When BETA is supplied as zero then C need not be set on input. Unchanged on exit.</p>
<p>C - DOUBLE PRECISION array of DIMENSION ( LDC, n ). Before entry, the leading m by n part of the array C must contain the matrix C, except when beta is zero, in which case C need not be set on entry. On exit, the array C is overwritten by the m by n matrix ( alpha*op( A )*op( B ) + beta*C ).</p>
<p>LDC - INTEGER. On entry, LDC specifies the first dimension of C as declared in the calling (sub) program. LDC must be at least max( 1, m ). Unchanged on exit.</p>
<p>Level 3 Blas routine.</p>
<p>&ndash; Written on 8-February-1989. Jack Dongarra, Argonne National Laboratory. Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical Algorithms Group Ltd.</p>
<p>.. External Functions .. </p>

</div>
</div>
<a class="anchor" id="a8f839afc1a7e4950dbaa3521e5eae60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DGEMV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEMV performs one of the matrix-vector operations</p>
<p>y := alpha*A*x + beta*y, or y := alpha*A'*x + beta*y,</p>
<p>where alpha and beta are scalars, x and y are vectors and A is an m by n matrix.</p>
<h1>Arguments</h1>
<p>TRANS - CHARACTER*1. On entry, TRANS specifies the operation to be performed as follows:</p>
<p>TRANS = 'N' or 'n' y := alpha*A*x + beta*y.</p>
<p>TRANS = 'T' or 't' y := alpha*A'*x + beta*y.</p>
<p>TRANS = 'C' or 'c' y := alpha*A'*x + beta*y.</p>
<p>Unchanged on exit.</p>
<p>M - INTEGER. On entry, M specifies the number of rows of the matrix A. M must be at least zero. Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the number of columns of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry, the leading m by n part of the array A must contain the matrix of coefficients. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least max( 1, m ). Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of DIMENSION at least ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' and at least ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. Before entry, the incremented array X must contain the vector x. Unchanged on exit.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>BETA - DOUBLE PRECISION. On entry, BETA specifies the scalar beta. When BETA is supplied as zero then Y need not be set on input. Unchanged on exit.</p>
<p>Y - DOUBLE PRECISION array of DIMENSION at least ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' and at least ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. Before entry with BETA non-zero, the incremented array Y must contain the vector y. On exit, Y is overwritten by the updated vector y.</p>
<p>INCY - INTEGER. On entry, INCY specifies the increment for the elements of Y. INCY must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacepsi_a8f839afc1a7e4950dbaa3521e5eae60f_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae8dc38039a8fad7ead68e36c3c6b3a59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEQLF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEQLF computes a QL factorization of a real M-by-N matrix A: A = Q * L.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, if m &gt;= n, the lower triangle of the subarray A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L; if m &lt;= n, the elements on and below the (n-m)-th superdiagonal contain the M-by-N lower trapezoidal matrix L; the remaining elements, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors (see Further Details).</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (min(M,N)) The scalar factors of the elementary reflectors (see Further Details).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N). For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>The matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(k) . . . H(2) H(1), where k = min(m,n).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in A(1:m-k+i-1,n-k+i), and tau in TAU(i). </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ae8dc38039a8fad7ead68e36c3c6b3a59_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a177094575b64845a2e142a79b1a4fa37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEQP3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>jpvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEQP3 computes a <a class="el" href="classpsi_1_1QR.html">QR</a> factorization with column pivoting of a matrix A: A*P = Q*R using Level 3 BLAS.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, the upper triangle of the array contains the min(M,N)-by-N upper trapezoidal matrix R; the elements below the diagonal, together with the array TAU, represent the orthogonal matrix Q as a product of min(M,N) elementary reflectors.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>JPVT (input/output) INTEGER array, dimension (N) On entry, if JPVT(J).ne.0, the J-th column of A is permuted to the front of A*P (a leading column); if JPVT(J)=0, the J-th column of A is a free column. On exit, if JPVT(J)=K, then the J-th column of A*P was the the K-th column of A.</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (min(M,N)) The scalar factors of the elementary reflectors.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO=0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= 3*N+1. For optimal performance LWORK &gt;= 2*N+( N+1 )*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>The matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(k), where k = min(m,n).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real/complex scalar, and v is a real/complex vector with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i), and tau in TAU(i).</p>
<p>Based on contributions by G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain X. Sun, Computer Science Dept., Duke University, USA </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a177094575b64845a2e142a79b1a4fa37_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0c7b1bf710faa0effed2123e38759485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEQPF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>jpvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>This routine is deprecated and has been replaced by routine DGEQP3.</p>
<p>DGEQPF computes a <a class="el" href="classpsi_1_1QR.html">QR</a> factorization with column pivoting of a real M-by-N matrix A: A*P = Q*R.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, the upper triangle of the array contains the min(M,N)-by-N upper triangular matrix R; the elements below the diagonal, together with the array TAU, represent the orthogonal matrix Q as a product of min(m,n) elementary reflectors.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>JPVT (input/output) INTEGER array, dimension (N) On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted to the front of A*P (a leading column); if JPVT(i) = 0, the i-th column of A is a free column. On exit, if JPVT(i) = k, then the i-th column of A*P was the k-th column of A.</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (min(M,N)) The scalar factors of the elementary reflectors.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>The matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(n)</p>
<p>Each H(i) has the form</p>
<p>H = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).</p>
<p>The matrix P is represented in jpvt as follows: If jpvt(j) = i then the jth column of P is the ith canonical unit vector.</p>
<p>Partial column norm updating strategy modified by Z. Drmac and Z. Bujanovic, Dept. of Mathematics, University of Zagreb, Croatia. June 2010 For more details see LAPACK Working Note 176. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a0c7b1bf710faa0effed2123e38759485_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae4774c9554c816b3d040bf10a31248fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEQRF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGEQRF computes a <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of a real M-by-N matrix A: A = Q * R.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, the elements on and above the diagonal of the array contain the min(M,N)-by-N upper trapezoidal matrix R (R is upper triangular if m &gt;= n); the elements below the diagonal, with the array TAU, represent the orthogonal matrix Q as a product of min(m,n) elementary reflectors (see Further Details).</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (min(M,N)) The scalar factors of the elementary reflectors (see Further Details).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N). For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>The matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(k), where k = min(m,n).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i), and tau in TAU(i). </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ae4774c9554c816b3d040bf10a31248fc_icgraph.svg" width="315" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa167c724fe9d2511e1f80dbe5125425e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DGER </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGER performs the rank 1 operation</p>
<p>A := alpha*x*y' + A,</p>
<p>where alpha is a scalar, x is an m element vector, y is an n element vector and A is an m by n matrix.</p>
<h1>Arguments</h1>
<p>M - INTEGER. On entry, M specifies the number of rows of the matrix A. M must be at least zero. Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the number of columns of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( m - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the m element vector x. Unchanged on exit.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>Y - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCY ) ). Before entry, the incremented array Y must contain the n element vector y. Unchanged on exit.</p>
<p>INCY - INTEGER. On entry, INCY specifies the increment for the elements of Y. INCY must not be zero. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry, the leading m by n part of the array A must contain the matrix of coefficients. On exit, A is overwritten by the updated matrix.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least max( 1, m ). Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa167c724fe9d2511e1f80dbe5125425e_icgraph.svg" width="334" height="163"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a98b81cd2301924a351c6c5bd7f1ec7c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGERFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGERFS improves the computed solution to a system of linear equations and provides error bounds and backward error estimates for the solution.</p>
<h1>Arguments</h1>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Conjugate transpose = Transpose)</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The original N-by-N matrix A.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>AF (input) DOUBLE PRECISION array, dimension (LDAF,N) The factors L and U from the factorization A = P*L*U as computed by DGETRF.</p>
<p>LDAF (input) INTEGER The leading dimension of the array AF. LDAF &gt;= max(1,N).</p>
<p>IPIV (input) INTEGER array, dimension (N) The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the matrix was interchanged with row IPIV(i).</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS) On entry, the solution matrix X, as computed by DGETRS. On exit, the improved solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Internal Parameters</h1>
<p>ITMAX is the maximum number of steps of iterative refinement. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a98b81cd2301924a351c6c5bd7f1ec7c2_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a00ad4b8597e2b4e81089f1bef5779bc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGERQF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGERQF computes an RQ factorization of a real M-by-N matrix A: A = R * Q.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, if m &lt;= n, the upper triangle of the subarray A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R; if m &gt;= n, the elements on and above the (m-n)-th subdiagonal contain the M-by-N upper trapezoidal matrix R; the remaining elements, with the array TAU, represent the orthogonal matrix Q as a product of min(m,n) elementary reflectors (see Further Details).</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (min(M,N)) The scalar factors of the elementary reflectors (see Further Details).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= M*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>The matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(k), where k = min(m,n).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i). </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a00ad4b8597e2b4e81089f1bef5779bc1_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a694b74f34cfc82e3bb2bc573b3bbb9bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGESDD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGESDD computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and right singular vectors. If singular vectors are desired, it uses a divide-and-conquer algorithm.</p>
<p>The SVD is written </p>
<pre class="fragment"> A = U * SIGMA * transpose(V)
</pre><p>where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A.</p>
<p>Note that the routine returns VT = V**T, not V.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 Specifies options for computing all or part of the matrix U: = 'A': all M columns of U and all N rows of V**T are returned in the arrays U and VT; = 'S': the first min(M,N) columns of U and the first min(M,N) rows of V**T are returned in the arrays U and VT; = 'O': If M &gt;= N, the first N columns of U are overwritten on the array A and all rows of V**T are returned in the array VT; otherwise, all columns of U are returned in the array U and the first M rows of V**T are overwritten in the array A; = 'N': no columns of U or rows of V**T are computed.</p>
<p>M (input) INTEGER The number of rows of the input matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the input matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, if JOBZ = 'O', A is overwritten with the first N columns of U (the left singular vectors, stored columnwise) if M &gt;= N; A is overwritten with the first M rows of V**T (the right singular vectors, stored rowwise) otherwise. if JOBZ .ne. 'O', the contents of A are destroyed.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>S (output) DOUBLE PRECISION array, dimension (min(M,N)) The singular values of A, sorted so that S(i) &gt;= S(i+1).</p>
<p>U (output) DOUBLE PRECISION array, dimension (LDU,UCOL) UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N; UCOL = min(M,N) if JOBZ = 'S'. If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M orthogonal matrix U; if JOBZ = 'S', U contains the first min(M,N) columns of U (the left singular vectors, stored columnwise); if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</p>
<p>LDU (input) INTEGER The leading dimension of the array U. LDU &gt;= 1; if JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.</p>
<p>VT (output) DOUBLE PRECISION array, dimension (LDVT,N) If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', VT contains the first min(M,N) rows of V**T (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.</p>
<p>LDVT (input) INTEGER The leading dimension of the array VT. LDVT &gt;= 1; if JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N; if JOBZ = 'S', LDVT &gt;= min(M,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK;</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= 1. If JOBZ = 'N', LWORK &gt;= 3*min(M,N) + max(max(M,N),7*min(M,N)). If JOBZ = 'O', LWORK &gt;= 3*min(M,N) + max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)). If JOBZ = 'S' or 'A' LWORK &gt;= 3*min(M,N) + max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)). For good performance, LWORK should generally be larger. If LWORK = -1 but other input arguments are legal, WORK(1) returns the optimal LWORK.</p>
<p>IWORK (workspace) INTEGER array, dimension (8*min(M,N))</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: DBDSDC did not converge, updating process failed.</p>
<h1>Further Details</h1>
<p>Based on contributions by Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a694b74f34cfc82e3bb2bc573b3bbb9bf_icgraph.svg" width="542" height="163"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a75592ae4cf9f1cc964de8086146df0fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGESVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGESVX uses the LU factorization to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N matrix and X and B are N-by-NRHS matrices.</p>
<p>Error bounds on the solution and a condition estimate are also provided.</p>
<h1>Description</h1>
<p>The following steps are performed:</p>
<ol type="1">
<li>If FACT = 'E', real scaling factors are computed to equilibrate the system: TRANS = 'N': diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B Whether or not the system will be equilibrated depends on the scaling of the matrix A, but if equilibration is used, A is overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N') or diag(C)*B (if TRANS = 'T' or 'C').</li>
</ol>
<ol type="1">
<li>If FACT = 'N' or 'E', the LU decomposition is used to factor the matrix A (after equilibration if FACT = 'E') as A = P * L * U, where P is a permutation matrix, L is a unit lower triangular matrix, and U is upper triangular.</li>
</ol>
<ol type="1">
<li>If some U(i,i)=0, so that U is exactly singular, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A. If the reciprocal of the condition number is less than machine precision, C++ Return value: INFO (output) INTEGER to solve for X and compute error bounds as described below.</li>
</ol>
<ol type="1">
<li>The system of equations is solved for X using the factored form of A.</li>
</ol>
<ol type="1">
<li>Iterative refinement is applied to improve the computed solution matrix and calculate error bounds and backward error estimates for it.</li>
</ol>
<ol type="1">
<li>If equilibration was used, the matrix X is premultiplied by diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so that it solves the original system before equilibration.</li>
</ol>
<h1>Arguments</h1>
<p>FACT (input) CHARACTER*1 Specifies whether or not the factored form of the matrix A is supplied on entry, and if not, whether the matrix A should be equilibrated before it is factored. = 'F': On entry, AF and IPIV contain the factored form of A. If EQUED is not 'N', the matrix A has been equilibrated with scaling factors given by R and C. A, AF, and IPIV are not modified. = 'N': The matrix A will be copied to AF and factored. = 'E': The matrix A will be equilibrated if necessary, then copied to AF and factored.</p>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Transpose)</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the N-by-N matrix A. If FACT = 'F' and EQUED is not 'N', then A must have been equilibrated by the scaling factors in R and/or C. A is not modified if FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.</p>
<p>On exit, if EQUED .ne. 'N', A is scaled as follows: EQUED = 'R': A := diag(R) * A EQUED = 'C': A := A * diag(C) EQUED = 'B': A := diag(R) * A * diag(C).</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>AF (input or output) DOUBLE PRECISION array, dimension (LDAF,N) If FACT = 'F', then AF is an input argument and on entry contains the factors L and U from the factorization A = P*L*U as computed by DGETRF. If EQUED .ne. 'N', then AF is the factored form of the equilibrated matrix A.</p>
<p>If FACT = 'N', then AF is an output argument and on exit returns the factors L and U from the factorization A = P*L*U of the original matrix A.</p>
<p>If FACT = 'E', then AF is an output argument and on exit returns the factors L and U from the factorization A = P*L*U of the equilibrated matrix A (see the description of A for the form of the equilibrated matrix).</p>
<p>LDAF (input) INTEGER The leading dimension of the array AF. LDAF &gt;= max(1,N).</p>
<p>IPIV (input or output) INTEGER array, dimension (N) If FACT = 'F', then IPIV is an input argument and on entry contains the pivot indices from the factorization A = P*L*U as computed by DGETRF; row i of the matrix was interchanged with row IPIV(i).</p>
<p>If FACT = 'N', then IPIV is an output argument and on exit contains the pivot indices from the factorization A = P*L*U of the original matrix A.</p>
<p>If FACT = 'E', then IPIV is an output argument and on exit contains the pivot indices from the factorization A = P*L*U of the equilibrated matrix A.</p>
<p>EQUED (input or output) CHARACTER*1 Specifies the form of equilibration that was done. = 'N': No equilibration (always true if FACT = 'N'). = 'R': Row equilibration, i.e., A has been premultiplied by diag(R). = 'C': Column equilibration, i.e., A has been postmultiplied by diag(C). = 'B': Both row and column equilibration, i.e., A has been replaced by diag(R) * A * diag(C). EQUED is an input argument if FACT = 'F'; otherwise, it is an output argument.</p>
<p>R (input or output) DOUBLE PRECISION array, dimension (N) The row scale factors for A. If EQUED = 'R' or 'B', A is multiplied on the left by diag(R); if EQUED = 'N' or 'C', R is not accessed. R is an input argument if FACT = 'F'; otherwise, R is an output argument. If FACT = 'F' and EQUED = 'R' or 'B', each element of R must be positive.</p>
<p>C (input or output) DOUBLE PRECISION array, dimension (N) The column scale factors for A. If EQUED = 'C' or 'B', A is multiplied on the right by diag(C); if EQUED = 'N' or 'R', C is not accessed. C is an input argument if FACT = 'F'; otherwise, C is an output argument. If FACT = 'F' and EQUED = 'C' or 'B', each element of C must be positive.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if EQUED = 'N', B is not modified; if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by diag(R)*B; if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is overwritten by diag(C)*B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,NRHS) If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to the original system of equations. Note that A and B are modified on exit if EQUED .ne. 'N', and the solution to the equilibrated system is inv(diag(C))*X if TRANS = 'N' and EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C' and EQUED = 'R' or 'B'.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>RCOND (output) DOUBLE PRECISION The estimate of the reciprocal condition number of the matrix A after equilibration (if done). If RCOND is less than the machine precision (in particular, if RCOND = 0), the matrix is singular to working precision. This condition is indicated by a return code of INFO &gt; 0.</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (4*N) On exit, WORK(1) contains the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If WORK(1) is much less than 1, then the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, condition estimator RCOND, and forward error bound FERR could be unreliable. If factorization fails with 0&lt;INFO&lt;=N, then WORK(1) contains the reciprocal pivot growth factor for the leading INFO columns of A.</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= N: U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution and error bounds could not be computed. RCOND = 0 is returned. = N+1: U is nonsingular, but RCOND is less than machine precision, meaning that the matrix is singular to working precision. Nevertheless, the solution and error bounds are computed because there are a number of situations where the computed solution can be more accurate than the value of RCOND would suggest. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a75592ae4cf9f1cc964de8086146df0fc_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa4297da7ca4fc2c7aa1234927a5bb111"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGETRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGETRS solves a system of linear equations A * X = B or A' * X = B with a general N-by-N matrix A using the LU factorization computed by DGETRF.</p>
<h1>Arguments</h1>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A'* X = B (Transpose) = 'C': A'* X = B (Conjugate transpose = Transpose)</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The factors L and U from the factorization A = P*L*U as computed by DGETRF.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>IPIV (input) INTEGER array, dimension (N) The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the matrix was interchanged with row IPIV(i).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa4297da7ca4fc2c7aa1234927a5bb111_icgraph.svg" width="328" height="163"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa44dfe07a23e79c1ac034b65d50f39b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGBAK </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGBAK forms the right or left eigenvectors of a real generalized eigenvalue problem A*x = lambda*B*x, by backward transformation on the computed eigenvectors of the balanced pair of matrices output by DGGBAL.</p>
<h1>Arguments</h1>
<p>JOB (input) CHARACTER*1 Specifies the type of backward transformation required: = 'N': do nothing, return immediately; = 'P': do backward transformation for permutation only; = 'S': do backward transformation for scaling only; = 'B': do backward transformations for both permutation and scaling. JOB must be the same as the argument JOB supplied to DGGBAL.</p>
<p>SIDE (input) CHARACTER*1 = 'R': V contains right eigenvectors; = 'L': V contains left eigenvectors.</p>
<p>N (input) INTEGER The number of rows of the matrix V. N &gt;= 0.</p>
<p>ILO (input) INTEGER IHI (input) INTEGER The integers ILO and IHI determined by DGGBAL. 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.</p>
<p>LSCALE (input) DOUBLE PRECISION array, dimension (N) Details of the permutations and/or scaling factors applied to the left side of A and B, as returned by DGGBAL.</p>
<p>RSCALE (input) DOUBLE PRECISION array, dimension (N) Details of the permutations and/or scaling factors applied to the right side of A and B, as returned by DGGBAL.</p>
<p>M (input) INTEGER The number of columns of the matrix V. M &gt;= 0.</p>
<p>V (input/output) DOUBLE PRECISION array, dimension (LDV,M) On entry, the matrix of right or left eigenvectors to be transformed, as returned by DTGEVC. On exit, V is overwritten by the transformed eigenvectors.</p>
<p>LDV (input) INTEGER The leading dimension of the matrix V. LDV &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>See R.C. Ward, Balancing the generalized eigenvalue problem, SIAM J. Sci. Stat. Comp. 2 (1981), 141-152. </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa44dfe07a23e79c1ac034b65d50f39b7_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa436205e359ff4b15b7a7c62afbba9d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGBAL </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGBAL balances a pair of general real matrices (A,B). This involves, first, permuting A and B by similarity transformations to isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N elements on the diagonal; and second, applying a diagonal similarity transformation to rows and columns ILO to IHI to make the rows and columns as close in norm as possible. Both steps are optional.</p>
<p>Balancing may reduce the 1-norm of the matrices, and improve the accuracy of the computed eigenvalues and/or eigenvectors in the generalized eigenvalue problem A*x = lambda*B*x.</p>
<h1>Arguments</h1>
<p>JOB (input) CHARACTER*1 Specifies the operations to be performed on A and B: = 'N': none: simply set ILO = 1, IHI = N, LSCALE(I) = 1.0 and RSCALE(I) = 1.0 for i = 1,...,N. = 'P': permute only; = 'S': scale only; = 'B': both permute and scale.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the input matrix A. On exit, A is overwritten by the balanced matrix. If JOB = 'N', A is not referenced.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,N) On entry, the input matrix B. On exit, B is overwritten by the balanced matrix. If JOB = 'N', B is not referenced.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>ILO (output) INTEGER IHI (output) INTEGER ILO and IHI are set to integers such that on exit A(i,j) = 0 and B(i,j) = 0 if i &gt; j and j = 1,...,ILO-1 or i = IHI+1,...,N. If JOB = 'N' or 'S', ILO = 1 and IHI = N.</p>
<p>LSCALE (output) DOUBLE PRECISION array, dimension (N) Details of the permutations and scaling factors applied to the left side of A and B. If P(j) is the index of the row interchanged with row j, and D(j) is the scaling factor applied to row j, then LSCALE(j) = P(j) for J = 1,...,ILO-1 = D(j) for J = ILO,...,IHI = P(j) for J = IHI+1,...,N. The order in which the interchanges are made is N to IHI+1, then 1 to ILO-1.</p>
<p>RSCALE (output) DOUBLE PRECISION array, dimension (N) Details of the permutations and scaling factors applied to the right side of A and B. If P(j) is the index of the column interchanged with column j, and D(j) is the scaling factor applied to column j, then LSCALE(j) = P(j) for J = 1,...,ILO-1 = D(j) for J = ILO,...,IHI = P(j) for J = IHI+1,...,N. The order in which the interchanges are made is N to IHI+1, then 1 to ILO-1.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (lwork) lwork must be at least max(1,6*N) when JOB = 'S' or 'B', and at least 1 when JOB = 'N' or 'P'.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>See R.C. WARD, Balancing the generalized eigenvalue problem, SIAM J. Sci. Stat. Comp. 2 (1981), 141-152. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa436205e359ff4b15b7a7c62afbba9d5_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7babb072640ba2fda26440d1d5d7735a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGES </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B), the generalized eigenvalues, the generalized real Schur form (S,T), optionally, the left and/or right matrices of Schur vectors (VSL and VSR). This gives the generalized Schur factorization </p>
<pre class="fragment">     (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
</pre><p>Optionally, it also orders the eigenvalues so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper quasi-triangular matrix S and the upper triangular matrix T.The leading columns of VSL and VSR then form an orthonormal basis for the corresponding left and right eigenspaces (deflating subspaces).</p>
<p>(If only the generalized eigenvalues are needed, use the driver DGGEV instead, which is faster.)</p>
<p>A generalized eigenvalue for a pair of matrices (A,B) is a scalar w or a ratio alpha/beta = w, such that A - w*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0 or both being zero.</p>
<p>A pair of matrices (S,T) is in generalized real Schur form if T is upper triangular with non-negative diagonal and S is block upper triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond to real generalized eigenvalues, while 2-by-2 blocks of S will be "standardized" by making the corresponding elements of T have the form: [ a 0 ] [ 0 b ]</p>
<p>and the pair of corresponding 2-by-2 blocks in S and T will have a complex conjugate pair of generalized eigenvalues.</p>
<h1>Arguments</h1>
<p>JOBVSL (input) CHARACTER*1 = 'N': do not compute the left Schur vectors; = 'V': compute the left Schur vectors.</p>
<p>JOBVSR (input) CHARACTER*1 = 'N': do not compute the right Schur vectors; = 'V': compute the right Schur vectors.</p>
<p>SORT (input) CHARACTER*1 Specifies whether or not to order the eigenvalues on the diagonal of the generalized Schur form. = 'N': Eigenvalues are not ordered; = 'S': Eigenvalues are ordered (see SELCTG);</p>
<p>SELCTG (external procedure) LOGICAL FUNCTION of three DOUBLE PRECISION arguments SELCTG must be declared EXTERNAL in the calling subroutine. If SORT = 'N', SELCTG is not referenced. If SORT = 'S', SELCTG is used to select eigenvalues to sort to the top left of the Schur form. An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either one of a complex conjugate pair of eigenvalues is selected, then both complex eigenvalues are selected.</p>
<p>Note that in the ill-conditioned case, a selected complex eigenvalue may no longer satisfy SELCTG(ALPHAR(j),ALPHAI(j), BETA(j)) = .TRUE. after ordering. INFO is to be set to N+2 in this case.</p>
<p>N (input) INTEGER The order of the matrices A, B, VSL, and VSR. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the first of the pair of matrices. On exit, A has been overwritten by its generalized Schur form S.</p>
<p>LDA (input) INTEGER The leading dimension of A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB, N) On entry, the second of the pair of matrices. On exit, B has been overwritten by its generalized Schur form T.</p>
<p>LDB (input) INTEGER The leading dimension of B. LDB &gt;= max(1,N).</p>
<p>SDIM (output) INTEGER If SORT = 'N', SDIM = 0. If SORT = 'S', SDIM = number of eigenvalues (after sorting) for which SELCTG is true. (Complex conjugate pairs for which SELCTG is true for either eigenvalue count as 2.)</p>
<p>ALPHAR (output) DOUBLE PRECISION array, dimension (N) ALPHAI (output) DOUBLE PRECISION array, dimension (N) BETA (output) DOUBLE PRECISION array, dimension (N) On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will be the generalized eigenvalues. ALPHAR(j) + ALPHAI(j)*i, and BETA(j),j=1,...,N are the diagonals of the complex Schur form (S,T) that would result if the 2-by-2 diagonal blocks of the real Schur form of (A,B) were further reduced to triangular form using 2-by-2 complex unitary transformations. If ALPHAI(j) is zero, then the j-th eigenvalue is real; if positive, then the j-th and (j+1)-st eigenvalues are a complex conjugate pair, with ALPHAI(j+1) negative.</p>
<p>Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j) may easily over- or underflow, and BETA(j) may even be zero. Thus, the user should avoid naively computing the ratio. However, ALPHAR and ALPHAI will be always less than and usually comparable with norm(A) in magnitude, and BETA always less than and usually comparable with norm(B).</p>
<p>VSL (output) DOUBLE PRECISION array, dimension (LDVSL,N) If JOBVSL = 'V', VSL will contain the left Schur vectors. Not referenced if JOBVSL = 'N'.</p>
<p>LDVSL (input) INTEGER The leading dimension of the matrix VSL. LDVSL &gt;=1, and if JOBVSL = 'V', LDVSL &gt;= N.</p>
<p>VSR (output) DOUBLE PRECISION array, dimension (LDVSR,N) If JOBVSR = 'V', VSR will contain the right Schur vectors. Not referenced if JOBVSR = 'N'.</p>
<p>LDVSR (input) INTEGER The leading dimension of the matrix VSR. LDVSR &gt;= 1, and if JOBVSR = 'V', LDVSR &gt;= N.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If N = 0, LWORK &gt;= 1, else LWORK &gt;= 8*N+16. For good performance , LWORK must generally be larger.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>BWORK (workspace) LOGICAL array, dimension (N) Not referenced if SORT = 'N'.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. = 1,...,N: The QZ iteration failed. (A,B) are not in Schur form, but ALPHAR(j), ALPHAI(j), and BETA(j) should be correct for j=INFO+1,...,N. &gt; N: =N+1: other than QZ iteration failed in DHGEQZ. =N+2: after reordering, roundoff changed values of some complex eigenvalues so that leading eigenvalues in the Generalized Schur form no longer satisfy SELCTG=.TRUE. This could also be caused due to scaling. =N+3: reordering failed in DTGSEN. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a7babb072640ba2fda26440d1d5d7735a_icgraph.svg" width="296" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5e7f1325fc6882fb79110a23ff4e8e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGESX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rconde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcondv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGESX computes for a pair of N-by-N real nonsymmetric matrices (A,B), the generalized eigenvalues, the real Schur form (S,T), and, optionally, the left and/or right matrices of Schur vectors (VSL and VSR). This gives the generalized Schur factorization </p>
<pre class="fragment"> (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )
</pre><p>Optionally, it also orders the eigenvalues so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper quasi-triangular matrix S and the upper triangular matrix T; computes a reciprocal condition number for the average of the selected eigenvalues (RCONDE); and computes a reciprocal condition number for the right and left deflating subspaces corresponding to the selected eigenvalues (RCONDV). The leading columns of VSL and VSR then form an orthonormal basis for the corresponding left and right eigenspaces (deflating subspaces).</p>
<p>A generalized eigenvalue for a pair of matrices (A,B) is a scalar w or a ratio alpha/beta = w, such that A - w*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0 or for both being zero.</p>
<p>A pair of matrices (S,T) is in generalized real Schur form if T is upper triangular with non-negative diagonal and S is block upper triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond to real generalized eigenvalues, while 2-by-2 blocks of S will be "standardized" by making the corresponding elements of T have the form: [ a 0 ] [ 0 b ]</p>
<p>and the pair of corresponding 2-by-2 blocks in S and T will have a complex conjugate pair of generalized eigenvalues.</p>
<h1>Arguments</h1>
<p>JOBVSL (input) CHARACTER*1 = 'N': do not compute the left Schur vectors; = 'V': compute the left Schur vectors.</p>
<p>JOBVSR (input) CHARACTER*1 = 'N': do not compute the right Schur vectors; = 'V': compute the right Schur vectors.</p>
<p>SORT (input) CHARACTER*1 Specifies whether or not to order the eigenvalues on the diagonal of the generalized Schur form. = 'N': Eigenvalues are not ordered; = 'S': Eigenvalues are ordered (see SELCTG).</p>
<p>SELCTG (external procedure) LOGICAL FUNCTION of three DOUBLE PRECISION arguments SELCTG must be declared EXTERNAL in the calling subroutine. If SORT = 'N', SELCTG is not referenced. If SORT = 'S', SELCTG is used to select eigenvalues to sort to the top left of the Schur form. An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either one of a complex conjugate pair of eigenvalues is selected, then both complex eigenvalues are selected. Note that a selected complex eigenvalue may no longer satisfy SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) = .TRUE. after ordering, since ordering may change the value of complex eigenvalues (especially if the eigenvalue is ill-conditioned), in this case INFO is set to N+3.</p>
<p>SENSE (input) CHARACTER*1 Determines which reciprocal condition numbers are computed. = 'N' : None are computed; = 'E' : Computed for average of selected eigenvalues only; = 'V' : Computed for selected deflating subspaces only; = 'B' : Computed for both. If SENSE = 'E', 'V', or 'B', SORT must equal 'S'.</p>
<p>N (input) INTEGER The order of the matrices A, B, VSL, and VSR. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the first of the pair of matrices. On exit, A has been overwritten by its generalized Schur form S.</p>
<p>LDA (input) INTEGER The leading dimension of A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB, N) On entry, the second of the pair of matrices. On exit, B has been overwritten by its generalized Schur form T.</p>
<p>LDB (input) INTEGER The leading dimension of B. LDB &gt;= max(1,N).</p>
<p>SDIM (output) INTEGER If SORT = 'N', SDIM = 0. If SORT = 'S', SDIM = number of eigenvalues (after sorting) for which SELCTG is true. (Complex conjugate pairs for which SELCTG is true for either eigenvalue count as 2.)</p>
<p>ALPHAR (output) DOUBLE PRECISION array, dimension (N) ALPHAI (output) DOUBLE PRECISION array, dimension (N) BETA (output) DOUBLE PRECISION array, dimension (N) On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will be the generalized eigenvalues. ALPHAR(j) + ALPHAI(j)*i and BETA(j),j=1,...,N are the diagonals of the complex Schur form (S,T) that would result if the 2-by-2 diagonal blocks of the real Schur form of (A,B) were further reduced to triangular form using 2-by-2 complex unitary transformations. If ALPHAI(j) is zero, then the j-th eigenvalue is real; if positive, then the j-th and (j+1)-st eigenvalues are a complex conjugate pair, with ALPHAI(j+1) negative.</p>
<p>Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j) may easily over- or underflow, and BETA(j) may even be zero. Thus, the user should avoid naively computing the ratio. However, ALPHAR and ALPHAI will be always less than and usually comparable with norm(A) in magnitude, and BETA always less than and usually comparable with norm(B).</p>
<p>VSL (output) DOUBLE PRECISION array, dimension (LDVSL,N) If JOBVSL = 'V', VSL will contain the left Schur vectors. Not referenced if JOBVSL = 'N'.</p>
<p>LDVSL (input) INTEGER The leading dimension of the matrix VSL. LDVSL &gt;=1, and if JOBVSL = 'V', LDVSL &gt;= N.</p>
<p>VSR (output) DOUBLE PRECISION array, dimension (LDVSR,N) If JOBVSR = 'V', VSR will contain the right Schur vectors. Not referenced if JOBVSR = 'N'.</p>
<p>LDVSR (input) INTEGER The leading dimension of the matrix VSR. LDVSR &gt;= 1, and if JOBVSR = 'V', LDVSR &gt;= N.</p>
<p>RCONDE (output) DOUBLE PRECISION array, dimension ( 2 ) If SENSE = 'E' or 'B', RCONDE(1) and RCONDE(2) contain the reciprocal condition numbers for the average of the selected eigenvalues. Not referenced if SENSE = 'N' or 'V'.</p>
<p>RCONDV (output) DOUBLE PRECISION array, dimension ( 2 ) If SENSE = 'V' or 'B', RCONDV(1) and RCONDV(2) contain the reciprocal condition numbers for the selected deflating subspaces. Not referenced if SENSE = 'N' or 'E'.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If N = 0, LWORK &gt;= 1, else if SENSE = 'E', 'V', or 'B', LWORK &gt;= max( 8*N, 6*N+16, 2*SDIM*(N-SDIM) ), else LWORK &gt;= max( 8*N, 6*N+16 ). Note that 2*SDIM*(N-SDIM) &lt;= N*N/2. Note also that an error is only returned if LWORK &lt; max( 8*N, 6*N+16), but if SENSE = 'E' or 'V' or 'B' this may not be large enough.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the bound on the optimal size of the WORK array and the minimum size of the IWORK array, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>IWORK (workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. If SENSE = 'N' or N = 0, LIWORK &gt;= 1, otherwise LIWORK &gt;= N+6.</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the bound on the optimal size of the WORK array and the minimum size of the IWORK array, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>BWORK (workspace) LOGICAL array, dimension (N) Not referenced if SORT = 'N'.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. = 1,...,N: The QZ iteration failed. (A,B) are not in Schur form, but ALPHAR(j), ALPHAI(j), and BETA(j) should be correct for j=INFO+1,...,N. &gt; N: =N+1: other than QZ iteration failed in DHGEQZ =N+2: after reordering, roundoff changed values of some complex eigenvalues so that leading eigenvalues in the Generalized Schur form no longer satisfy SELCTG=.TRUE. This could also be caused due to scaling. =N+3: reordering failed in DTGSEN.</p>
<h1>Further Details</h1>
<p>An approximate (asymptotic) bound on the average absolute error of the selected eigenvalues is </p>
<pre class="fragment"> EPS * norm((A, B)) / RCONDE( 1 ).
</pre><p>An approximate (asymptotic) bound on the maximum angular error in the computed deflating subspaces is </p>
<pre class="fragment"> EPS * norm((A, B)) / RCONDV( 2 ).
</pre><p>See LAPACK User's Guide, section 4.11 for more information. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a5e7f1325fc6882fb79110a23ff4e8e13_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="abeaeec7f98dffa1357f2fb803e586c49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGEV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B) the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors.</p>
<p>A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta = lambda, such that A - lambda*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0, and even for both being zero.</p>
<p>The right eigenvector v(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies </p>
<pre class="fragment">             A * v(j) = lambda(j) * B * v(j).
</pre><p>The left eigenvector u(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies </p>
<pre class="fragment">             u(j)**H * A  = lambda(j) * u(j)**H * B .
</pre><p>where u(j)**H is the conjugate-transpose of u(j).</p>
<h1>Arguments</h1>
<p>JOBVL (input) CHARACTER*1 = 'N': do not compute the left generalized eigenvectors; = 'V': compute the left generalized eigenvectors.</p>
<p>JOBVR (input) CHARACTER*1 = 'N': do not compute the right generalized eigenvectors; = 'V': compute the right generalized eigenvectors.</p>
<p>N (input) INTEGER The order of the matrices A, B, VL, and VR. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the matrix A in the pair (A,B). On exit, A has been overwritten.</p>
<p>LDA (input) INTEGER The leading dimension of A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB, N) On entry, the matrix B in the pair (A,B). On exit, B has been overwritten.</p>
<p>LDB (input) INTEGER The leading dimension of B. LDB &gt;= max(1,N).</p>
<p>ALPHAR (output) DOUBLE PRECISION array, dimension (N) ALPHAI (output) DOUBLE PRECISION array, dimension (N) BETA (output) DOUBLE PRECISION array, dimension (N) On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will be the generalized eigenvalues. If ALPHAI(j) is zero, then the j-th eigenvalue is real; if positive, then the j-th and (j+1)-st eigenvalues are a complex conjugate pair, with ALPHAI(j+1) negative.</p>
<p>Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j) may easily over- or underflow, and BETA(j) may even be zero. Thus, the user should avoid naively computing the ratio alpha/beta. However, ALPHAR and ALPHAI will be always less than and usually comparable with norm(A) in magnitude, and BETA always less than and usually comparable with norm(B).</p>
<p>VL (output) DOUBLE PRECISION array, dimension (LDVL,N) If JOBVL = 'V', the left eigenvectors u(j) are stored one after another in the columns of VL, in the same order as their eigenvalues. If the j-th eigenvalue is real, then u(j) = VL(:,j), the j-th column of VL. If the j-th and (j+1)-th eigenvalues form a complex conjugate pair, then u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1). Each eigenvector is scaled so the largest component has abs(real part)+abs(imag. part)=1. Not referenced if JOBVL = 'N'.</p>
<p>LDVL (input) INTEGER The leading dimension of the matrix VL. LDVL &gt;= 1, and if JOBVL = 'V', LDVL &gt;= N.</p>
<p>VR (output) DOUBLE PRECISION array, dimension (LDVR,N) If JOBVR = 'V', the right eigenvectors v(j) are stored one after another in the columns of VR, in the same order as their eigenvalues. If the j-th eigenvalue is real, then v(j) = VR(:,j), the j-th column of VR. If the j-th and (j+1)-th eigenvalues form a complex conjugate pair, then v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1). Each eigenvector is scaled so the largest component has abs(real part)+abs(imag. part)=1. Not referenced if JOBVR = 'N'.</p>
<p>LDVR (input) INTEGER The leading dimension of the matrix VR. LDVR &gt;= 1, and if JOBVR = 'V', LDVR &gt;= N.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,8*N). For good performance, LWORK must generally be larger.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. = 1,...,N: The QZ iteration failed. No eigenvectors have been calculated, but ALPHAR(j), ALPHAI(j), and BETA(j) should be correct for j=INFO+1,...,N. &gt; N: =N+1: other than QZ iteration failed in DHGEQZ. =N+2: error return from DTGEVC. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_abeaeec7f98dffa1357f2fb803e586c49_icgraph.svg" width="296" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8d405d44f7f53f87f94421236062fce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGEVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>balanc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>abnrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bbnrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rconde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcondv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B) the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors.</p>
<p>Optionally also, it computes a balancing transformation to improve the conditioning of the eigenvalues and eigenvectors (ILO, IHI, LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for the eigenvalues (RCONDE), and reciprocal condition numbers for the right eigenvectors (RCONDV).</p>
<p>A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta = lambda, such that A - lambda*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0, and even for both being zero.</p>
<p>The right eigenvector v(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies </p>
<pre class="fragment">             A * v(j) = lambda(j) * B * v(j) .
</pre><p>The left eigenvector u(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies </p>
<pre class="fragment">             u(j)**H * A  = lambda(j) * u(j)**H * B.
</pre><p>where u(j)**H is the conjugate-transpose of u(j).</p>
<h1>Arguments</h1>
<p>BALANC (input) CHARACTER*1 Specifies the balance option to be performed. = 'N': do not diagonally scale or permute; = 'P': permute only; = 'S': scale only; = 'B': both permute and scale. Computed reciprocal condition numbers will be for the matrices after permuting and/or balancing. Permuting does not change condition numbers (in exact arithmetic), but balancing does.</p>
<p>JOBVL (input) CHARACTER*1 = 'N': do not compute the left generalized eigenvectors; = 'V': compute the left generalized eigenvectors.</p>
<p>JOBVR (input) CHARACTER*1 = 'N': do not compute the right generalized eigenvectors; = 'V': compute the right generalized eigenvectors.</p>
<p>SENSE (input) CHARACTER*1 Determines which reciprocal condition numbers are computed. = 'N': none are computed; = 'E': computed for eigenvalues only; = 'V': computed for eigenvectors only; = 'B': computed for eigenvalues and eigenvectors.</p>
<p>N (input) INTEGER The order of the matrices A, B, VL, and VR. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the matrix A in the pair (A,B). On exit, A has been overwritten. If JOBVL='V' or JOBVR='V' or both, then A contains the first part of the real Schur form of the "balanced" versions of the input A and B.</p>
<p>LDA (input) INTEGER The leading dimension of A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB, N) On entry, the matrix B in the pair (A,B). On exit, B has been overwritten. If JOBVL='V' or JOBVR='V' or both, then B contains the second part of the real Schur form of the "balanced" versions of the input A and B.</p>
<p>LDB (input) INTEGER The leading dimension of B. LDB &gt;= max(1,N).</p>
<p>ALPHAR (output) DOUBLE PRECISION array, dimension (N) ALPHAI (output) DOUBLE PRECISION array, dimension (N) BETA (output) DOUBLE PRECISION array, dimension (N) On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will be the generalized eigenvalues. If ALPHAI(j) is zero, then the j-th eigenvalue is real; if positive, then the j-th and (j+1)-st eigenvalues are a complex conjugate pair, with ALPHAI(j+1) negative.</p>
<p>Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j) may easily over- or underflow, and BETA(j) may even be zero. Thus, the user should avoid naively computing the ratio ALPHA/BETA. However, ALPHAR and ALPHAI will be always less than and usually comparable with norm(A) in magnitude, and BETA always less than and usually comparable with norm(B).</p>
<p>VL (output) DOUBLE PRECISION array, dimension (LDVL,N) If JOBVL = 'V', the left eigenvectors u(j) are stored one after another in the columns of VL, in the same order as their eigenvalues. If the j-th eigenvalue is real, then u(j) = VL(:,j), the j-th column of VL. If the j-th and (j+1)-th eigenvalues form a complex conjugate pair, then u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1). Each eigenvector will be scaled so the largest component have abs(real part) + abs(imag. part) = 1. Not referenced if JOBVL = 'N'.</p>
<p>LDVL (input) INTEGER The leading dimension of the matrix VL. LDVL &gt;= 1, and if JOBVL = 'V', LDVL &gt;= N.</p>
<p>VR (output) DOUBLE PRECISION array, dimension (LDVR,N) If JOBVR = 'V', the right eigenvectors v(j) are stored one after another in the columns of VR, in the same order as their eigenvalues. If the j-th eigenvalue is real, then v(j) = VR(:,j), the j-th column of VR. If the j-th and (j+1)-th eigenvalues form a complex conjugate pair, then v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1). Each eigenvector will be scaled so the largest component have abs(real part) + abs(imag. part) = 1. Not referenced if JOBVR = 'N'.</p>
<p>LDVR (input) INTEGER The leading dimension of the matrix VR. LDVR &gt;= 1, and if JOBVR = 'V', LDVR &gt;= N.</p>
<p>ILO (output) INTEGER IHI (output) INTEGER ILO and IHI are integer values such that on exit A(i,j) = 0 and B(i,j) = 0 if i &gt; j and j = 1,...,ILO-1 or i = IHI+1,...,N. If BALANC = 'N' or 'S', ILO = 1 and IHI = N.</p>
<p>LSCALE (output) DOUBLE PRECISION array, dimension (N) Details of the permutations and scaling factors applied to the left side of A and B. If PL(j) is the index of the row interchanged with row j, and DL(j) is the scaling factor applied to row j, then LSCALE(j) = PL(j) for j = 1,...,ILO-1 = DL(j) for j = ILO,...,IHI = PL(j) for j = IHI+1,...,N. The order in which the interchanges are made is N to IHI+1, then 1 to ILO-1.</p>
<p>RSCALE (output) DOUBLE PRECISION array, dimension (N) Details of the permutations and scaling factors applied to the right side of A and B. If PR(j) is the index of the column interchanged with column j, and DR(j) is the scaling factor applied to column j, then RSCALE(j) = PR(j) for j = 1,...,ILO-1 = DR(j) for j = ILO,...,IHI = PR(j) for j = IHI+1,...,N The order in which the interchanges are made is N to IHI+1, then 1 to ILO-1.</p>
<p>ABNRM (output) DOUBLE PRECISION The one-norm of the balanced matrix A.</p>
<p>BBNRM (output) DOUBLE PRECISION The one-norm of the balanced matrix B.</p>
<p>RCONDE (output) DOUBLE PRECISION array, dimension (N) If SENSE = 'E' or 'B', the reciprocal condition numbers of the eigenvalues, stored in consecutive elements of the array. For a complex conjugate pair of eigenvalues two consecutive elements of RCONDE are set to the same value. Thus RCONDE(j), RCONDV(j), and the j-th columns of VL and VR all correspond to the j-th eigenpair. If SENSE = 'N or 'V', RCONDE is not referenced.</p>
<p>RCONDV (output) DOUBLE PRECISION array, dimension (N) If SENSE = 'V' or 'B', the estimated reciprocal condition numbers of the eigenvectors, stored in consecutive elements of the array. For a complex eigenvector two consecutive elements of RCONDV are set to the same value. If the eigenvalues cannot be reordered to compute RCONDV(j), RCONDV(j) is set to 0; this can only occur when the true value would be very small anyway. If SENSE = 'N' or 'E', RCONDV is not referenced.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,2*N). If BALANC = 'S' or 'B', or JOBVL = 'V', or JOBVR = 'V', LWORK &gt;= max(1,6*N). If SENSE = 'E' or 'B', LWORK &gt;= max(1,10*N). If SENSE = 'V' or 'B', LWORK &gt;= 2*N*N+8*N+16.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace) INTEGER array, dimension (N+6) If SENSE = 'E', IWORK is not referenced.</p>
<p>BWORK (workspace) LOGICAL array, dimension (N) If SENSE = 'N', BWORK is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. = 1,...,N: The QZ iteration failed. No eigenvectors have been calculated, but ALPHAR(j), ALPHAI(j), and BETA(j) should be correct for j=INFO+1,...,N. &gt; N: =N+1: other than QZ iteration failed in DHGEQZ. =N+2: error return from DTGEVC.</p>
<h1>Further Details</h1>
<p>Balancing a matrix pair (A,B) includes, first, permuting rows and columns to isolate eigenvalues, second, applying diagonal similarity transformation to the rows and columns to make the rows and columns as close in norm as possible. The computed reciprocal condition numbers correspond to the balanced matrix. Permuting rows and columns will not change the condition numbers (in exact arithmetic) but diagonal scaling will. For further explanation of balancing, see section 4.11.1.2 of LAPACK Users' Guide.</p>
<p>An approximate error bound on the chordal distance between the i-th computed generalized eigenvalue w and the corresponding exact eigenvalue lambda is </p>
<pre class="fragment"> chord(w, lambda) &lt;= EPS * norm(ABNRM, BBNRM) / RCONDE(I)
</pre><p>An approximate error bound for the angle between the i-th computed eigenvector VL(i) or VR(i) is given by </p>
<pre class="fragment"> EPS * norm(ABNRM, BBNRM) / DIF(i).
</pre><p>For further explanation of the reciprocal condition numbers RCONDE and RCONDV, see section 4.11 of LAPACK User's Guide. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a8d405d44f7f53f87f94421236062fce8_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a56a25b99190d84886d4037fa09c86f9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGGLM </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGGLM solves a general Gauss-Markov linear model (GLM) problem: </p>
<pre class="fragment">    minimize || y ||_2   subject to   d = A*x + B*y
        x
</pre><p>where A is an N-by-M matrix, B is an N-by-P matrix, and d is a given N-vector. It is assumed that M &lt;= N &lt;= M+P, and </p>
<pre class="fragment">       rank(A) = M    and    rank( A B ) = N.
</pre><p>Under these assumptions, the constrained equation is always consistent, and there is a unique solution x and a minimal 2-norm solution y, which is obtained using a generalized <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of the matrices (A, B) given by</p>
<p>A = Q*(R), B = Q*T*Z. (0)</p>
<p>In particular, if matrix B is square nonsingular, then the problem GLM is equivalent to the following weighted linear least squares problem </p>
<pre class="fragment">         minimize || inv(B)*(d-A*x) ||_2
             x
</pre><p>where inv(B) denotes the inverse of B.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The number of rows of the matrices A and B. N &gt;= 0.</p>
<p>M (input) INTEGER The number of columns of the matrix A. 0 &lt;= M &lt;= N.</p>
<p>P (input) INTEGER The number of columns of the matrix B. P &gt;= N-M.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,M) On entry, the N-by-M matrix A. On exit, the upper triangular part of the array A contains the M-by-M upper triangular matrix R.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,P) On entry, the N-by-P matrix B. On exit, if N &lt;= P, the upper triangle of the subarray B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T; if N &gt; P, the elements on and above the (N-P)th subdiagonal contain the N-by-P upper trapezoidal matrix T.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, D is the left hand side of the GLM equation. On exit, D is destroyed.</p>
<p>X (output) DOUBLE PRECISION array, dimension (M) Y (output) DOUBLE PRECISION array, dimension (P) On exit, X and Y are the solutions of the GLM problem.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N+M+P). For optimum performance, LWORK &gt;= M+min(N,P)+max(N,P)*NB, where NB is an upper bound for the optimal blocksizes for DGEQRF, SGERQF, DORMQR and SORMRQ.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. = 1: the upper triangular factor R associated with A in the generalized <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of the pair (A, B) is singular, so that rank(A) &lt; M; the least squares solution could not be computed. = 2: the bottom (N-M) by (N-M) part of the upper trapezoidal factor T associated with B in the generalized <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of the pair (A, B) is singular, so that rank( A B ) &lt; N; the least squares solution could not be computed. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a56a25b99190d84886d4037fa09c86f9c_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8f6e4407d2b59a7915c4e536d489d709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGHRD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGHRD reduces a pair of real matrices (A,B) to generalized upper Hessenberg form using orthogonal transformations, where A is a general matrix and B is upper triangular. The form of the generalized eigenvalue problem is A*x = lambda*B*x, and B is typically made upper triangular by computing its <a class="el" href="classpsi_1_1QR.html">QR</a> factorization and moving the orthogonal matrix Q to the left side of the equation.</p>
<p>This subroutine simultaneously reduces A to a Hessenberg matrix H: Q**T*A*Z = H and transforms B to another upper triangular matrix T: Q**T*B*Z = T in order to reduce the problem to its standard form H*y = lambda*T*y where y = Z**T*x.</p>
<p>The orthogonal matrices Q and Z are determined as products of Givens rotations. They may either be formed explicitly, or they may be postmultiplied into input matrices Q1 and Z1, so that </p>
<pre class="fragment"> Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T

 Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
</pre><p>If Q1 is the orthogonal matrix from the <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of B in the original equation A*x = lambda*B*x, then DGGHRD reduces the original problem to generalized Hessenberg form.</p>
<h1>Arguments</h1>
<p>COMPQ (input) CHARACTER*1 = 'N': do not compute Q; = 'I': Q is initialized to the unit matrix, and the orthogonal matrix Q is returned; = 'V': Q must contain an orthogonal matrix Q1 on entry, and the product Q1*Q is returned.</p>
<p>COMPZ (input) CHARACTER*1 = 'N': do not compute Z; = 'I': Z is initialized to the unit matrix, and the orthogonal matrix Z is returned; = 'V': Z must contain an orthogonal matrix Z1 on entry, and the product Z1*Z is returned.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>ILO (input) INTEGER IHI (input) INTEGER ILO and IHI mark the rows and columns of A which are to be reduced. It is assumed that A is already upper triangular in rows and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally set by a previous call to SGGBAL; otherwise they should be set to 1 and N respectively. 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the N-by-N general matrix to be reduced. On exit, the upper triangle and the first subdiagonal of A are overwritten with the upper Hessenberg matrix H, and the rest is set to zero.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB, N) On entry, the N-by-N upper triangular matrix B. On exit, the upper triangular matrix T = Q**T B Z. The elements below the diagonal are set to zero.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>Q (input/output) DOUBLE PRECISION array, dimension (LDQ, N) On entry, if COMPQ = 'V', the orthogonal matrix Q1, typically from the <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of B. On exit, if COMPQ='I', the orthogonal matrix Q, and if COMPQ = 'V', the product Q1*Q. Not referenced if COMPQ='N'.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= N if COMPQ='V' or 'I'; LDQ &gt;= 1 otherwise.</p>
<p>Z (input/output) DOUBLE PRECISION array, dimension (LDZ, N) On entry, if COMPZ = 'V', the orthogonal matrix Z1. On exit, if COMPZ='I', the orthogonal matrix Z, and if COMPZ = 'V', the product Z1*Z. Not referenced if COMPZ='N'.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= N if COMPZ='V' or 'I'; LDZ &gt;= 1 otherwise.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>This routine reduces A to Hessenberg and B to triangular form by an unblocked reduction, as described in <em>Matrix_Computations</em>, by Golub and Van Loan (Johns Hopkins Press.) </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a8f6e4407d2b59a7915c4e536d489d709_icgraph.svg" width="320" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a86040bfafdb726b01f7cfe5afebef987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGLSE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGLSE solves the linear equality-constrained least squares (LSE) problem: </p>
<pre class="fragment">    minimize || c - A*x ||_2   subject to   B*x = d
</pre><p>where A is an M-by-N matrix, B is a P-by-N matrix, c is a given M-vector, and d is a given P-vector. It is assumed that P &lt;= N &lt;= M+P, and </p>
<pre class="fragment">     rank(B) = P and  rank( (A) ) = N.
                          ( (B) )
</pre><p>These conditions ensure that the LSE problem has a unique solution, which is obtained using a generalized RQ factorization of the matrices (B, A) given by</p>
<p>B = (0 R)*Q, A = Z*T*Q.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrices A and B. N &gt;= 0.</p>
<p>P (input) INTEGER The number of rows of the matrix B. 0 &lt;= P &lt;= N &lt;= M+P.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, the elements on and above the diagonal of the array contain the min(M,N)-by-N upper trapezoidal matrix T.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,N) On entry, the P-by-N matrix B. On exit, the upper triangle of the subarray B(1:P,N-P+1:N) contains the P-by-P upper triangular matrix R.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,P).</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (M) On entry, C contains the right hand side vector for the least squares part of the LSE problem. On exit, the residual sum of squares for the solution is given by the sum of squares of elements N-P+1 to M of vector C.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (P) On entry, D contains the right hand side vector for the constrained equation. On exit, D is destroyed.</p>
<p>X (output) DOUBLE PRECISION array, dimension (N) On exit, X is the solution of the LSE problem.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,M+N+P). For optimum performance LWORK &gt;= P+min(M,N)+max(M,N)*NB, where NB is an upper bound for the optimal blocksizes for DGEQRF, SGERQF, DORMQR and SORMRQ.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. = 1: the upper triangular factor R associated with B in the generalized RQ factorization of the pair (B, A) is singular, so that rank(B) &lt; P; the least squares solution could not be computed. = 2: the (N-P) by (N-P) part of the upper trapezoidal factor T associated with A in the generalized RQ factorization of the pair (B, A) is singular, so that rank( (A) ) &lt; N; the least squares solution could not ( (B) ) be computed. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a86040bfafdb726b01f7cfe5afebef987_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a180f6035e86ceb038e3ca6f06fce6edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGQRF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>taua</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>taub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGQRF computes a generalized <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of an N-by-M matrix A and an N-by-P matrix B: </p>
<pre class="fragment">        A = Q*R,        B = Q*T*Z,
</pre><p>where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal matrix, and R and T assume one of the forms:</p>
<p>if N &gt;= M, R = ( R11 ) M , or if N &lt; M, R = ( R11 R12 ) N, ( 0 ) N-M N M-N M</p>
<p>where R11 is upper triangular, and</p>
<p>if N &lt;= P, T = ( 0 T12 ) N, or if N &gt; P, T = ( T11 ) N-P, P-N N ( T21 ) P P</p>
<p>where T12 or T21 is upper triangular.</p>
<p>In particular, if B is square and nonsingular, the GQR factorization of A and B implicitly gives the <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of inv(B)*A: </p>
<pre class="fragment">         inv(B)*A = Z'*(inv(T)*R)
</pre><p>where inv(B) denotes the inverse of the matrix B, and Z' denotes the transpose of the matrix Z.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The number of rows of the matrices A and B. N &gt;= 0.</p>
<p>M (input) INTEGER The number of columns of the matrix A. M &gt;= 0.</p>
<p>P (input) INTEGER The number of columns of the matrix B. P &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,M) On entry, the N-by-M matrix A. On exit, the elements on and above the diagonal of the array contain the min(N,M)-by-M upper trapezoidal matrix R (R is upper triangular if N &gt;= M); the elements below the diagonal, with the array TAUA, represent the orthogonal matrix Q as a product of min(N,M) elementary reflectors (see Further Details).</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>TAUA (output) DOUBLE PRECISION array, dimension (min(N,M)) The scalar factors of the elementary reflectors which represent the orthogonal matrix Q (see Further Details).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,P) On entry, the N-by-P matrix B. On exit, if N &lt;= P, the upper triangle of the subarray B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T; if N &gt; P, the elements on and above the (N-P)-th subdiagonal contain the N-by-P upper trapezoidal matrix T; the remaining elements, with the array TAUB, represent the orthogonal matrix Z as a product of elementary reflectors (see Further Details).</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>TAUB (output) DOUBLE PRECISION array, dimension (min(N,P)) The scalar factors of the elementary reflectors which represent the orthogonal matrix Z (see Further Details).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N,M,P). For optimum performance LWORK &gt;= max(N,M,P)*max(NB1,NB2,NB3), where NB1 is the optimal blocksize for the <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of an N-by-M matrix, NB2 is the optimal blocksize for the RQ factorization of an N-by-P matrix, and NB3 is the optimal blocksize for a call of DORMQR.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>The matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(k), where k = min(n,m).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - taua * v * v'</p>
<p>where taua is a real scalar, and v is a real vector with v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i+1:n,i), and taua in TAUA(i). To form Q explicitly, use LAPACK subroutine DORGQR. To use Q to update another matrix, use LAPACK subroutine DORMQR.</p>
<p>The matrix Z is represented as a product of elementary reflectors</p>
<p>Z = H(1) H(2) . . . H(k), where k = min(n,p).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - taub * v * v'</p>
<p>where taub is a real scalar, and v is a real vector with v(p-k+i+1:p) = 0 and v(p-k+i) = 1; v(1:p-k+i-1) is stored on exit in B(n-k+i,1:p-k+i-1), and taub in TAUB(i). To form Z explicitly, use LAPACK subroutine DORGRQ. To use Z to update another matrix, use LAPACK subroutine DORMRQ. </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a180f6035e86ceb038e3ca6f06fce6edc_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5e71b43f2237b766cf3ab8a5817f683e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGRQF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>taua</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>taub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGRQF computes a generalized RQ factorization of an M-by-N matrix A and a P-by-N matrix B: </p>
<pre class="fragment">        A = R*Q,        B = Z*T*Q,
</pre><p>where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal matrix, and R and T assume one of the forms:</p>
<p>if M &lt;= N, R = ( 0 R12 ) M, or if M &gt; N, R = ( R11 ) M-N, N-M M ( R21 ) N N</p>
<p>where R12 or R21 is upper triangular, and</p>
<p>if P &gt;= N, T = ( T11 ) N , or if P &lt; N, T = ( T11 T12 ) P, ( 0 ) P-N P N-P N</p>
<p>where T11 is upper triangular.</p>
<p>In particular, if B is square and nonsingular, the GRQ factorization of A and B implicitly gives the RQ factorization of A*inv(B): </p>
<pre class="fragment">         A*inv(B) = (R*inv(T))*Z'
</pre><p>where inv(B) denotes the inverse of the matrix B, and Z' denotes the transpose of the matrix Z.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>P (input) INTEGER The number of rows of the matrix B. P &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrices A and B. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, if M &lt;= N, the upper triangle of the subarray A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R; if M &gt; N, the elements on and above the (M-N)-th subdiagonal contain the M-by-N upper trapezoidal matrix R; the remaining elements, with the array TAUA, represent the orthogonal matrix Q as a product of elementary reflectors (see Further Details).</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAUA (output) DOUBLE PRECISION array, dimension (min(M,N)) The scalar factors of the elementary reflectors which represent the orthogonal matrix Q (see Further Details).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,N) On entry, the P-by-N matrix B. On exit, the elements on and above the diagonal of the array contain the min(P,N)-by-N upper trapezoidal matrix T (T is upper triangular if P &gt;= N); the elements below the diagonal, with the array TAUB, represent the orthogonal matrix Z as a product of elementary reflectors (see Further Details).</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,P).</p>
<p>TAUB (output) DOUBLE PRECISION array, dimension (min(P,N)) The scalar factors of the elementary reflectors which represent the orthogonal matrix Z (see Further Details).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N,M,P). For optimum performance LWORK &gt;= max(N,M,P)*max(NB1,NB2,NB3), where NB1 is the optimal blocksize for the RQ factorization of an M-by-N matrix, NB2 is the optimal blocksize for the <a class="el" href="classpsi_1_1QR.html">QR</a> factorization of a P-by-N matrix, and NB3 is the optimal blocksize for a call of DORMRQ.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INF0= -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>The matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(k), where k = min(m,n).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - taua * v * v'</p>
<p>where taua is a real scalar, and v is a real vector with v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in A(m-k+i,1:n-k+i-1), and taua in TAUA(i). To form Q explicitly, use LAPACK subroutine DORGRQ. To use Q to update another matrix, use LAPACK subroutine DORMRQ.</p>
<p>The matrix Z is represented as a product of elementary reflectors</p>
<p>Z = H(1) H(2) . . . H(k), where k = min(p,n).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - taub * v * v'</p>
<p>where taub is a real scalar, and v is a real vector with v(1:i-1) = 0 and v(i) = 1; v(i+1:p) is stored on exit in B(i+1:p,i), and taub in TAUB(i). To form Z explicitly, use LAPACK subroutine DORGQR. To use Z to update another matrix, use LAPACK subroutine DORMQR. </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a5e71b43f2237b766cf3ab8a5817f683e_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5c47752512130b7701d02342068c247a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGSVD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGSVD computes the generalized singular value decomposition (GSVD) of an M-by-N real matrix A and P-by-N real matrix B: </p>
<pre class="fragment">U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R )
</pre><p>where U, V and Q are orthogonal matrices, and Z' is the transpose of Z. Let K+L = the effective numerical rank of the matrix (A',B')', then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the following structures, respectively:</p>
<p>If M-K-L &gt;= 0, </p>
<pre class="fragment">                K  L
   D1 =     K ( I  0 )
            L ( 0  C )
        M-K-L ( 0  0 )

              K  L
   D2 =   L ( 0  S )
        P-L ( 0  0 )

            N-K-L  K    L
</pre><p> ( 0 R ) = K ( 0 R11 R12 ) L ( 0 0 R22 )</p>
<p>where</p>
<p>C = diag( ALPHA(K+1), ... , ALPHA(K+L) ), S = diag( BETA(K+1), ... , BETA(K+L) ), C**2 + S**2 = I.</p>
<p>R is stored in A(1:K+L,N-K-L+1:N) on exit.</p>
<p>If M-K-L &lt; 0, </p>
<pre class="fragment">              K M-K K+L-M
   D1 =   K ( I  0    0   )
        M-K ( 0  C    0   )

                K M-K K+L-M
   D2 =   M-K ( 0  S    0  )
        K+L-M ( 0  0    I  )
          P-L ( 0  0    0  )

               N-K-L  K   M-K  K+L-M
</pre><p> ( 0 R ) = K ( 0 R11 R12 R13 ) M-K ( 0 0 R22 R23 ) K+L-M ( 0 0 0 R33 )</p>
<p>where</p>
<p>C = diag( ALPHA(K+1), ... , ALPHA(M) ), S = diag( BETA(K+1), ... , BETA(M) ), C**2 + S**2 = I.</p>
<p>(R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored ( 0 R22 R23 ) in B(M-K+1:L,N+M-K-L+1:N) on exit.</p>
<p>The routine computes C, S, R, and optionally the orthogonal transformation matrices U, V and Q.</p>
<p>In particular, if B is an N-by-N nonsingular matrix, then the GSVD of A and B implicitly gives the SVD of A*inv(B): A*inv(B) = U*(D1*inv(D2))*V'. If ( A',B')' has orthonormal columns, then the GSVD of A and B is also equal to the CS decomposition of A and B. Furthermore, the GSVD can be used to derive the solution of the eigenvalue problem: A'<em>A x = lambda</em> B'*B x. In some literature, the GSVD of A and B is presented in the form U'*A*X = ( 0 D1 ), V'*B*X = ( 0 D2 ) where U and V are orthogonal and X is nonsingular, D1 and D2 are ``diagonal''. The former GSVD form can be converted to the latter form by taking the nonsingular matrix X as </p>
<pre class="fragment">                 X = Q*( I   0    )
                       ( 0 inv(R) ).
</pre><h1>Arguments</h1>
<p>JOBU (input) CHARACTER*1 = 'U': Orthogonal matrix U is computed; = 'N': U is not computed.</p>
<p>JOBV (input) CHARACTER*1 = 'V': Orthogonal matrix V is computed; = 'N': V is not computed.</p>
<p>JOBQ (input) CHARACTER*1 = 'Q': Orthogonal matrix Q is computed; = 'N': Q is not computed.</p>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrices A and B. N &gt;= 0.</p>
<p>P (input) INTEGER The number of rows of the matrix B. P &gt;= 0.</p>
<p>K (output) INTEGER L (output) INTEGER On exit, K and L specify the dimension of the subblocks described in the Purpose section. K + L = effective numerical rank of (A',B')'.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, A contains the triangular matrix R, or part of R. See Purpose for details.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,N) On entry, the P-by-N matrix B. On exit, B contains the triangular matrix R if M-K-L &lt; 0. See Purpose for details.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,P).</p>
<p>ALPHA (output) DOUBLE PRECISION array, dimension (N) BETA (output) DOUBLE PRECISION array, dimension (N) On exit, ALPHA and BETA contain the generalized singular value pairs of A and B; ALPHA(1:K) = 1, BETA(1:K) = 0, and if M-K-L &gt;= 0, ALPHA(K+1:K+L) = C, BETA(K+1:K+L) = S, or if M-K-L &lt; 0, ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0 BETA(K+1:M) =S, BETA(M+1:K+L) =1 and ALPHA(K+L+1:N) = 0 BETA(K+L+1:N) = 0</p>
<p>U (output) DOUBLE PRECISION array, dimension (LDU,M) If JOBU = 'U', U contains the M-by-M orthogonal matrix U. If JOBU = 'N', U is not referenced.</p>
<p>LDU (input) INTEGER The leading dimension of the array U. LDU &gt;= max(1,M) if JOBU = 'U'; LDU &gt;= 1 otherwise.</p>
<p>V (output) DOUBLE PRECISION array, dimension (LDV,P) If JOBV = 'V', V contains the P-by-P orthogonal matrix V. If JOBV = 'N', V is not referenced.</p>
<p>LDV (input) INTEGER The leading dimension of the array V. LDV &gt;= max(1,P) if JOBV = 'V'; LDV &gt;= 1 otherwise.</p>
<p>Q (output) DOUBLE PRECISION array, dimension (LDQ,N) If JOBQ = 'Q', Q contains the N-by-N orthogonal matrix Q. If JOBQ = 'N', Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= max(1,N) if JOBQ = 'Q'; LDQ &gt;= 1 otherwise.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (max(3*N,M,P)+N)</p>
<p>IWORK (workspace/output) INTEGER array, dimension (N) On exit, IWORK stores the sorting information. More precisely, the following loop will sort ALPHA for I = K+1, min(M,K+L) swap ALPHA(I) and ALPHA(IWORK(I)) endfor such that ALPHA(1) &gt;= ALPHA(2) &gt;= ... &gt;= ALPHA(N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if INFO = 1, the Jacobi-type procedure failed to converge. For further details, see subroutine DTGSJA.</p>
<h1>Internal Parameters</h1>
<p>TOLA DOUBLE PRECISION TOLB DOUBLE PRECISION TOLA and TOLB are the thresholds to determine the effective rank of (A',B')'. Generally, they are set to TOLA = MAX(M,N)*norm(A)*MAZHEPS, TOLB = MAX(P,N)*norm(B)*MAZHEPS. The size of TOLA and TOLB may affect the size of backward errors of the decomposition.</p>
<h1>Further Details</h1>
<p>2-96 Based on modifications by Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a5c47752512130b7701d02342068c247a_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a73ffa89e8a5538ddb36a49be7add1a15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGGSVP </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tola</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGGSVP computes orthogonal matrices U, V and Q such that </p>
<pre class="fragment">             N-K-L  K    L
</pre><p> U'*A*Q = K ( 0 A12 A13 ) if M-K-L &gt;= 0; L ( 0 0 A23 ) M-K-L ( 0 0 0 ) </p>
<pre class="fragment">   N-K-L  K    L
</pre><p> = K ( 0 A12 A13 ) if M-K-L &lt; 0; M-K ( 0 0 A23 )</p>
<p>N-K-L K L V'*B*Q = L ( 0 0 B13 ) P-L ( 0 0 0 )</p>
<p>where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular upper triangular; A23 is L-by-L upper triangular if M-K-L &gt;= 0, otherwise A23 is (M-K)-by-L upper trapezoidal. K+L = the effective numerical rank of the (M+P)-by-N matrix (A',B')'. Z' denotes the transpose of Z.</p>
<p>This decomposition is the preprocessing step for computing the Generalized Singular Value Decomposition (GSVD), see subroutine DGGSVD.</p>
<h1>Arguments</h1>
<p>JOBU (input) CHARACTER*1 = 'U': Orthogonal matrix U is computed; = 'N': U is not computed.</p>
<p>JOBV (input) CHARACTER*1 = 'V': Orthogonal matrix V is computed; = 'N': V is not computed.</p>
<p>JOBQ (input) CHARACTER*1 = 'Q': Orthogonal matrix Q is computed; = 'N': Q is not computed.</p>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>P (input) INTEGER The number of rows of the matrix B. P &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrices A and B. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, A contains the triangular (or trapezoidal) matrix described in the Purpose section.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,N) On entry, the P-by-N matrix B. On exit, B contains the triangular matrix described in the Purpose section.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,P).</p>
<p>TOLA (input) DOUBLE PRECISION TOLB (input) DOUBLE PRECISION TOLA and TOLB are the thresholds to determine the effective numerical rank of matrix B and a subblock of A. Generally, they are set to TOLA = MAX(M,N)*norm(A)*MAZHEPS, TOLB = MAX(P,N)*norm(B)*MAZHEPS. The size of TOLA and TOLB may affect the size of backward errors of the decomposition.</p>
<p>K (output) INTEGER L (output) INTEGER On exit, K and L specify the dimension of the subblocks described in Purpose. K + L = effective numerical rank of (A',B')'.</p>
<p>U (output) DOUBLE PRECISION array, dimension (LDU,M) If JOBU = 'U', U contains the orthogonal matrix U. If JOBU = 'N', U is not referenced.</p>
<p>LDU (input) INTEGER The leading dimension of the array U. LDU &gt;= max(1,M) if JOBU = 'U'; LDU &gt;= 1 otherwise.</p>
<p>V (output) DOUBLE PRECISION array, dimension (LDV,P) If JOBV = 'V', V contains the orthogonal matrix V. If JOBV = 'N', V is not referenced.</p>
<p>LDV (input) INTEGER The leading dimension of the array V. LDV &gt;= max(1,P) if JOBV = 'V'; LDV &gt;= 1 otherwise.</p>
<p>Q (output) DOUBLE PRECISION array, dimension (LDQ,N) If JOBQ = 'Q', Q contains the orthogonal matrix Q. If JOBQ = 'N', Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= max(1,N) if JOBQ = 'Q'; LDQ &gt;= 1 otherwise.</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>TAU (workspace) DOUBLE PRECISION array, dimension (N)</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (max(3*N,M,P))</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value.</p>
<h1>Further Details</h1>
<p>The subroutine uses LAPACK subroutine DGEQPF for the <a class="el" href="classpsi_1_1QR.html">QR</a> factorization with column pivoting to detect the effective numerical rank of the a matrix. It may be replaced by a better rank determination strategy. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a73ffa89e8a5538ddb36a49be7add1a15_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a735bfd6706e202a9d743312539aa8e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGTCON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGTCON estimates the reciprocal of the condition number of a real tridiagonal matrix A using the LU factorization as computed by DGTTRF.</p>
<p>An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).</p>
<h1>Arguments</h1>
<p>NORM (input) CHARACTER*1 Specifies whether the 1-norm condition number or the infinity-norm condition number is required: = '1' or 'O': 1-norm; = 'I': Infinity-norm.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>DL (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) multipliers that define the matrix L from the LU factorization of A as computed by DGTTRF.</p>
<p>D (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of the upper triangular matrix U from the LU factorization of A.</p>
<p>DU (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) elements of the first superdiagonal of U.</p>
<p>DU2 (input) DOUBLE PRECISION array, dimension (N-2) The (n-2) elements of the second superdiagonal of U.</p>
<p>IPIV (input) INTEGER array, dimension (N) The pivot indices; for 1 &lt;= i &lt;= n, row i of the matrix was interchanged with row IPIV(i). IPIV(i) will always be either i or i+1; IPIV(i) = i indicates a row interchange was not required.</p>
<p>ANORM (input) DOUBLE PRECISION If NORM = '1' or 'O', the 1-norm of the original matrix A. If NORM = 'I', the infinity-norm of the original matrix A.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an estimate of the 1-norm of inv(A) computed in this routine.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (2*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a735bfd6706e202a9d743312539aa8e4e_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a84c57ef02e174f2bc07c0cb591cb635a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGTRFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dlf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>duf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGTRFS improves the computed solution to a system of linear equations when the coefficient matrix is tridiagonal, and provides error bounds and backward error estimates for the solution.</p>
<h1>Arguments</h1>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Conjugate transpose = Transpose)</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>DL (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) subdiagonal elements of A.</p>
<p>D (input) DOUBLE PRECISION array, dimension (N) The diagonal elements of A.</p>
<p>DU (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) superdiagonal elements of A.</p>
<p>DLF (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) multipliers that define the matrix L from the LU factorization of A as computed by DGTTRF.</p>
<p>DF (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of the upper triangular matrix U from the LU factorization of A.</p>
<p>DUF (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) elements of the first superdiagonal of U.</p>
<p>DU2 (input) DOUBLE PRECISION array, dimension (N-2) The (n-2) elements of the second superdiagonal of U.</p>
<p>IPIV (input) INTEGER array, dimension (N) The pivot indices; for 1 &lt;= i &lt;= n, row i of the matrix was interchanged with row IPIV(i). IPIV(i) will always be either i or i+1; IPIV(i) = i indicates a row interchange was not required.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS) On entry, the solution matrix X, as computed by DGTTRS. On exit, the improved solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Internal Parameters</h1>
<p>ITMAX is the maximum number of steps of iterative refinement. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a84c57ef02e174f2bc07c0cb591cb635a_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a76f3c73d2b7d53e209439172f18401b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGTSV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGTSV solves the equation</p>
<p>A*X = B,</p>
<p>where A is an n by n tridiagonal matrix, by Gaussian elimination with partial pivoting.</p>
<p>Note that the equation A'*X = B may be solved by interchanging the order of the arguments DU and DL.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>DL (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, DL must contain the (n-1) sub-diagonal elements of A.</p>
<p>On exit, DL is overwritten by the (n-2) elements of the second super-diagonal of the upper triangular matrix U from the LU factorization of A, in DL(1), ..., DL(n-2).</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, D must contain the diagonal elements of A.</p>
<p>On exit, D is overwritten by the n diagonal elements of U.</p>
<p>DU (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, DU must contain the (n-1) super-diagonal elements of A.</p>
<p>On exit, DU is overwritten by the (n-1) elements of the first super-diagonal of U.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N by NRHS matrix of right hand side matrix B. On exit, if INFO = 0, the N by NRHS solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, U(i,i) is exactly zero, and the solution has not been computed. The factorization has not been completed unless i = N. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a76f3c73d2b7d53e209439172f18401b1_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad41c192f1b7e35baef951254c68acb56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGTSVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dlf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>duf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGTSVX uses the LU factorization to compute the solution to a real system of linear equations A * X = B or A**T * X = B, where A is a tridiagonal matrix of order N and X and B are N-by-NRHS matrices.</p>
<p>Error bounds on the solution and a condition estimate are also provided.</p>
<h1>Description</h1>
<p>The following steps are performed:</p>
<ol type="1">
<li>If FACT = 'N', the LU decomposition is used to factor the matrix A as A = L * U, where L is a product of permutation and unit lower bidiagonal matrices and U is upper triangular with nonzeros in only the main diagonal and first two superdiagonals.</li>
</ol>
<ol type="1">
<li>If some U(i,i)=0, so that U is exactly singular, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A. If the reciprocal of the condition number is less than machine precision, C++ Return value: INFO (output) INTEGER to solve for X and compute error bounds as described below.</li>
</ol>
<ol type="1">
<li>The system of equations is solved for X using the factored form of A.</li>
</ol>
<ol type="1">
<li>Iterative refinement is applied to improve the computed solution matrix and calculate error bounds and backward error estimates for it.</li>
</ol>
<h1>Arguments</h1>
<p>FACT (input) CHARACTER*1 Specifies whether or not the factored form of A has been supplied on entry. = 'F': DLF, DF, DUF, DU2, and IPIV contain the factored form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV will not be modified. = 'N': The matrix will be copied to DLF, DF, and DUF and factored.</p>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Conjugate transpose = Transpose)</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>DL (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) subdiagonal elements of A.</p>
<p>D (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of A.</p>
<p>DU (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) superdiagonal elements of A.</p>
<p>DLF (input or output) DOUBLE PRECISION array, dimension (N-1) If FACT = 'F', then DLF is an input argument and on entry contains the (n-1) multipliers that define the matrix L from the LU factorization of A as computed by DGTTRF.</p>
<p>If FACT = 'N', then DLF is an output argument and on exit contains the (n-1) multipliers that define the matrix L from the LU factorization of A.</p>
<p>DF (input or output) DOUBLE PRECISION array, dimension (N) If FACT = 'F', then DF is an input argument and on entry contains the n diagonal elements of the upper triangular matrix U from the LU factorization of A.</p>
<p>If FACT = 'N', then DF is an output argument and on exit contains the n diagonal elements of the upper triangular matrix U from the LU factorization of A.</p>
<p>DUF (input or output) DOUBLE PRECISION array, dimension (N-1) If FACT = 'F', then DUF is an input argument and on entry contains the (n-1) elements of the first superdiagonal of U.</p>
<p>If FACT = 'N', then DUF is an output argument and on exit contains the (n-1) elements of the first superdiagonal of U.</p>
<p>DU2 (input or output) DOUBLE PRECISION array, dimension (N-2) If FACT = 'F', then DU2 is an input argument and on entry contains the (n-2) elements of the second superdiagonal of U.</p>
<p>If FACT = 'N', then DU2 is an output argument and on exit contains the (n-2) elements of the second superdiagonal of U.</p>
<p>IPIV (input or output) INTEGER array, dimension (N) If FACT = 'F', then IPIV is an input argument and on entry contains the pivot indices from the LU factorization of A as computed by DGTTRF.</p>
<p>If FACT = 'N', then IPIV is an output argument and on exit contains the pivot indices from the LU factorization of A; row i of the matrix was interchanged with row IPIV(i). IPIV(i) will always be either i or i+1; IPIV(i) = i indicates a row interchange was not required.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The N-by-NRHS right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,NRHS) If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>RCOND (output) DOUBLE PRECISION The estimate of the reciprocal condition number of the matrix A. If RCOND is less than the machine precision (in particular, if RCOND = 0), the matrix is singular to working precision. This condition is indicated by a return code of C++ Return value: INFO (output) INTEGER</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= N: U(i,i) is exactly zero. The factorization has not been completed unless i = N, but the factor U is exactly singular, so the solution and error bounds could not be computed. RCOND = 0 is returned. = N+1: U is nonsingular, but RCOND is less than machine precision, meaning that the matrix is singular to working precision. Nevertheless, the solution and error bounds are computed because there are a number of situations where the computed solution can be more accurate than the value of RCOND would suggest. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ad41c192f1b7e35baef951254c68acb56_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad7a04949ec96b0a4d026c649fcdadc84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGTTRF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGTTRF computes an LU factorization of a real tridiagonal matrix A using elimination with partial pivoting and row interchanges.</p>
<p>The factorization has the form A = L * U where L is a product of permutation and unit lower bidiagonal matrices and U is upper triangular with nonzeros in only the main diagonal and first two superdiagonals.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix A.</p>
<p>DL (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, DL must contain the (n-1) sub-diagonal elements of A.</p>
<p>On exit, DL is overwritten by the (n-1) multipliers that define the matrix L from the LU factorization of A.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, D must contain the diagonal elements of A.</p>
<p>On exit, D is overwritten by the n diagonal elements of the upper triangular matrix U from the LU factorization of A.</p>
<p>DU (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, DU must contain the (n-1) super-diagonal elements of A.</p>
<p>On exit, DU is overwritten by the (n-1) elements of the first super-diagonal of U.</p>
<p>DU2 (output) DOUBLE PRECISION array, dimension (N-2) On exit, DU2 is overwritten by the (n-2) elements of the second super-diagonal of U.</p>
<p>IPIV (output) INTEGER array, dimension (N) The pivot indices; for 1 &lt;= i &lt;= n, row i of the matrix was interchanged with row IPIV(i). IPIV(i) will always be either i or i+1; IPIV(i) = i indicates a row interchange was not required.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -k, the k-th argument had an illegal value &gt; 0: if INFO = k, U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ad7a04949ec96b0a4d026c649fcdadc84_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad00a34294880feefe4cfe8bb47fceb13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGTTRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>du2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGTTRS solves one of the systems of equations A*X = B or A'*X = B, with a tridiagonal matrix A using the LU factorization computed by DGTTRF.</p>
<h1>Arguments</h1>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations. = 'N': A * X = B (No transpose) = 'T': A'* X = B (Transpose) = 'C': A'* X = B (Conjugate transpose = Transpose)</p>
<p>N (input) INTEGER The order of the matrix A.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>DL (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) multipliers that define the matrix L from the LU factorization of A.</p>
<p>D (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of the upper triangular matrix U from the LU factorization of A.</p>
<p>DU (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) elements of the first super-diagonal of U.</p>
<p>DU2 (input) DOUBLE PRECISION array, dimension (N-2) The (n-2) elements of the second super-diagonal of U.</p>
<p>IPIV (input) INTEGER array, dimension (N) The pivot indices; for 1 &lt;= i &lt;= n, row i of the matrix was interchanged with row IPIV(i). IPIV(i) will always be either i or i+1; IPIV(i) = i indicates a row interchange was not required.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the matrix of right hand side vectors B. On exit, B is overwritten by the solution vectors X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ad00a34294880feefe4cfe8bb47fceb13_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a67fb743c17dc2781d93ef400eb311d15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DHGEQZ </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DHGEQZ computes the eigenvalues of a real matrix pair (H,T), where H is an upper Hessenberg matrix and T is upper triangular, using the double-shift QZ method. <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> pairs of this type are produced by the reduction to generalized upper Hessenberg form of a real matrix pair (A,B):</p>
<p>A = Q1*H*Z1**T, B = Q1*T*Z1**T,</p>
<p>as computed by DGGHRD.</p>
<p>If JOB='S', then the Hessenberg-triangular pair (H,T) is also reduced to generalized Schur form,</p>
<p>H = Q*S*Z**T, T = Q*P*Z**T,</p>
<p>where Q and Z are orthogonal matrices, P is an upper triangular matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2 diagonal blocks.</p>
<p>The 1-by-1 blocks correspond to real eigenvalues of the matrix pair (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of eigenvalues.</p>
<p>Additionally, the 2-by-2 upper triangular diagonal blocks of P corresponding to 2-by-2 blocks of S are reduced to positive diagonal form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0, P(j,j) &gt; 0, and P(j+1,j+1) &gt; 0.</p>
<p>Optionally, the orthogonal matrix Q from the generalized Schur factorization may be postmultiplied into an input matrix Q1, and the orthogonal matrix Z may be postmultiplied into an input matrix Z1. If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced the matrix pair (A,B) to generalized upper Hessenberg form, then the output matrices Q1*Q and Z1*Z are the orthogonal factors from the generalized Schur factorization of (A,B):</p>
<p>A = (Q1*Q)*S*(Z1*Z)**T, B = (Q1*Q)*P*(Z1*Z)**T.</p>
<p>To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently, of (A,B)) are computed as a pair of values (alpha,beta), where alpha is complex and beta real. If beta is nonzero, lambda = alpha / beta is an eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP) A*x = lambda*B*x and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the alternate form of the GNEP mu*A*y = B*y. Real eigenvalues can be read directly from the generalized Schur form: alpha = S(i,i), beta = P(i,i).</p>
<p><a class="el" href="classpsi_1_1Ref.html">Ref</a>: C.B. Moler &amp; G.W. Stewart, "An Algorithm for Generalized Matrix
     Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973), pp. 241&ndash;256.</p>
<h1>Arguments</h1>
<p>JOB (input) CHARACTER*1 = 'E': Compute eigenvalues only; = 'S': Compute eigenvalues and the Schur form.</p>
<p>COMPQ (input) CHARACTER*1 = 'N': Left Schur vectors (Q) are not computed; = 'I': Q is initialized to the unit matrix and the matrix Q of left Schur vectors of (H,T) is returned; = 'V': Q must contain an orthogonal matrix Q1 on entry and the product Q1*Q is returned.</p>
<p>COMPZ (input) CHARACTER*1 = 'N': Right Schur vectors (Z) are not computed; = 'I': Z is initialized to the unit matrix and the matrix Z of right Schur vectors of (H,T) is returned; = 'V': Z must contain an orthogonal matrix Z1 on entry and the product Z1*Z is returned.</p>
<p>N (input) INTEGER The order of the matrices H, T, Q, and Z. N &gt;= 0.</p>
<p>ILO (input) INTEGER IHI (input) INTEGER ILO and IHI mark the rows and columns of H which are in Hessenberg form. It is assumed that A is already upper triangular in rows and columns 1:ILO-1 and IHI+1:N. If N &gt; 0, 1 &lt;= ILO &lt;= IHI &lt;= N; if N = 0, ILO=1 and IHI=0.</p>
<p>H (input/output) DOUBLE PRECISION array, dimension (LDH, N) On entry, the N-by-N upper Hessenberg matrix H. On exit, if JOB = 'S', H contains the upper quasi-triangular matrix S from the generalized Schur factorization; 2-by-2 diagonal blocks (corresponding to complex conjugate pairs of eigenvalues) are returned in standard form, with H(i,i) = H(i+1,i+1) and H(i+1,i)*H(i,i+1) &lt; 0. If JOB = 'E', the diagonal blocks of H match those of S, but the rest of H is unspecified.</p>
<p>LDH (input) INTEGER The leading dimension of the array H. LDH &gt;= max( 1, N ).</p>
<p>T (input/output) DOUBLE PRECISION array, dimension (LDT, N) On entry, the N-by-N upper triangular matrix T. On exit, if JOB = 'S', T contains the upper triangular matrix P from the generalized Schur factorization; 2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S are reduced to positive diagonal form, i.e., if H(j+1,j) is non-zero, then T(j+1,j) = T(j,j+1) = 0, T(j,j) &gt; 0, and T(j+1,j+1) &gt; 0. If JOB = 'E', the diagonal blocks of T match those of P, but the rest of T is unspecified.</p>
<p>LDT (input) INTEGER The leading dimension of the array T. LDT &gt;= max( 1, N ).</p>
<p>ALPHAR (output) DOUBLE PRECISION array, dimension (N) The real parts of each scalar alpha defining an eigenvalue of GNEP.</p>
<p>ALPHAI (output) DOUBLE PRECISION array, dimension (N) The imaginary parts of each scalar alpha defining an eigenvalue of GNEP. If ALPHAI(j) is zero, then the j-th eigenvalue is real; if positive, then the j-th and (j+1)-st eigenvalues are a complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j).</p>
<p>BETA (output) DOUBLE PRECISION array, dimension (N) The scalars beta that define the eigenvalues of GNEP. Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and beta = BETA(j) represent the j-th eigenvalue of the matrix pair (A,B), in one of the forms lambda = alpha/beta or mu = beta/alpha. Since either lambda or mu may overflow, they should not, in general, be computed.</p>
<p>Q (input/output) DOUBLE PRECISION array, dimension (LDQ, N) On entry, if COMPZ = 'V', the orthogonal matrix Q1 used in the reduction of (A,B) to generalized Hessenberg form. On exit, if COMPZ = 'I', the orthogonal matrix of left Schur vectors of (H,T), and if COMPZ = 'V', the orthogonal matrix of left Schur vectors of (A,B). Not referenced if COMPZ = 'N'.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= 1. If COMPQ='V' or 'I', then LDQ &gt;= N.</p>
<p>Z (input/output) DOUBLE PRECISION array, dimension (LDZ, N) On entry, if COMPZ = 'V', the orthogonal matrix Z1 used in the reduction of (A,B) to generalized Hessenberg form. On exit, if COMPZ = 'I', the orthogonal matrix of right Schur vectors of (H,T), and if COMPZ = 'V', the orthogonal matrix of right Schur vectors of (A,B). Not referenced if COMPZ = 'N'.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1. If COMPZ='V' or 'I', then LDZ &gt;= N.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO &gt;= 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N).</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value = 1,...,N: the QZ iteration did not converge. (H,T) is not in Schur form, but ALPHAR(i), ALPHAI(i), and BETA(i), i=INFO+1,...,N should be correct. = N+1,...,2*N: the shift calculation failed. (H,T) is not in Schur form, but ALPHAR(i), ALPHAI(i), and BETA(i), i=INFO-N+1,...,N should be correct.</p>
<h1>Further Details</h1>
<p>Iteration counters:</p>
<p>JITER &ndash; counts iterations. IITER &ndash; counts iterations run since ILAST was last changed. This is therefore reset only when a 1-by-1 or 2-by-2 block deflates off the bottom. </p>
<hr/>
<p>.. Parameters .. $ SAFETY = 1.0E+0 ) </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a67fb743c17dc2781d93ef400eb311d15_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a33a026d1fa8b2c995079b644e1c3064a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DHSEIN </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>eigsrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>initv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifaill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifailr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DHSEIN uses inverse iteration to find specified right and/or left eigenvectors of a real upper Hessenberg matrix H.</p>
<p>The right eigenvector x and the left eigenvector y of the matrix H corresponding to an eigenvalue w are defined by: </p>
<pre class="fragment">         H * x = w * x,     y**h * H = w * y**h
</pre><p>where y**h denotes the conjugate transpose of the vector y.</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'R': compute right eigenvectors only; = 'L': compute left eigenvectors only; = 'B': compute both right and left eigenvectors.</p>
<p>EIGSRC (input) CHARACTER*1 Specifies the source of eigenvalues supplied in (WR,WI): = 'Q': the eigenvalues were found using DHSEQR; thus, if H has zero subdiagonal elements, and so is block-triangular, then the j-th eigenvalue can be assumed to be an eigenvalue of the block containing the j-th row/column. This property allows DHSEIN to perform inverse iteration on just one diagonal block. = 'N': no assumptions are made on the correspondence between eigenvalues and diagonal blocks. In this case, DHSEIN must always perform inverse iteration using the whole matrix H.</p>
<p>INITV (input) CHARACTER*1 = 'N': no initial vectors are supplied; = 'U': user-supplied initial vectors are stored in the arrays VL and/or VR.</p>
<p>SELECT (input/output) LOGICAL array, dimension (N) Specifies the eigenvectors to be computed. To select the real eigenvector corresponding to a real eigenvalue WR(j), SELECT(j) must be set to .TRUE.. To select the complex eigenvector corresponding to a complex eigenvalue (WR(j),WI(j)), with complex conjugate (WR(j+1),WI(j+1)), either SELECT(j) or SELECT(j+1) or both must be set to .TRUE.; then on exit SELECT(j) is .TRUE. and SELECT(j+1) is .FALSE..</p>
<p>N (input) INTEGER The order of the matrix H. N &gt;= 0.</p>
<p>H (input) DOUBLE PRECISION array, dimension (LDH,N) The upper Hessenberg matrix H.</p>
<p>LDH (input) INTEGER The leading dimension of the array H. LDH &gt;= max(1,N).</p>
<p>WR (input/output) DOUBLE PRECISION array, dimension (N) WI (input) DOUBLE PRECISION array, dimension (N) On entry, the real and imaginary parts of the eigenvalues of H; a complex conjugate pair of eigenvalues must be stored in consecutive elements of WR and WI. On exit, WR may have been altered since close eigenvalues are perturbed slightly in searching for independent eigenvectors.</p>
<p>VL (input/output) DOUBLE PRECISION array, dimension (LDVL,MM) On entry, if INITV = 'U' and SIDE = 'L' or 'B', VL must contain starting vectors for the inverse iteration for the left eigenvectors; the starting vector for each eigenvector must be in the same column(s) in which the eigenvector will be stored. On exit, if SIDE = 'L' or 'B', the left eigenvectors specified by SELECT will be stored consecutively in the columns of VL, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part and the second the imaginary part. If SIDE = 'R', VL is not referenced.</p>
<p>LDVL (input) INTEGER The leading dimension of the array VL. LDVL &gt;= max(1,N) if SIDE = 'L' or 'B'; LDVL &gt;= 1 otherwise.</p>
<p>VR (input/output) DOUBLE PRECISION array, dimension (LDVR,MM) On entry, if INITV = 'U' and SIDE = 'R' or 'B', VR must contain starting vectors for the inverse iteration for the right eigenvectors; the starting vector for each eigenvector must be in the same column(s) in which the eigenvector will be stored. On exit, if SIDE = 'R' or 'B', the right eigenvectors specified by SELECT will be stored consecutively in the columns of VR, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part and the second the imaginary part. If SIDE = 'L', VR is not referenced.</p>
<p>LDVR (input) INTEGER The leading dimension of the array VR. LDVR &gt;= max(1,N) if SIDE = 'R' or 'B'; LDVR &gt;= 1 otherwise.</p>
<p>MM (input) INTEGER The number of columns in the arrays VL and/or VR. MM &gt;= M.</p>
<p>M (output) INTEGER The number of columns in the arrays VL and/or VR required to store the eigenvectors; each selected real eigenvector occupies one column and each selected complex eigenvector occupies two columns.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension ((N+2)*N)</p>
<p>IFAILL (output) INTEGER array, dimension (MM) If SIDE = 'L' or 'B', IFAILL(i) = j &gt; 0 if the left eigenvector in the i-th column of VL (corresponding to the eigenvalue w(j)) failed to converge; IFAILL(i) = 0 if the eigenvector converged satisfactorily. If the i-th and (i+1)th columns of VL hold a complex eigenvector, then IFAILL(i) and IFAILL(i+1) are set to the same value. If SIDE = 'R', IFAILL is not referenced.</p>
<p>IFAILR (output) INTEGER array, dimension (MM) If SIDE = 'R' or 'B', IFAILR(i) = j &gt; 0 if the right eigenvector in the i-th column of VR (corresponding to the eigenvalue w(j)) failed to converge; IFAILR(i) = 0 if the eigenvector converged satisfactorily. If the i-th and (i+1)th columns of VR hold a complex eigenvector, then IFAILR(i) and IFAILR(i+1) are set to the same value. If SIDE = 'L', IFAILR is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, i is the number of eigenvectors which failed to converge; see IFAILL and IFAILR for further details.</p>
<h1>Further Details</h1>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x|+|y|. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a33a026d1fa8b2c995079b644e1c3064a_icgraph.svg" width="304" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="acf2a864036d76935f43d7c4be662b7c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DHSEQR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DHSEQR computes the eigenvalues of a Hessenberg matrix H and, optionally, the matrices T and Z from the Schur decomposition H = Z T Z**T, where T is an upper quasi-triangular matrix (the Schur form), and Z is the orthogonal matrix of Schur vectors.</p>
<p>Optionally Z may be postmultiplied into an input orthogonal matrix Q so that this routine can give the Schur factorization of a matrix A which has been reduced to the Hessenberg form H by the orthogonal matrix Q: A = Q*H*Q**T = (QZ)*T*(QZ)**T.</p>
<h1>Arguments</h1>
<p>JOB (input) CHARACTER*1 = 'E': compute eigenvalues only; = 'S': compute eigenvalues and the Schur form T.</p>
<p>COMPZ (input) CHARACTER*1 = 'N': no Schur vectors are computed; = 'I': Z is initialized to the unit matrix and the matrix Z of Schur vectors of H is returned; = 'V': Z must contain an orthogonal matrix Q on entry, and the product Q*Z is returned.</p>
<p>N (input) INTEGER The order of the matrix H. N .GE. 0.</p>
<p>ILO (input) INTEGER IHI (input) INTEGER It is assumed that H is already upper triangular in rows and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally set by a previous call to DGEBAL, and then passed to DGEHRD when the matrix output by DGEBAL is reduced to Hessenberg form. Otherwise ILO and IHI should be set to 1 and N respectively. If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N. If N = 0, then ILO = 1 and IHI = 0.</p>
<p>H (input/output) DOUBLE PRECISION array, dimension (LDH,N) On entry, the upper Hessenberg matrix H. On exit, if INFO = 0 and JOB = 'S', then H contains the upper quasi-triangular matrix T from the Schur decomposition (the Schur form); 2-by-2 diagonal blocks (corresponding to complex conjugate pairs of eigenvalues) are returned in standard form, with H(i,i) = H(i+1,i+1) and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and JOB = 'E', the contents of H are unspecified on exit. (The output value of H when INFO.GT.0 is given under the description of INFO below.)</p>
<p>Unlike earlier versions of DHSEQR, this subroutine may explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.</p>
<p>LDH (input) INTEGER The leading dimension of the array H. LDH .GE. max(1,N).</p>
<p>WR (output) DOUBLE PRECISION array, dimension (N) WI (output) DOUBLE PRECISION array, dimension (N) The real and imaginary parts, respectively, of the computed eigenvalues. If two eigenvalues are computed as a complex conjugate pair, they are stored in consecutive elements of WR and WI, say the i-th and (i+1)th, with WI(i) .GT. 0 and WI(i+1) .LT. 0. If JOB = 'S', the eigenvalues are stored in the same order as on the diagonal of the Schur form returned in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).</p>
<p>Z (input/output) DOUBLE PRECISION array, dimension (LDZ,N) If COMPZ = 'N', Z is not referenced. If COMPZ = 'I', on entry Z need not be set and on exit, if INFO = 0, Z contains the orthogonal matrix Z of the Schur vectors of H. If COMPZ = 'V', on entry Z must contain an N-by-N matrix Q, which is assumed to be equal to the unit matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit, if INFO = 0, Z contains Q*Z. Normally Q is the orthogonal matrix generated by DORGHR after the call to DGEHRD which formed the Hessenberg matrix H. (The output value of Z when INFO.GT.0 is given under the description of INFO below.)</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. if COMPZ = 'I' or COMPZ = 'V', then LDZ.GE.MAX(1,N). Otherwize, LDZ.GE.1.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (LWORK) On exit, if INFO = 0, WORK(1) returns an estimate of the optimal value for LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK .GE. max(1,N) is sufficient and delivers very good and sometimes optimal performance. However, LWORK as large as 11*N may be required for optimal performance. A workspace query is recommended to determine the optimal workspace size.</p>
<p>If LWORK = -1, then DHSEQR does a workspace query. In this case, DHSEQR checks the input parameters and estimates the optimal workspace size for the given values of N, ILO and IHI. The estimate is returned in WORK(1). No error message related to LWORK is issued by XERBLA. Neither H nor Z are accessed.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit .LT. 0: if INFO = -i, the i-th argument had an illegal value .GT. 0: if INFO = i, DHSEQR failed to compute all of the eigenvalues. Elements 1:ilo-1 and i+1:n of WR and WI contain those eigenvalues which have been successfully computed. (Failures are rare.)</p>
<p>If INFO .GT. 0 and JOB = 'E', then on exit, the remaining unconverged eigenvalues are the eigen- values of the upper Hessenberg matrix rows and columns ILO through INFO of the final, output value of H.</p>
<p>If INFO .GT. 0 and JOB = 'S', then on exit</p>
<p>(*) (initial value of H)*U = U*(final value of H) </p>
<pre class="fragment"> where U is an orthogonal matrix.  The final
 value of H is upper Hessenberg and quasi-triangular
 in rows and columns INFO+1 through IHI.

 If INFO .GT. 0 and COMPZ = 'V', then on exit

   (final value of Z)  =  (initial value of Z)*U

 where U is the orthogonal matrix in (*) (regard-
 less of the value of JOB.)

 If INFO .GT. 0 and COMPZ = 'I', then on exit
       (final value of Z)  = U
 where U is the orthogonal matrix in (*) (regard-
 less of the value of JOB.)

 If INFO .GT. 0 and COMPZ = 'N', then Z is not
 accessed.
</pre><p>================================================================ Default values supplied by ILAENV(ISPEC,'DHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK). It is suggested that these defaults be adjusted in order to attain best performance in each particular computational environment.</p>
<p>ISPEC=12: The DLAHQR vs DLAQR0 crossover point. Default: 75. (Must be at least 11.)</p>
<p>ISPEC=13: Recommended deflation window size. This depends on ILO, IHI and NS. NS is the number of simultaneous shifts returned by ILAENV(ISPEC=15). (See ISPEC=15 below.) The default for (IHI-ILO+1).LE.500 is NS. The default for (IHI-ILO+1).GT.500 is 3*NS/2.</p>
<p>ISPEC=14: Nibble crossover point. (See IPARMQ for details.) Default: 14% of deflation window size.</p>
<p>ISPEC=15: Number of simultaneous shifts in a multishift <a class="el" href="classpsi_1_1QR.html">QR</a> iteration.</p>
<p>If IHI-ILO+1 is ...</p>
<p>greater than ...but less ... the or equal to ... than default is </p>
<pre class="fragment"> 1               30          NS =   2(+)
30               60          NS =   4(+)
60              150          NS =  10(+)
</pre><p> 150 590 NS = ** 590 3000 NS = 64 3000 6000 NS = 128 6000 infinity NS = 256</p>
<p>(+) By default some or all matrices of this order are passed to the implicit double shift routine DLAHQR and this parameter is ignored. See ISPEC=12 above and comments in IPARMQ for details.</p>
<p>(**) The asterisks (**) indicate an ad-hoc function of N increasing from 10 to 64.</p>
<p>ISPEC=16: Select structured matrix multiply. If the number of simultaneous shifts (specified by ISPEC=15) is less than 14, then the default for ISPEC=16 is 0. Otherwise the default for ISPEC=16 is 2. </p>
<hr/>
<p> Based on contributions by Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA </p>
<hr/>
<p> References: K. Braman, R. Byers and R. Mathias, The Multi-Shift <a class="el" href="classpsi_1_1QR.html">QR</a> Algorithm Part I: Maintaining Well Focused Shifts, and Level 3 Performance, SIAM Journal of <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Analysis, volume 23, pages 929&ndash;947, 2002.</p>
<p>K. Braman, R. Byers and R. Mathias, The Multi-Shift <a class="el" href="classpsi_1_1QR.html">QR</a> Algorithm Part II: Aggressive Early Deflation, SIAM Journal of <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Analysis, volume 23, pages 948&ndash;973, 2002. </p>
<hr/>
<p> .. Parameters ..</p>
<p>==== Matrices of order NTINY or smaller must be processed by . DLAHQR because of insufficient subdiagonal scratch space. . (This is a hard limit.) ==== </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_acf2a864036d76935f43d7c4be662b7c2_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3f6e60d755abd22f120a83a17b7deca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DOPGTR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DOPGTR generates a real orthogonal matrix Q which is defined as the product of n-1 elementary reflectors H(i) of order n, as returned by DSPTRD using packed storage:</p>
<p>if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),</p>
<p>if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangular packed storage used in previous call to DSPTRD; = 'L': Lower triangular packed storage used in previous call to DSPTRD.</p>
<p>N (input) INTEGER The order of the matrix Q. N &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The vectors which define the elementary reflectors, as returned by DSPTRD.</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (N-1) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DSPTRD.</p>
<p>Q (output) DOUBLE PRECISION array, dimension (LDQ,N) The N-by-N orthogonal matrix Q.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (N-1)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="accad2aadf66d22b75355708708af0e82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DOPMTR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DOPMTR overwrites the general real M-by-N matrix C with </p>
<pre class="fragment">            SIDE = 'L'     SIDE = 'R'
</pre><p> TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T</p>
<p>where Q is a real orthogonal matrix of order nq, with nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of nq-1 elementary reflectors, as returned by DSPTRD using packed storage:</p>
<p>if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);</p>
<p>if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'L': apply Q or Q**T from the Left; = 'R': apply Q or Q**T from the Right.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangular packed storage used in previous call to DSPTRD; = 'L': Lower triangular packed storage used in previous call to DSPTRD.</p>
<p>TRANS (input) CHARACTER*1 = 'N': No transpose, apply Q; = 'T': Transpose, apply Q**T.</p>
<p>M (input) INTEGER The number of rows of the matrix C. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix C. N &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (M*(M+1)/2) if SIDE = 'L' (N*(N+1)/2) if SIDE = 'R' The vectors which define the elementary reflectors, as returned by DSPTRD. AP is modified by the routine but restored on exit.</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (M-1) if SIDE = 'L' or (N-1) if SIDE = 'R' TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DSPTRD.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (N) if SIDE = 'L' (M) if SIDE = 'R'</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a8cbe7aee87fe8c038d294b1d825bb430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORGBR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORGBR generates one of the real orthogonal matrices Q or P**T determined by DGEBRD when reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and P**T are defined as products of elementary reflectors H(i) or G(i) respectively.</p>
<p>If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q is of order M: if m &gt;= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n columns of Q, where m &gt;= n &gt;= k; if m &lt; k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an M-by-M matrix.</p>
<p>If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T is of order N: if k &lt; n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m rows of P**T, where n &gt;= m &gt;= k; if k &gt;= n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as an N-by-N matrix.</p>
<h1>Arguments</h1>
<p>VECT (input) CHARACTER*1 Specifies whether the matrix Q or the matrix P**T is required, as defined in the transformation applied by DGEBRD: = 'Q': generate Q; = 'P': generate P**T.</p>
<p>M (input) INTEGER The number of rows of the matrix Q or P**T to be returned. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix Q or P**T to be returned. N &gt;= 0. If VECT = 'Q', M &gt;= N &gt;= min(M,K); if VECT = 'P', N &gt;= M &gt;= min(N,K).</p>
<p>K (input) INTEGER If VECT = 'Q', the number of columns in the original M-by-K matrix reduced by DGEBRD. If VECT = 'P', the number of rows in the original K-by-N matrix reduced by DGEBRD. K &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the vectors which define the elementary reflectors, as returned by DGEBRD. On exit, the M-by-N matrix Q or P**T.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (min(M,K)) if VECT = 'Q' (min(N,K)) if VECT = 'P' TAU(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q or P**T, as returned by DGEBRD in its array argument TAUQ or TAUP.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,min(M,N)). For optimum performance LWORK &gt;= min(M,N)*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a8cbe7aee87fe8c038d294b1d825bb430_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5583bf43b296577c37dd9591f0c9914c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORGHR </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORGHR generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD:</p>
<p>Q = H(ilo) H(ilo+1) . . . H(ihi-1).</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix Q. N &gt;= 0.</p>
<p>ILO (input) INTEGER IHI (input) INTEGER ILO and IHI must have the same values as in the previous call of DGEHRD. Q is equal to the unit matrix except in the submatrix Q(ilo+1:ihi,ilo+1:ihi). 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the vectors which define the elementary reflectors, as returned by DGEHRD. On exit, the N-by-N orthogonal matrix Q.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (N-1) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGEHRD.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= IHI-ILO. For optimum performance LWORK &gt;= (IHI-ILO)*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a5583bf43b296577c37dd9591f0c9914c_icgraph.svg" width="320" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a26cf75a4ae3299a216b09eb6f4b4b737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORGLQ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORGLQ generates an M-by-N real matrix Q with orthonormal rows, which is defined as the first M rows of a product of K elementary reflectors of order N </p>
<pre class="fragment">  Q  =  H(k) . . . H(2) H(1)
</pre><p>as returned by DGELQF.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix Q. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix Q. N &gt;= M.</p>
<p>K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. M &gt;= K &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the i-th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGELQF in the first k rows of its array argument A. On exit, the M-by-N matrix Q.</p>
<p>LDA (input) INTEGER The first dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGELQF.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= M*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument has an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a26cf75a4ae3299a216b09eb6f4b4b737_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa5df55e56031164c7edc6bdb65113853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORGQL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORGQL generates an M-by-N real matrix Q with orthonormal columns, which is defined as the last N columns of a product of K elementary reflectors of order M </p>
<pre class="fragment">  Q  =  H(k) . . . H(2) H(1)
</pre><p>as returned by DGEQLF.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix Q. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix Q. M &gt;= N &gt;= 0.</p>
<p>K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. N &gt;= K &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the (n-k+i)-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGEQLF in the last k columns of its array argument A. On exit, the M-by-N matrix Q.</p>
<p>LDA (input) INTEGER The first dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGEQLF.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N). For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument has an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa5df55e56031164c7edc6bdb65113853_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3bd2223a663dcda9dcc7816d2058f8d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORGQR </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORGQR generates an M-by-N real matrix Q with orthonormal columns, which is defined as the first N columns of a product of K elementary reflectors of order M </p>
<pre class="fragment">  Q  =  H(1) H(2) . . . H(k)
</pre><p>as returned by DGEQRF.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix Q. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix Q. M &gt;= N &gt;= 0.</p>
<p>K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. N &gt;= K &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGEQRF in the first k columns of its array argument A. On exit, the M-by-N matrix Q.</p>
<p>LDA (input) INTEGER The first dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGEQRF.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N). For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument has an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a3bd2223a663dcda9dcc7816d2058f8d6_icgraph.svg" width="320" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac23b845911f25755ce43d73a1b077696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORGRQ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORGRQ generates an M-by-N real matrix Q with orthonormal rows, which is defined as the last M rows of a product of K elementary reflectors of order N </p>
<pre class="fragment">  Q  =  H(1) H(2) . . . H(k)
</pre><p>as returned by DGERQF.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix Q. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix Q. N &gt;= M.</p>
<p>K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. M &gt;= K &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the (m-k+i)-th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGERQF in the last k rows of its array argument A. On exit, the M-by-N matrix Q.</p>
<p>LDA (input) INTEGER The first dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGERQF.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= M*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument has an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ac23b845911f25755ce43d73a1b077696_icgraph.svg" width="320" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad4b4cb4f1243709349d405f6b2b48453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORGTR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORGTR generates a real orthogonal matrix Q which is defined as the product of n-1 elementary reflectors of order N, as returned by DSYTRD:</p>
<p>if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),</p>
<p>if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A contains elementary reflectors from DSYTRD; = 'L': Lower triangle of A contains elementary reflectors from DSYTRD.</p>
<p>N (input) INTEGER The order of the matrix Q. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the vectors which define the elementary reflectors, as returned by DSYTRD. On exit, the N-by-N orthogonal matrix Q.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (N-1) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DSYTRD.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N-1). For optimum performance LWORK &gt;= (N-1)*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ad4b4cb4f1243709349d405f6b2b48453_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a45cdfdfc88e99834da9b4f7edcc7836c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORMBR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T</p>
<p>If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': P * C C * P TRANS = 'T': P**T * C C * P**T</p>
<p>Here Q and P**T are the orthogonal matrices determined by DGEBRD when reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and P**T are defined as products of elementary reflectors H(i) and G(i) respectively.</p>
<p>Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the order of the orthogonal matrix Q or P**T that is applied.</p>
<p>If VECT = 'Q', A is assumed to have been an NQ-by-K matrix: if nq &gt;= k, Q = H(1) H(2) . . . H(k); if nq &lt; k, Q = H(1) H(2) . . . H(nq-1).</p>
<p>If VECT = 'P', A is assumed to have been a K-by-NQ matrix: if k &lt; nq, P = G(1) G(2) . . . G(k); if k &gt;= nq, P = G(1) G(2) . . . G(nq-1).</p>
<h1>Arguments</h1>
<p>VECT (input) CHARACTER*1 = 'Q': apply Q or Q**T; = 'P': apply P or P**T.</p>
<p>SIDE (input) CHARACTER*1 = 'L': apply Q, Q**T, P or P**T from the Left; = 'R': apply Q, Q**T, P or P**T from the Right.</p>
<p>TRANS (input) CHARACTER*1 = 'N': No transpose, apply Q or P; = 'T': Transpose, apply Q**T or P**T.</p>
<p>M (input) INTEGER The number of rows of the matrix C. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix C. N &gt;= 0.</p>
<p>K (input) INTEGER If VECT = 'Q', the number of columns in the original matrix reduced by DGEBRD. If VECT = 'P', the number of rows in the original matrix reduced by DGEBRD. K &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,min(nq,K)) if VECT = 'Q' (LDA,nq) if VECT = 'P' The vectors which define the elementary reflectors H(i) and G(i), whose products determine the matrices Q and P, as returned by DGEBRD.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. If VECT = 'Q', LDA &gt;= max(1,nq); if VECT = 'P', LDA &gt;= max(1,min(nq,K)).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (min(nq,K)) TAU(i) must contain the scalar factor of the elementary reflector H(i) or G(i) which determines Q or P, as returned by DGEBRD in the array argument TAUQ or TAUP.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q or P*C or P**T*C or C*P or C*P**T.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If SIDE = 'L', LWORK &gt;= max(1,N); if SIDE = 'R', LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a45cdfdfc88e99834da9b4f7edcc7836c_icgraph.svg" width="320" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa53d61822fda02062379e781b25a8d9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORMHR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ilo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ihi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORMHR overwrites the general real M-by-N matrix C with </p>
<pre class="fragment">            SIDE = 'L'     SIDE = 'R'
</pre><p> TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T</p>
<p>where Q is a real orthogonal matrix of order nq, with nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of IHI-ILO elementary reflectors, as returned by DGEHRD:</p>
<p>Q = H(ilo) H(ilo+1) . . . H(ihi-1).</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'L': apply Q or Q**T from the Left; = 'R': apply Q or Q**T from the Right.</p>
<p>TRANS (input) CHARACTER*1 = 'N': No transpose, apply Q; = 'T': Transpose, apply Q**T.</p>
<p>M (input) INTEGER The number of rows of the matrix C. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix C. N &gt;= 0.</p>
<p>ILO (input) INTEGER IHI (input) INTEGER ILO and IHI must have the same values as in the previous call of DGEHRD. Q is equal to the unit matrix except in the submatrix Q(ilo+1:ihi,ilo+1:ihi). If SIDE = 'L', then 1 &lt;= ILO &lt;= IHI &lt;= M, if M &gt; 0, and ILO = 1 and IHI = 0, if M = 0; if SIDE = 'R', then 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0, and ILO = 1 and IHI = 0, if N = 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,M) if SIDE = 'L' (LDA,N) if SIDE = 'R' The vectors which define the elementary reflectors, as returned by DGEHRD.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (M-1) if SIDE = 'L' (N-1) if SIDE = 'R' TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGEHRD.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If SIDE = 'L', LWORK &gt;= max(1,N); if SIDE = 'R', LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa53d61822fda02062379e781b25a8d9b_icgraph.svg" width="323" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6ad0337d93f2db21ef79672f50e1a96b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORMLQ </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORMLQ overwrites the general real M-by-N matrix C with </p>
<pre class="fragment">            SIDE = 'L'     SIDE = 'R'
</pre><p> TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T</p>
<p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p>
<pre class="fragment">  Q = H(k) . . . H(2) H(1)
</pre><p>as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'L': apply Q or Q**T from the Left; = 'R': apply Q or Q**T from the Right.</p>
<p>TRANS (input) CHARACTER*1 = 'N': No transpose, apply Q; = 'T': Transpose, apply Q**T.</p>
<p>M (input) INTEGER The number of rows of the matrix C. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix C. N &gt;= 0.</p>
<p>K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = 'L', M &gt;= K &gt;= 0; if SIDE = 'R', N &gt;= K &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,M) if SIDE = 'L', (LDA,N) if SIDE = 'R' The i-th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGELQF in the first k rows of its array argument A. A is modified by the routine but restored on exit.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,K).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGELQF.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If SIDE = 'L', LWORK &gt;= max(1,N); if SIDE = 'R', LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a6ad0337d93f2db21ef79672f50e1a96b_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab32e51ae6609550f6cf95eece4b99228"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORMQL </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORMQL overwrites the general real M-by-N matrix C with </p>
<pre class="fragment">            SIDE = 'L'     SIDE = 'R'
</pre><p> TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T</p>
<p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p>
<pre class="fragment">  Q = H(k) . . . H(2) H(1)
</pre><p>as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'L': apply Q or Q**T from the Left; = 'R': apply Q or Q**T from the Right.</p>
<p>TRANS (input) CHARACTER*1 = 'N': No transpose, apply Q; = 'T': Transpose, apply Q**T.</p>
<p>M (input) INTEGER The number of rows of the matrix C. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix C. N &gt;= 0.</p>
<p>K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = 'L', M &gt;= K &gt;= 0; if SIDE = 'R', N &gt;= K &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGEQLF in the last k columns of its array argument A. A is modified by the routine but restored on exit.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. If SIDE = 'L', LDA &gt;= max(1,M); if SIDE = 'R', LDA &gt;= max(1,N).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGEQLF.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If SIDE = 'L', LWORK &gt;= max(1,N); if SIDE = 'R', LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ab32e51ae6609550f6cf95eece4b99228_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab0e7926eb5e51eaae7d8f71e03e4745e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORMQR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORMQR overwrites the general real M-by-N matrix C with </p>
<pre class="fragment">            SIDE = 'L'     SIDE = 'R'
</pre><p> TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T</p>
<p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p>
<pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'L': apply Q or Q**T from the Left; = 'R': apply Q or Q**T from the Right.</p>
<p>TRANS (input) CHARACTER*1 = 'N': No transpose, apply Q; = 'T': Transpose, apply Q**T.</p>
<p>M (input) INTEGER The number of rows of the matrix C. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix C. N &gt;= 0.</p>
<p>K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = 'L', M &gt;= K &gt;= 0; if SIDE = 'R', N &gt;= K &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGEQRF in the first k columns of its array argument A. A is modified by the routine but restored on exit.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. If SIDE = 'L', LDA &gt;= max(1,M); if SIDE = 'R', LDA &gt;= max(1,N).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGEQRF.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If SIDE = 'L', LWORK &gt;= max(1,N); if SIDE = 'R', LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ab0e7926eb5e51eaae7d8f71e03e4745e_icgraph.svg" width="323" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a24d3d206966481e688f72436691c129a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORMR3 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORMR3 overwrites the general real m by n matrix C with </p>
<pre class="fragment">  Q * C  if SIDE = 'L' and TRANS = 'N', or

  Q'* C  if SIDE = 'L' and TRANS = 'T', or

  C * Q  if SIDE = 'R' and TRANS = 'N', or

  C * Q' if SIDE = 'R' and TRANS = 'T',
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p>
<pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by DTZRZF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'L': apply Q or Q' from the Left = 'R': apply Q or Q' from the Right</p>
<p>TRANS (input) CHARACTER*1 = 'N': apply Q (No transpose) = 'T': apply Q' (Transpose)</p>
<p>M (input) INTEGER The number of rows of the matrix C. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix C. N &gt;= 0.</p>
<p>K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = 'L', M &gt;= K &gt;= 0; if SIDE = 'R', N &gt;= K &gt;= 0.</p>
<p>L (input) INTEGER The number of columns of the matrix A containing the meaningful part of the Householder reflectors. If SIDE = 'L', M &gt;= L &gt;= 0, if SIDE = 'R', N &gt;= L &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,M) if SIDE = 'L', (LDA,N) if SIDE = 'R' The i-th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DTZRZF in the last k rows of its array argument A. A is modified by the routine but restored on exit.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,K).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DTZRZF.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the m-by-n matrix C. On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (N) if SIDE = 'L', (M) if SIDE = 'R'</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>Based on contributions by A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a24d3d206966481e688f72436691c129a_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac3652160e0a4dfadeb7671065e18bdd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORMRQ </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORMRQ overwrites the general real M-by-N matrix C with </p>
<pre class="fragment">            SIDE = 'L'     SIDE = 'R'
</pre><p> TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T</p>
<p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p>
<pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'L': apply Q or Q**T from the Left; = 'R': apply Q or Q**T from the Right.</p>
<p>TRANS (input) CHARACTER*1 = 'N': No transpose, apply Q; = 'T': Transpose, apply Q**T.</p>
<p>M (input) INTEGER The number of rows of the matrix C. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix C. N &gt;= 0.</p>
<p>K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = 'L', M &gt;= K &gt;= 0; if SIDE = 'R', N &gt;= K &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,M) if SIDE = 'L', (LDA,N) if SIDE = 'R' The i-th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGERQF in the last k rows of its array argument A. A is modified by the routine but restored on exit.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,K).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGERQF.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If SIDE = 'L', LWORK &gt;= max(1,N); if SIDE = 'R', LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ac3652160e0a4dfadeb7671065e18bdd7_icgraph.svg" width="323" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a66158a3bbe19d7864ddd9688cdfde9d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORMRZ </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORMRZ overwrites the general real M-by-N matrix C with </p>
<pre class="fragment">            SIDE = 'L'     SIDE = 'R'
</pre><p> TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T</p>
<p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p>
<pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'L': apply Q or Q**T from the Left; = 'R': apply Q or Q**T from the Right.</p>
<p>TRANS (input) CHARACTER*1 = 'N': No transpose, apply Q; = 'T': Transpose, apply Q**T.</p>
<p>M (input) INTEGER The number of rows of the matrix C. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix C. N &gt;= 0.</p>
<p>K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = 'L', M &gt;= K &gt;= 0; if SIDE = 'R', N &gt;= K &gt;= 0.</p>
<p>L (input) INTEGER The number of columns of the matrix A containing the meaningful part of the Householder reflectors. If SIDE = 'L', M &gt;= L &gt;= 0, if SIDE = 'R', N &gt;= L &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,M) if SIDE = 'L', (LDA,N) if SIDE = 'R' The i-th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DTZRZF in the last k rows of its array argument A. A is modified by the routine but restored on exit.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,K).</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DTZRZF.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If SIDE = 'L', LWORK &gt;= max(1,N); if SIDE = 'R', LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>Based on contributions by A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a66158a3bbe19d7864ddd9688cdfde9d2_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2246cbbd73e6ccab2a431eb824e03a0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DORMTR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DORMTR overwrites the general real M-by-N matrix C with </p>
<pre class="fragment">            SIDE = 'L'     SIDE = 'R'
</pre><p> TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T</p>
<p>where Q is a real orthogonal matrix of order nq, with nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of nq-1 elementary reflectors, as returned by DSYTRD:</p>
<p>if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);</p>
<p>if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'L': apply Q or Q**T from the Left; = 'R': apply Q or Q**T from the Right.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A contains elementary reflectors from DSYTRD; = 'L': Lower triangle of A contains elementary reflectors from DSYTRD.</p>
<p>TRANS (input) CHARACTER*1 = 'N': No transpose, apply Q; = 'T': Transpose, apply Q**T.</p>
<p>M (input) INTEGER The number of rows of the matrix C. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix C. N &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,M) if SIDE = 'L' (LDA,N) if SIDE = 'R' The vectors which define the elementary reflectors, as returned by DSYTRD.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.</p>
<p>TAU (input) DOUBLE PRECISION array, dimension (M-1) if SIDE = 'L' (N-1) if SIDE = 'R' TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DSYTRD.</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If SIDE = 'L', LWORK &gt;= max(1,N); if SIDE = 'R', LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a2246cbbd73e6ccab2a431eb824e03a0b_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3140c5434e011b0250ab605254e411fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPBCON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPBCON estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite band matrix using the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T computed by DPBTRF.</p>
<p>An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangular factor stored in AB; = 'L': Lower triangular factor stored in AB.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) The triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T of the band matrix A, stored in the first KD+1 rows of the array. The j-th column of U or L is stored in the j-th column of the array AB as follows: if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO ='L', AB(1+i-j,j) = L(i,j) for j&lt;=i&lt;=min(n,j+kd).</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD+1.</p>
<p>ANORM (input) DOUBLE PRECISION The 1-norm (or infinity-norm) of the symmetric band matrix A.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an estimate of the 1-norm of inv(A) computed in this routine.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a3140c5434e011b0250ab605254e411fa_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a005c6545bfe68019a7eb490a721edc87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPBEQU </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>scond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>amax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPBEQU computes row and column scalings intended to equilibrate a symmetric positive definite band matrix A and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangular of A is stored; = 'L': Lower triangular of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) The upper or lower triangle of the symmetric band matrix A, stored in the first KD+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd).</p>
<p>LDAB (input) INTEGER The leading dimension of the array A. LDAB &gt;= KD+1.</p>
<p>S (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, S contains the scale factors for A.</p>
<p>SCOND (output) DOUBLE PRECISION If INFO = 0, S contains the ratio of the smallest S(i) to the largest S(i). If SCOND &gt;= 0.1 and AMAX is neither too large nor too small, it is not worth scaling by S.</p>
<p>AMAX (output) DOUBLE PRECISION Absolute value of largest matrix element. If AMAX is very close to overflow or very close to underflow, the matrix should be scaled.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if INFO = i, the i-th diagonal element is nonpositive. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a005c6545bfe68019a7eb490a721edc87_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a59fb9381f8029a310e4286c64fe13801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPBRFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>afb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldafb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPBRFS improves the computed solution to a system of linear equations when the coefficient matrix is symmetric positive definite and banded, and provides error bounds and backward error estimates for the solution.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) The upper or lower triangle of the symmetric band matrix A, stored in the first KD+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd).</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD+1.</p>
<p>AFB (input) DOUBLE PRECISION array, dimension (LDAFB,N) The triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T of the band matrix A as computed by DPBTRF, in the same storage format as A (see AB).</p>
<p>LDAFB (input) INTEGER The leading dimension of the array AFB. LDAFB &gt;= KD+1.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS) On entry, the solution matrix X, as computed by DPBTRS. On exit, the improved solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Internal Parameters</h1>
<p>ITMAX is the maximum number of steps of iterative refinement. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a59fb9381f8029a310e4286c64fe13801_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a997e83088744ddb8941ed686c5455bfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPBSTF </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPBSTF computes a split <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization of a real symmetric positive definite band matrix A.</p>
<p>This routine is designed to be used in conjunction with DSBGST.</p>
<p>The factorization has the form A = S**T*S where S is a band matrix of the same bandwidth as A and the following structure:</p>
<p>S = ( U ) ( M L )</p>
<p>where U is upper triangular of order m = (n+kd)/2, and L is lower triangular of order n-m.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB,N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first kd+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd).</p>
<p>On exit, if INFO = 0, the factor S from the split <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = S**T*S. See Further Details.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD+1.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the factorization could not be completed, because the updated element a(i,i) was negative; the matrix A is not positive definite.</p>
<h1>Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when N = 7, KD = 2:</p>
<p>S = ( s11 s12 s13 ) ( s22 s23 s24 ) ( s33 s34 ) ( s44 ) ( s53 s54 s55 ) ( s64 s65 s66 ) ( s75 s76 s77 )</p>
<p>If UPLO = 'U', the array AB holds:</p>
<p>on entry: on exit:</p>
<ul>
<li>* a13 a24 a35 a46 a57 * * s13 s24 s53 s64 s75</li>
<li>a12 a23 a34 a45 a56 a67 * s12 s23 s34 s54 s65 s76 a11 a22 a33 a44 a55 a66 a77 s11 s22 s33 s44 s55 s66 s77</li>
</ul>
<p>If UPLO = 'L', the array AB holds:</p>
<p>on entry: on exit:</p>
<p>a11 a22 a33 a44 a55 a66 a77 s11 s22 s33 s44 s55 s66 s77 a21 a32 a43 a54 a65 a76 * s12 s23 s34 s54 s65 s76 * a31 a42 a53 a64 a64 * * s13 s24 s53 s64 s75 * *</p>
<p>Array elements marked * are not used by the routine. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a997e83088744ddb8941ed686c5455bfa_icgraph.svg" width="307" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="acf538a4c8f96441272a9d72986222d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPBSV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPBSV computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite band matrix and X and B are N-by-NRHS matrices.</p>
<p>The <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> decomposition is used to factor A as A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular band matrix, and L is a lower triangular band matrix, with the same number of superdiagonals or subdiagonals as A. The factored form of A is then used to solve the system of equations A * X = B.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB,N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first KD+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(N,j+KD). See below for further details.</p>
<p>On exit, if INFO = 0, the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T of the band matrix A, in the same storage format as A.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD+1.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if INFO = 0, the N-by-NRHS solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed.</p>
<h1>Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when N = 6, KD = 2, and UPLO = 'U':</p>
<p>On entry: On exit: </p>
<pre class="fragment">*    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
*   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66</p>
<p>Similarly, if UPLO = 'L' the format of A is as follows:</p>
<p>On entry: On exit:</p>
<p>a11 a22 a33 a44 a55 a66 l11 l22 l33 l44 l55 l66 a21 a32 a43 a54 a65 * l21 l32 l43 l54 l65 * a31 a42 a53 a64 * * l31 l42 l53 l64 * *</p>
<p>Array elements marked * are not used by the routine. </p>
<hr/>
<p>.. External Functions .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_acf538a4c8f96441272a9d72986222d35_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa35a456d1d4286c6527d82295172515a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPBSVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>afb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldafb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPBSVX uses the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite band matrix and X and B are N-by-NRHS matrices.</p>
<p>Error bounds on the solution and a condition estimate are also provided.</p>
<h1>Description</h1>
<p>The following steps are performed:</p>
<ol type="1">
<li>If FACT = 'E', real scaling factors are computed to equilibrate the system: diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B Whether or not the system will be equilibrated depends on the scaling of the matrix A, but if equilibration is used, A is overwritten by diag(S)*A*diag(S) and B by diag(S)*B.</li>
</ol>
<ol type="1">
<li>If FACT = 'N' or 'E', the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> decomposition is used to factor the matrix A (after equilibration if FACT = 'E') as A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular band matrix, and L is a lower triangular band matrix.</li>
</ol>
<ol type="1">
<li>If the leading i-by-i principal minor is not positive definite, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A. If the reciprocal of the condition number is less than machine precision, INFO = N+1 is returned as a warning, but the routine still goes on to solve for X and compute error bounds as described below.</li>
</ol>
<ol type="1">
<li>The system of equations is solved for X using the factored form of A.</li>
</ol>
<ol type="1">
<li>Iterative refinement is applied to improve the computed solution matrix and calculate error bounds and backward error estimates for it.</li>
</ol>
<ol type="1">
<li>If equilibration was used, the matrix X is premultiplied by diag(S) so that it solves the original system before equilibration.</li>
</ol>
<h1>Arguments</h1>
<p>FACT (input) CHARACTER*1 Specifies whether or not the factored form of the matrix A is supplied on entry, and if not, whether the matrix A should be equilibrated before it is factored. = 'F': On entry, AFB contains the factored form of A. If EQUED = 'Y', the matrix A has been equilibrated with scaling factors given by S. AB and AFB will not be modified. = 'N': The matrix A will be copied to AFB and factored. = 'E': The matrix A will be equilibrated if necessary, then copied to AFB and factored.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right-hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB,N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first KD+1 rows of the array, except if FACT = 'F' and EQUED = 'Y', then A must contain the equilibrated matrix diag(S)*A*diag(S). The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(N,j+KD). See below for further details.</p>
<p>On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by diag(S)*A*diag(S).</p>
<p>LDAB (input) INTEGER The leading dimension of the array A. LDAB &gt;= KD+1.</p>
<p>AFB (input or output) DOUBLE PRECISION array, dimension (LDAFB,N) If FACT = 'F', then AFB is an input argument and on entry contains the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T of the band matrix A, in the same storage format as A (see AB). If EQUED = 'Y', then AFB is the factored form of the equilibrated matrix A.</p>
<p>If FACT = 'N', then AFB is an output argument and on exit returns the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T.</p>
<p>If FACT = 'E', then AFB is an output argument and on exit returns the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T of the equilibrated matrix A (see the description of A for the form of the equilibrated matrix).</p>
<p>LDAFB (input) INTEGER The leading dimension of the array AFB. LDAFB &gt;= KD+1.</p>
<p>EQUED (input or output) CHARACTER*1 Specifies the form of equilibration that was done. = 'N': No equilibration (always true if FACT = 'N'). = 'Y': Equilibration was done, i.e., A has been replaced by diag(S) * A * diag(S). EQUED is an input argument if FACT = 'F'; otherwise, it is an output argument.</p>
<p>S (input or output) DOUBLE PRECISION array, dimension (N) The scale factors for A; not accessed if EQUED = 'N'. S is an input argument if FACT = 'F'; otherwise, S is an output argument. If FACT = 'F' and EQUED = 'Y', each element of S must be positive.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y', B is overwritten by diag(S) * B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,NRHS) If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to the original system of equations. Note that if EQUED = 'Y', A and B are modified on exit, and the solution to the equilibrated system is inv(diag(S))*X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>RCOND (output) DOUBLE PRECISION The estimate of the reciprocal condition number of the matrix A after equilibration (if done). If RCOND is less than the machine precision (in particular, if RCOND = 0), the matrix is singular to working precision. This condition is indicated by a return code of INFO &gt; 0.</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= N: the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed. RCOND = 0 is returned. = N+1: U is nonsingular, but RCOND is less than machine precision, meaning that the matrix is singular to working precision. Nevertheless, the solution and error bounds are computed because there are a number of situations where the computed solution can be more accurate than the value of RCOND would suggest.</p>
<h1>Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when N = 6, KD = 2, and UPLO = 'U':</p>
<p>Two-dimensional storage of the symmetric matrix A:</p>
<p>a11 a12 a13 a22 a23 a24 a33 a34 a35 a44 a45 a46 a55 a56 (aij=conjg(aji)) a66</p>
<p>Band storage of the upper triangle of A: </p>
<pre class="fragment">*    *   a13  a24  a35  a46
*   a12  a23  a34  a45  a56
</pre><p> a11 a22 a33 a44 a55 a66</p>
<p>Similarly, if UPLO = 'L' the format of A is as follows:</p>
<p>a11 a22 a33 a44 a55 a66 a21 a32 a43 a54 a65 * a31 a42 a53 a64 * *</p>
<p>Array elements marked * are not used by the routine. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa35a456d1d4286c6527d82295172515a_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="afe4e603468da3b258aa4aeef583062eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPBTRF </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPBTRF computes the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization of a real symmetric positive definite band matrix A.</p>
<p>The factorization has the form A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB,N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first KD+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd).</p>
<p>On exit, if INFO = 0, the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T of the band matrix A, in the same storage format as A.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD+1.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the leading minor of order i is not positive definite, and the factorization could not be completed.</p>
<h1>Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when N = 6, KD = 2, and UPLO = 'U':</p>
<p>On entry: On exit: </p>
<pre class="fragment">*    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
*   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66</p>
<p>Similarly, if UPLO = 'L' the format of A is as follows:</p>
<p>On entry: On exit:</p>
<p>a11 a22 a33 a44 a55 a66 l11 l22 l33 l44 l55 l66 a21 a32 a43 a54 a65 * l21 l32 l43 l54 l65 * a31 a42 a53 a64 * * l31 l42 l53 l64 * *</p>
<p>Array elements marked * are not used by the routine.</p>
<p>Contributed by Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989 </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_afe4e603468da3b258aa4aeef583062eb_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7e52e17ca03fc8a2f3bd0f22690e6d44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPBTRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPBTRS solves a system of linear equations A*X = B with a symmetric positive definite band matrix A using the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T computed by DPBTRF.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangular factor stored in AB; = 'L': Lower triangular factor stored in AB.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) The triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T of the band matrix A, stored in the first KD+1 rows of the array. The j-th column of U or L is stored in the j-th column of the array AB as follows: if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO ='L', AB(1+i-j,j) = L(i,j) for j&lt;=i&lt;=min(n,j+kd).</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD+1.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a7e52e17ca03fc8a2f3bd0f22690e6d44_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa94115d396126beb0323fe47d71a1b12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPOCON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPOCON estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite matrix using the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T computed by DPOTRF.</p>
<p>An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, as computed by DPOTRF.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>ANORM (input) DOUBLE PRECISION The 1-norm (or infinity-norm) of the symmetric matrix A.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an estimate of the 1-norm of inv(A) computed in this routine.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa94115d396126beb0323fe47d71a1b12_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8f3bc0fe1281e840ef397a6b3aaef296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPOEQU </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>scond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>amax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPOEQU computes row and column scalings intended to equilibrate a symmetric positive definite matrix A and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The N-by-N symmetric positive definite matrix whose scaling factors are to be computed. Only the diagonal elements of A are referenced.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>S (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, S contains the scale factors for A.</p>
<p>SCOND (output) DOUBLE PRECISION If INFO = 0, S contains the ratio of the smallest S(i) to the largest S(i). If SCOND &gt;= 0.1 and AMAX is neither too large nor too small, it is not worth scaling by S.</p>
<p>AMAX (output) DOUBLE PRECISION Absolute value of largest matrix element. If AMAX is very close to overflow or very close to underflow, the matrix should be scaled.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the i-th diagonal element is nonpositive. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a8f3bc0fe1281e840ef397a6b3aaef296_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="acfd6a5b6e2484454ac7d558a2593e820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPORFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPORFS improves the computed solution to a system of linear equations when the coefficient matrix is symmetric positive definite, and provides error bounds and backward error estimates for the solution.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>AF (input) DOUBLE PRECISION array, dimension (LDAF,N) The triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, as computed by DPOTRF.</p>
<p>LDAF (input) INTEGER The leading dimension of the array AF. LDAF &gt;= max(1,N).</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS) On entry, the solution matrix X, as computed by DPOTRS. On exit, the improved solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Internal Parameters</h1>
<p>ITMAX is the maximum number of steps of iterative refinement. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_acfd6a5b6e2484454ac7d558a2593e820_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a844b9c97630f4e0804dde850a64bc07d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPOSV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPOSV computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite matrix and X and B are N-by-NRHS matrices.</p>
<p>The <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> decomposition is used to factor A as A = U**T* U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is a lower triangular matrix. The factored form of A is then used to solve the system of equations A * X = B.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced.</p>
<p>On exit, if INFO = 0, the factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if INFO = 0, the N-by-NRHS solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed. </p>
<hr/>
<p>.. External Functions .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a844b9c97630f4e0804dde850a64bc07d_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab60ae04b0340d0fcdff4a1bd9b74774b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPOSVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPOSVX uses the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite matrix and X and B are N-by-NRHS matrices.</p>
<p>Error bounds on the solution and a condition estimate are also provided.</p>
<h1>Description</h1>
<p>The following steps are performed:</p>
<ol type="1">
<li>If FACT = 'E', real scaling factors are computed to equilibrate the system: diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B Whether or not the system will be equilibrated depends on the scaling of the matrix A, but if equilibration is used, A is overwritten by diag(S)*A*diag(S) and B by diag(S)*B.</li>
</ol>
<ol type="1">
<li>If FACT = 'N' or 'E', the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> decomposition is used to factor the matrix A (after equilibration if FACT = 'E') as A = U**T* U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is a lower triangular matrix.</li>
</ol>
<ol type="1">
<li>If the leading i-by-i principal minor is not positive definite, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A. If the reciprocal of the condition number is less than machine precision, INFO = N+1 is returned as a warning, but the routine still goes on to solve for X and compute error bounds as described below.</li>
</ol>
<ol type="1">
<li>The system of equations is solved for X using the factored form of A.</li>
</ol>
<ol type="1">
<li>Iterative refinement is applied to improve the computed solution matrix and calculate error bounds and backward error estimates for it.</li>
</ol>
<ol type="1">
<li>If equilibration was used, the matrix X is premultiplied by diag(S) so that it solves the original system before equilibration.</li>
</ol>
<h1>Arguments</h1>
<p>FACT (input) CHARACTER*1 Specifies whether or not the factored form of the matrix A is supplied on entry, and if not, whether the matrix A should be equilibrated before it is factored. = 'F': On entry, AF contains the factored form of A. If EQUED = 'Y', the matrix A has been equilibrated with scaling factors given by S. A and AF will not be modified. = 'N': The matrix A will be copied to AF and factored. = 'E': The matrix A will be equilibrated if necessary, then copied to AF and factored.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the symmetric matrix A, except if FACT = 'F' and EQUED = 'Y', then A must contain the equilibrated matrix diag(S)*A*diag(S). If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. A is not modified if FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.</p>
<p>On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by diag(S)*A*diag(S).</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>AF (input or output) DOUBLE PRECISION array, dimension (LDAF,N) If FACT = 'F', then AF is an input argument and on entry contains the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, in the same storage format as A. If EQUED .ne. 'N', then AF is the factored form of the equilibrated matrix diag(S)*A*diag(S).</p>
<p>If FACT = 'N', then AF is an output argument and on exit returns the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T of the original matrix A.</p>
<p>If FACT = 'E', then AF is an output argument and on exit returns the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T of the equilibrated matrix A (see the description of A for the form of the equilibrated matrix).</p>
<p>LDAF (input) INTEGER The leading dimension of the array AF. LDAF &gt;= max(1,N).</p>
<p>EQUED (input or output) CHARACTER*1 Specifies the form of equilibration that was done. = 'N': No equilibration (always true if FACT = 'N'). = 'Y': Equilibration was done, i.e., A has been replaced by diag(S) * A * diag(S). EQUED is an input argument if FACT = 'F'; otherwise, it is an output argument.</p>
<p>S (input or output) DOUBLE PRECISION array, dimension (N) The scale factors for A; not accessed if EQUED = 'N'. S is an input argument if FACT = 'F'; otherwise, S is an output argument. If FACT = 'F' and EQUED = 'Y', each element of S must be positive.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y', B is overwritten by diag(S) * B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,NRHS) If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to the original system of equations. Note that if EQUED = 'Y', A and B are modified on exit, and the solution to the equilibrated system is inv(diag(S))*X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>RCOND (output) DOUBLE PRECISION The estimate of the reciprocal condition number of the matrix A after equilibration (if done). If RCOND is less than the machine precision (in particular, if RCOND = 0), the matrix is singular to working precision. This condition is indicated by a return code of INFO &gt; 0.</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= N: the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed. RCOND = 0 is returned. = N+1: U is nonsingular, but RCOND is less than machine precision, meaning that the matrix is singular to working precision. Nevertheless, the solution and error bounds are computed because there are a number of situations where the computed solution can be more accurate than the value of RCOND would suggest. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ab60ae04b0340d0fcdff4a1bd9b74774b_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a660e6adeae6b80ff8f9c707f4fe7fe33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPPCON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPPCON estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite packed matrix using the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T computed by DPPTRF.</p>
<p>An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, packed columnwise in a linear array. The j-th column of U or L is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j&lt;=i&lt;=n.</p>
<p>ANORM (input) DOUBLE PRECISION The 1-norm (or infinity-norm) of the symmetric matrix A.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an estimate of the 1-norm of inv(A) computed in this routine.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="ae671a89eb1d7b3c56ba38a20c2c3b6bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPPEQU </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>scond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>amax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPPEQU computes row and column scalings intended to equilibrate a symmetric positive definite matrix A in packed storage and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>S (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, S contains the scale factors for A.</p>
<p>SCOND (output) DOUBLE PRECISION If INFO = 0, S contains the ratio of the smallest S(i) to the largest S(i). If SCOND &gt;= 0.1 and AMAX is neither too large nor too small, it is not worth scaling by S.</p>
<p>AMAX (output) DOUBLE PRECISION Absolute value of largest matrix element. If AMAX is very close to overflow or very close to underflow, the matrix should be scaled.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the i-th diagonal element is nonpositive. </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="ae80d660766514be955218f1b4cd07fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPPRFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>afp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPPRFS improves the computed solution to a system of linear equations when the coefficient matrix is symmetric positive definite and packed, and provides error bounds and backward error estimates for the solution.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>AFP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, as computed by DPPTRF/ZPPTRF, packed columnwise in a linear array in the same format as A (see AP).</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS) On entry, the solution matrix X, as computed by DPPTRS. On exit, the improved solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Internal Parameters</h1>
<p>ITMAX is the maximum number of steps of iterative refinement. </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a85251589adc7788dc939b2031f2f3850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPPSV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPPSV computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite matrix stored in packed format and X and B are N-by-NRHS matrices.</p>
<p>The <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> decomposition is used to factor A as A = U**T* U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is a lower triangular matrix. The factored form of A is then used to solve the system of equations A * X = B.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n. See below for further details.</p>
<p>On exit, if INFO = 0, the factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, in the same storage format as A.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if INFO = 0, the N-by-NRHS solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed.</p>
<h1>Further Details</h1>
<p>The packed storage scheme is illustrated by the following example when N = 4, UPLO = 'U':</p>
<p>Two-dimensional storage of the symmetric matrix A:</p>
<p>a11 a12 a13 a14 a22 a23 a24 a33 a34 (aij = conjg(aji)) a44</p>
<p>Packed storage of the upper triangle of A:</p>
<p>AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ] </p>
<hr/>
<p>.. External Functions .. </p>

</div>
</div>
<a class="anchor" id="ab346569aaa90a9319753e5f5ac5e5c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPPSVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>afp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPPSVX uses the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite matrix stored in packed format and X and B are N-by-NRHS matrices.</p>
<p>Error bounds on the solution and a condition estimate are also provided.</p>
<h1>Description</h1>
<p>The following steps are performed:</p>
<ol type="1">
<li>If FACT = 'E', real scaling factors are computed to equilibrate the system: diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B Whether or not the system will be equilibrated depends on the scaling of the matrix A, but if equilibration is used, A is overwritten by diag(S)*A*diag(S) and B by diag(S)*B.</li>
</ol>
<ol type="1">
<li>If FACT = 'N' or 'E', the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> decomposition is used to factor the matrix A (after equilibration if FACT = 'E') as A = U**T* U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is a lower triangular matrix.</li>
</ol>
<ol type="1">
<li>If the leading i-by-i principal minor is not positive definite, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A. If the reciprocal of the condition number is less than machine precision, INFO = N+1 is returned as a warning, but the routine still goes on to solve for X and compute error bounds as described below.</li>
</ol>
<ol type="1">
<li>The system of equations is solved for X using the factored form of A.</li>
</ol>
<ol type="1">
<li>Iterative refinement is applied to improve the computed solution matrix and calculate error bounds and backward error estimates for it.</li>
</ol>
<ol type="1">
<li>If equilibration was used, the matrix X is premultiplied by diag(S) so that it solves the original system before equilibration.</li>
</ol>
<h1>Arguments</h1>
<p>FACT (input) CHARACTER*1 Specifies whether or not the factored form of the matrix A is supplied on entry, and if not, whether the matrix A should be equilibrated before it is factored. = 'F': On entry, AFP contains the factored form of A. If EQUED = 'Y', the matrix A has been equilibrated with scaling factors given by S. AP and AFP will not be modified. = 'N': The matrix A will be copied to AFP and factored. = 'E': The matrix A will be equilibrated if necessary, then copied to AFP and factored.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array, except if FACT = 'F' and EQUED = 'Y', then A must contain the equilibrated matrix diag(S)*A*diag(S). The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n. See below for further details. A is not modified if FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.</p>
<p>On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by diag(S)*A*diag(S).</p>
<p>AFP (input or output) DOUBLE PRECISION array, dimension (N*(N+1)/2) If FACT = 'F', then AFP is an input argument and on entry contains the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U'*U or A = L*L', in the same storage format as A. If EQUED .ne. 'N', then AFP is the factored form of the equilibrated matrix A.</p>
<p>If FACT = 'N', then AFP is an output argument and on exit returns the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U'*U or A = L*L' of the original matrix A.</p>
<p>If FACT = 'E', then AFP is an output argument and on exit returns the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U'*U or A = L*L' of the equilibrated matrix A (see the description of AP for the form of the equilibrated matrix).</p>
<p>EQUED (input or output) CHARACTER*1 Specifies the form of equilibration that was done. = 'N': No equilibration (always true if FACT = 'N'). = 'Y': Equilibration was done, i.e., A has been replaced by diag(S) * A * diag(S). EQUED is an input argument if FACT = 'F'; otherwise, it is an output argument.</p>
<p>S (input or output) DOUBLE PRECISION array, dimension (N) The scale factors for A; not accessed if EQUED = 'N'. S is an input argument if FACT = 'F'; otherwise, S is an output argument. If FACT = 'F' and EQUED = 'Y', each element of S must be positive.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y', B is overwritten by diag(S) * B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,NRHS) If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to the original system of equations. Note that if EQUED = 'Y', A and B are modified on exit, and the solution to the equilibrated system is inv(diag(S))*X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>RCOND (output) DOUBLE PRECISION The estimate of the reciprocal condition number of the matrix A after equilibration (if done). If RCOND is less than the machine precision (in particular, if RCOND = 0), the matrix is singular to working precision. This condition is indicated by a return code of INFO &gt; 0.</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= N: the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed. RCOND = 0 is returned. = N+1: U is nonsingular, but RCOND is less than machine precision, meaning that the matrix is singular to working precision. Nevertheless, the solution and error bounds are computed because there are a number of situations where the computed solution can be more accurate than the value of RCOND would suggest.</p>
<h1>Further Details</h1>
<p>The packed storage scheme is illustrated by the following example when N = 4, UPLO = 'U':</p>
<p>Two-dimensional storage of the symmetric matrix A:</p>
<p>a11 a12 a13 a14 a22 a23 a24 a33 a34 (aij = conjg(aji)) a44</p>
<p>Packed storage of the upper triangle of A:</p>
<p>AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ] </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a13ee4eb52472b2fb5d6245bde81aacd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPPTRF </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPPTRF computes the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization of a real symmetric positive definite matrix A stored in packed format.</p>
<p>The factorization has the form A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n. See below for further details.</p>
<p>On exit, if INFO = 0, the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, in the same storage format as A.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the leading minor of order i is not positive definite, and the factorization could not be completed.</p>
<p>Further Details ======= =======</p>
<p>The packed storage scheme is illustrated by the following example when N = 4, UPLO = 'U':</p>
<p>Two-dimensional storage of the symmetric matrix A:</p>
<p>a11 a12 a13 a14 a22 a23 a24 a33 a34 (aij = aji) a44</p>
<p>Packed storage of the upper triangle of A:</p>
<p>AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ] </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a852877f1114766bcd0651c7d2358a7ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPPTRI </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPPTRI computes the inverse of a real symmetric positive definite matrix A using the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T computed by DPPTRF.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangular factor is stored in AP; = 'L': Lower triangular factor is stored in AP.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, packed columnwise as a linear array. The j-th column of U or L is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, the upper or lower triangle of the (symmetric) inverse of A, overwriting the input factor U or L.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the (i,i) element of the factor U or L is zero, and the inverse could not be computed. </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a488ec73fb354c46086658a5a81db0ad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPPTRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPPTRS solves a system of linear equations A*X = B with a symmetric positive definite matrix A in packed storage using the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T computed by DPPTRF.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, packed columnwise in a linear array. The j-th column of U or L is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j&lt;=i&lt;=n.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Local Scalars .. </p>

</div>
</div>
<a class="anchor" id="a55abe8cd8a5a69abf978dbf72829e4e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPTCON </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPTCON computes the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite tridiagonal matrix using the factorization A = L*D*L**T or A = U**T*D*U computed by DPTTRF.</p>
<p>Norm(inv(A)) is computed by a direct method, and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>D (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of the diagonal matrix D from the factorization of A, as computed by DPTTRF.</p>
<p>E (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) off-diagonal elements of the unit bidiagonal factor U or L from the factorization of A, as computed by DPTTRF.</p>
<p>ANORM (input) DOUBLE PRECISION The 1-norm of the original matrix A.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the 1-norm of inv(A) computed in this routine.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>The method used is described in Nicholas J. Higham, "Efficient Algorithms for Computing the Condition Number of a Tridiagonal <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a>", SIAM J. Sci. Stat. Comput., Vol. 7, No. 1, January 1986. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a55abe8cd8a5a69abf978dbf72829e4e0_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2b1b70e86ee6317042ac73c6afad4c2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPTEQR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPTEQR computes all eigenvalues and, optionally, eigenvectors of a symmetric positive definite tridiagonal matrix by first factoring the matrix using DPTTRF, and then calling DBDSQR to compute the singular values of the bidiagonal factor.</p>
<p>This routine computes the eigenvalues of the positive definite tridiagonal matrix to high relative accuracy. This means that if the eigenvalues range over many orders of magnitude in size, then the small eigenvalues and corresponding eigenvectors will be computed more accurately than, for example, with the standard <a class="el" href="classpsi_1_1QR.html">QR</a> method.</p>
<p>The eigenvectors of a full or band symmetric positive definite matrix can also be found if DSYTRD, DSPTRD, or DSBTRD has been used to reduce this matrix to tridiagonal form. (The reduction to tridiagonal form, however, may preclude the possibility of obtaining high relative accuracy in the small eigenvalues of the original matrix, if these eigenvalues range over many orders of magnitude.)</p>
<h1>Arguments</h1>
<p>COMPZ (input) CHARACTER*1 = 'N': Compute eigenvalues only. = 'V': Compute eigenvectors of original symmetric matrix also. Array Z contains the orthogonal matrix used to reduce the original matrix to tridiagonal form. = 'I': Compute eigenvectors of tridiagonal matrix also.</p>
<p>N (input) INTEGER The order of the matrix. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the n diagonal elements of the tridiagonal matrix. On normal exit, D contains the eigenvalues, in descending order.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, the (n-1) subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</p>
<p>Z (input/output) DOUBLE PRECISION array, dimension (LDZ, N) On entry, if COMPZ = 'V', the orthogonal matrix used in the reduction to tridiagonal form. On exit, if COMPZ = 'V', the orthonormal eigenvectors of the original symmetric matrix; if COMPZ = 'I', the orthonormal eigenvectors of the tridiagonal matrix. If INFO &gt; 0 on exit, Z contains the eigenvectors associated with only the stored eigenvalues. If COMPZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if COMPZ = 'V' or 'I', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (4*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if INFO = i, and i is: &lt;= N the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization of the matrix could not be performed because the i-th principal minor was not positive definite. &gt; N the SVD algorithm failed to converge; if INFO = N+i, i off-diagonal elements of the bidiagonal factor did not converge to zero. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a2b1b70e86ee6317042ac73c6afad4c2d_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8cc9f6c41708d22ebb9a9613608d5f6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPTRFS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPTRFS improves the computed solution to a system of linear equations when the coefficient matrix is symmetric positive definite and tridiagonal, and provides error bounds and backward error estimates for the solution.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>D (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of the tridiagonal matrix A.</p>
<p>E (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) subdiagonal elements of the tridiagonal matrix A.</p>
<p>DF (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of the diagonal matrix D from the factorization computed by DPTTRF.</p>
<p>EF (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) subdiagonal elements of the unit bidiagonal factor L from the factorization computed by DPTTRF.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS) On entry, the solution matrix X, as computed by DPTTRS. On exit, the improved solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j).</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (2*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Internal Parameters</h1>
<p>ITMAX is the maximum number of steps of iterative refinement. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a8cc9f6c41708d22ebb9a9613608d5f6b_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a57f7f9c2328fd0604879a4f46a995716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPTSV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPTSV computes the solution to a real system of linear equations A*X = B, where A is an N-by-N symmetric positive definite tridiagonal matrix, and X and B are N-by-NRHS matrices.</p>
<p>A is factored as A = L*D*L**T, and the factored form of A is then used to solve the system of equations.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the n diagonal elements of the tridiagonal matrix A. On exit, the n diagonal elements of the diagonal matrix D from the factorization A = L*D*L**T.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, the (n-1) subdiagonal elements of the tridiagonal matrix A. On exit, the (n-1) subdiagonal elements of the unit bidiagonal factor L from the L*D*L**T factorization of A. (E can also be regarded as the superdiagonal of the unit bidiagonal factor U from the U**T*D*U factorization of A.)</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if INFO = 0, the N-by-NRHS solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the leading minor of order i is not positive definite, and the solution has not been computed. The factorization has not been completed unless i = N. </p>
<hr/>
<p>.. External Subroutines .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a57f7f9c2328fd0604879a4f46a995716_icgraph.svg" width="291" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aaf0e36e3511b6aa9272132465988ceed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPTSVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPTSVX uses the factorization A = L*D*L**T to compute the solution to a real system of linear equations A*X = B, where A is an N-by-N symmetric positive definite tridiagonal matrix and X and B are N-by-NRHS matrices.</p>
<p>Error bounds on the solution and a condition estimate are also provided.</p>
<h1>Description</h1>
<p>The following steps are performed:</p>
<ol type="1">
<li>If FACT = 'N', the matrix A is factored as A = L*D*L**T, where L is a unit lower bidiagonal matrix and D is diagonal. The factorization can also be regarded as having the form A = U**T*D*U.</li>
</ol>
<ol type="1">
<li>If the leading i-by-i principal minor is not positive definite, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A. If the reciprocal of the condition number is less than machine precision, INFO = N+1 is returned as a warning, but the routine still goes on to solve for X and compute error bounds as described below.</li>
</ol>
<ol type="1">
<li>The system of equations is solved for X using the factored form of A.</li>
</ol>
<ol type="1">
<li>Iterative refinement is applied to improve the computed solution matrix and calculate error bounds and backward error estimates for it.</li>
</ol>
<h1>Arguments</h1>
<p>FACT (input) CHARACTER*1 Specifies whether or not the factored form of A has been supplied on entry. = 'F': On entry, DF and EF contain the factored form of A. D, E, DF, and EF will not be modified. = 'N': The matrix A will be copied to DF and EF and factored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>D (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of the tridiagonal matrix A.</p>
<p>E (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) subdiagonal elements of the tridiagonal matrix A.</p>
<p>DF (input or output) DOUBLE PRECISION array, dimension (N) If FACT = 'F', then DF is an input argument and on entry contains the n diagonal elements of the diagonal matrix D from the L*D*L**T factorization of A. If FACT = 'N', then DF is an output argument and on exit contains the n diagonal elements of the diagonal matrix D from the L*D*L**T factorization of A.</p>
<p>EF (input or output) DOUBLE PRECISION array, dimension (N-1) If FACT = 'F', then EF is an input argument and on entry contains the (n-1) subdiagonal elements of the unit bidiagonal factor L from the L*D*L**T factorization of A. If FACT = 'N', then EF is an output argument and on exit contains the (n-1) subdiagonal elements of the unit bidiagonal factor L from the L*D*L**T factorization of A.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The N-by-NRHS right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,NRHS) If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal condition number of the matrix A. If RCOND is less than the machine precision (in particular, if RCOND = 0), the matrix is singular to working precision. This condition is indicated by a return code of INFO &gt; 0.</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j).</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (2*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= N: the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed. RCOND = 0 is returned. = N+1: U is nonsingular, but RCOND is less than machine precision, meaning that the matrix is singular to working precision. Nevertheless, the solution and error bounds are computed because there are a number of situations where the computed solution can be more accurate than the value of RCOND would suggest. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aaf0e36e3511b6aa9272132465988ceed_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a721c8451a91e178b2e5a96205338fe25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPTTRF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPTTRF computes the L*D*L' factorization of a real symmetric positive definite tridiagonal matrix A. The factorization may also be regarded as having the form A = U'*D*U.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the n diagonal elements of the tridiagonal matrix A. On exit, the n diagonal elements of the diagonal matrix D from the L*D*L' factorization of A.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, the (n-1) subdiagonal elements of the tridiagonal matrix A. On exit, the (n-1) subdiagonal elements of the unit bidiagonal factor L from the L*D*L' factorization of A. E can also be regarded as the superdiagonal of the unit bidiagonal factor U from the U'*D*U factorization of A.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -k, the k-th argument had an illegal value &gt; 0: if INFO = k, the leading minor of order k is not positive definite; if k &lt; N, the factorization could not be completed, while if k = N, the factorization was completed, but D(N) &lt;= 0. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a721c8451a91e178b2e5a96205338fe25_icgraph.svg" width="307" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a68fc446a6cfd00aaf9691d5625922f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPTTRS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPTTRS solves a tridiagonal system of the form A * X = B using the L*D*L' factorization of A computed by DPTTRF. D is a diagonal matrix specified in the vector D, L is a unit bidiagonal matrix whose subdiagonal is specified in the vector E, and X and B are N by NRHS matrices.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the tridiagonal matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>D (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of the diagonal matrix D from the L*D*L' factorization of A.</p>
<p>E (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) subdiagonal elements of the unit bidiagonal factor L from the L*D*L' factorization of A. E can also be regarded as the superdiagonal of the unit bidiagonal factor U from the factorization A = U'*D*U.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side vectors B for the system of linear equations. On exit, the solution vectors, X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -k, the k-th argument had an illegal value </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a68fc446a6cfd00aaf9691d5625922f4d_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a060b8bee208f53b00d094d33b3e5d113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSBEV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSBEV computes all the eigenvalues and, optionally, eigenvectors of a real symmetric band matrix A.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB, N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first KD+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd).</p>
<p>On exit, AB is overwritten by values generated during the reduction to tridiagonal form. If UPLO = 'U', the first superdiagonal and the diagonal of the tridiagonal matrix T are returned in rows KD and KD+1 of AB, and if UPLO = 'L', the diagonal and first subdiagonal of T are returned in the first two rows of AB.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD + 1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal eigenvectors of the matrix A, with the i-th column of Z holding the eigenvector associated with W(i). If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (max(1,3*N-2))</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a060b8bee208f53b00d094d33b3e5d113_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac23fe05be014c8f6b875dcaccab54594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSBEVD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSBEVD computes all the eigenvalues and, optionally, eigenvectors of a real symmetric band matrix A. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB, N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first KD+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd).</p>
<p>On exit, AB is overwritten by values generated during the reduction to tridiagonal form. If UPLO = 'U', the first superdiagonal and the diagonal of the tridiagonal matrix T are returned in rows KD and KD+1 of AB, and if UPLO = 'L', the diagonal and first subdiagonal of T are returned in the first two rows of AB.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD + 1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal eigenvectors of the matrix A, with the i-th column of Z holding the eigenvector associated with W(i). If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (LWORK) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. IF N &lt;= 1, LWORK must be at least 1. If JOBZ = 'N' and N &gt; 2, LWORK must be at least 2*N. If JOBZ = 'V' and N &gt; 2, LWORK must be at least ( 1 + 5*N + 2*N**2 ).</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array LIWORK. If JOBZ = 'N' or N &lt;= 1, LIWORK must be at least 1. If JOBZ = 'V' and N &gt; 2, LIWORK must be at least 3 + 5*N.</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ac23fe05be014c8f6b875dcaccab54594_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac64b1e06707e6a9ed9cb5e7fbc549fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSBEVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSBEVX computes selected eigenvalues and, optionally, eigenvectors of a real symmetric band matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>RANGE (input) CHARACTER*1 = 'A': all eigenvalues will be found; = 'V': all eigenvalues in the half-open interval (VL,VU] will be found; = 'I': the IL-th through IU-th eigenvalues will be found.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB, N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first KD+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd).</p>
<p>On exit, AB is overwritten by values generated during the reduction to tridiagonal form. If UPLO = 'U', the first superdiagonal and the diagonal of the tridiagonal matrix T are returned in rows KD and KD+1 of AB, and if UPLO = 'L', the diagonal and first subdiagonal of T are returned in the first two rows of AB.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD + 1.</p>
<p>Q (output) DOUBLE PRECISION array, dimension (LDQ, N) If JOBZ = 'V', the N-by-N orthogonal matrix used in the reduction to tridiagonal form. If JOBZ = 'N', the array Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. If JOBZ = 'V', then LDQ &gt;= max(1,N).</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to </p>
<pre class="fragment">    ABSTOL + EPS *   max( |a|,|b| ) ,
</pre><p>where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix obtained by reducing AB to tridiagonal form.</p>
<p>Eigenvalues will be computed most accurately when ABSTOL is set to twice the underflow threshold 2*DLAMCH('S'), not zero. If this routine returns with INFO&gt;0, indicating that some eigenvectors did not converge, try setting ABSTOL to 2*DLAMCH('S').</p>
<p>See "Computing Small Singular Values of Bidiagonal Matrices
        with Guaranteed High Relative Accuracy," by Demmel and Kahan, LAPACK Working Note #3.</p>
<p>M (output) INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) The first M elements contain the selected eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M)) If JOBZ = 'V', then if INFO = 0, the first M columns of Z contain the orthonormal eigenvectors of the matrix A corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). If an eigenvector fails to converge, then that column of Z contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in IFAIL. If JOBZ = 'N', then Z is not referenced. Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = 'V', the exact value of M is not known in advance and an upper bound must be used.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (7*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (5*N)</p>
<p>IFAIL (output) INTEGER array, dimension (N) If JOBZ = 'V', then if INFO = 0, the first M elements of IFAIL are zero. If INFO &gt; 0, then IFAIL contains the indices of the eigenvectors that failed to converge. If JOBZ = 'N', then IFAIL is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if INFO = i, then i eigenvectors failed to converge. Their indices are stored in array IFAIL. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ac64b1e06707e6a9ed9cb5e7fbc549fa0_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="adb5950a185909fd0893a782e7e16d671"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSBGST </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ka</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldbb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSBGST reduces a real symmetric-definite banded generalized eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y, such that C has the same bandwidth as A.</p>
<p>B must have been previously factorized as S**T*S by DPBSTF, using a split <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization. A is overwritten by C = X**T*A*X, where X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the bandwidth of A.</p>
<h1>Arguments</h1>
<p>VECT (input) CHARACTER*1 = 'N': do not form the transformation matrix X; = 'V': form X.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>KA (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KA &gt;= 0.</p>
<p>KB (input) INTEGER The number of superdiagonals of the matrix B if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KA &gt;= KB &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB,N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first ka+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+ka).</p>
<p>On exit, the transformed matrix X**T*A*X, stored in the same format as A.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KA+1.</p>
<p>BB (input) DOUBLE PRECISION array, dimension (LDBB,N) The banded factor S from the split <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization of B, as returned by DPBSTF, stored in the first KB+1 rows of the array.</p>
<p>LDBB (input) INTEGER The leading dimension of the array BB. LDBB &gt;= KB+1.</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,N) If VECT = 'V', the n-by-n matrix X. If VECT = 'N', the array X is not referenced.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N) if VECT = 'V'; LDX &gt;= 1 otherwise.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (2*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_adb5950a185909fd0893a782e7e16d671_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa3eb22d1cae3c55df3a6c840bb21d672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSBGV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ka</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldbb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSBGV computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite banded eigenproblem, of the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and banded, and B is also positive definite.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangles of A and B are stored; = 'L': Lower triangles of A and B are stored.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>KA (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KA &gt;= 0.</p>
<p>KB (input) INTEGER The number of superdiagonals of the matrix B if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KB &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB, N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first ka+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+ka).</p>
<p>On exit, the contents of AB are destroyed.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KA+1.</p>
<p>BB (input/output) DOUBLE PRECISION array, dimension (LDBB, N) On entry, the upper or lower triangle of the symmetric band matrix B, stored in the first kb+1 rows of the array. The j-th column of B is stored in the j-th column of the array BB as follows: if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)&lt;=i&lt;=j; if UPLO = 'L', BB(1+i-j,j) = B(i,j) for j&lt;=i&lt;=min(n,j+kb).</p>
<p>On exit, the factor S from the split <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization B = S**T*S, as returned by DPBSTF.</p>
<p>LDBB (input) INTEGER The leading dimension of the array BB. LDBB &gt;= KB+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of eigenvectors, with the i-th column of Z holding the eigenvector associated with W(i). The eigenvectors are normalized so that Z**T*B*Z = I. If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= N.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is: &lt;= N: the algorithm failed to converge: i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; &gt; N: if INFO = N + i, for 1 &lt;= i &lt;= N, then DPBSTF returned INFO = i: B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed. </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa3eb22d1cae3c55df3a6c840bb21d672_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aaca486852733a72044e767f25ce1571e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSBGVD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ka</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldbb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSBGVD computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite banded eigenproblem, of the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and banded, and B is also positive definite. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangles of A and B are stored; = 'L': Lower triangles of A and B are stored.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>KA (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KA &gt;= 0.</p>
<p>KB (input) INTEGER The number of superdiagonals of the matrix B if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KB &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB, N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first ka+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+ka).</p>
<p>On exit, the contents of AB are destroyed.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KA+1.</p>
<p>BB (input/output) DOUBLE PRECISION array, dimension (LDBB, N) On entry, the upper or lower triangle of the symmetric band matrix B, stored in the first kb+1 rows of the array. The j-th column of B is stored in the j-th column of the array BB as follows: if UPLO = 'U', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)&lt;=i&lt;=j; if UPLO = 'L', BB(1+i-j,j) = B(i,j) for j&lt;=i&lt;=min(n,j+kb).</p>
<p>On exit, the factor S from the split <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization B = S**T*S, as returned by DPBSTF.</p>
<p>LDBB (input) INTEGER The leading dimension of the array BB. LDBB &gt;= KB+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of eigenvectors, with the i-th column of Z holding the eigenvector associated with W(i). The eigenvectors are normalized so Z**T*B*Z = I. If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = 'N' and N &gt; 1, LWORK &gt;= 3*N. If JOBZ = 'V' and N &gt; 1, LWORK &gt;= 1 + 5*N + 2*N**2.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if LIWORK &gt; 0, IWORK(1) returns the optimal LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. If JOBZ = 'N' or N &lt;= 1, LIWORK &gt;= 1. If JOBZ = 'V' and N &gt; 1, LIWORK &gt;= 3 + 5*N.</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is: &lt;= N: the algorithm failed to converge: i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; &gt; N: if INFO = N + i, for 1 &lt;= i &lt;= N, then DPBSTF returned INFO = i: B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed.</p>
<h1>Further Details</h1>
<p>Based on contributions by Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aaca486852733a72044e767f25ce1571e_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a45536e6e57bc1e077d5ff7518ac46e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSBGVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ka</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldbb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSBGVX computes selected eigenvalues, and optionally, eigenvectors of a real generalized symmetric-definite banded eigenproblem, of the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and banded, and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either all eigenvalues, a range of values or a range of indices for the desired eigenvalues.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>RANGE (input) CHARACTER*1 = 'A': all eigenvalues will be found. = 'V': all eigenvalues in the half-open interval (VL,VU] will be found. = 'I': the IL-th through IU-th eigenvalues will be found.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangles of A and B are stored; = 'L': Lower triangles of A and B are stored.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>KA (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KA &gt;= 0.</p>
<p>KB (input) INTEGER The number of superdiagonals of the matrix B if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KB &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB, N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first ka+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+ka).</p>
<p>On exit, the contents of AB are destroyed.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KA+1.</p>
<p>BB (input/output) DOUBLE PRECISION array, dimension (LDBB, N) On entry, the upper or lower triangle of the symmetric band matrix B, stored in the first kb+1 rows of the array. The j-th column of B is stored in the j-th column of the array BB as follows: if UPLO = 'U', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)&lt;=i&lt;=j; if UPLO = 'L', BB(1+i-j,j) = B(i,j) for j&lt;=i&lt;=min(n,j+kb).</p>
<p>On exit, the factor S from the split <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization B = S**T*S, as returned by DPBSTF.</p>
<p>LDBB (input) INTEGER The leading dimension of the array BB. LDBB &gt;= KB+1.</p>
<p>Q (output) DOUBLE PRECISION array, dimension (LDQ, N) If JOBZ = 'V', the n-by-n matrix used in the reduction of A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x, and consequently C to tridiagonal form. If JOBZ = 'N', the array Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. If JOBZ = 'N', LDQ &gt;= 1. If JOBZ = 'V', LDQ &gt;= max(1,N).</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to </p>
<pre class="fragment">    ABSTOL + EPS *   max( |a|,|b| ) ,
</pre><p>where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.</p>
<p>Eigenvalues will be computed most accurately when ABSTOL is set to twice the underflow threshold 2*DLAMCH('S'), not zero. If this routine returns with INFO&gt;0, indicating that some eigenvectors did not converge, try setting ABSTOL to 2*DLAMCH('S').</p>
<p>M (output) INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of eigenvectors, with the i-th column of Z holding the eigenvector associated with W(i). The eigenvectors are normalized so Z**T*B*Z = I. If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (7*N)</p>
<p>IWORK (workspace/output) INTEGER array, dimension (5*N)</p>
<p>IFAIL (output) INTEGER array, dimension (M) If JOBZ = 'V', then if INFO = 0, the first M elements of IFAIL are zero. If INFO &gt; 0, then IFAIL contains the indices of the eigenvalues that failed to converge. If JOBZ = 'N', then IFAIL is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0 : successful exit &lt; 0 : if INFO = -i, the i-th argument had an illegal value &lt;= N: if INFO = i, then i eigenvectors failed to converge. Their indices are stored in IFAIL. &gt; N : DPBSTF returned an error code; i.e., if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading minor of order i of B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed.</p>
<h1>Further Details</h1>
<p>Based on contributions by Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a45536e6e57bc1e077d5ff7518ac46e7f_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="af8ef675ad1d23833b56dcfa08c472a6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSBMV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSBMV performs the matrix-vector operation</p>
<p>y := alpha*A*x + beta*y,</p>
<p>where alpha and beta are scalars, x and y are n element vectors and A is an n by n symmetric band matrix, with k super-diagonals.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the upper or lower triangular part of the band matrix A is being supplied as follows:</p>
<p>UPLO = 'U' or 'u' The upper triangular part of A is being supplied.</p>
<p>UPLO = 'L' or 'l' The lower triangular part of A is being supplied.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>K - INTEGER. On entry, K specifies the number of super-diagonals of the matrix A. K must satisfy 0 .le. K. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the symmetric matrix, supplied column by column, with the leading diagonal of the matrix in row ( k + 1 ) of the array, the first super-diagonal starting at position 2 in row k, and so on. The top left k by k triangle of the array A is not referenced. The following program segment will transfer the upper triangular part of a symmetric band matrix from conventional full matrix storage to band storage: </p>
<pre class="fragment">  DO 20, J = 1, N
     M = K + 1 - J
     DO 10, I = MAX( 1, J - K ), J
        A( M + I, J ) = matrix( I, J )
</pre><p> 10 CONTINUE 20 CONTINUE</p>
<p>Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the symmetric matrix, supplied column by column, with the leading diagonal of the matrix in row 1 of the array, the first sub-diagonal starting at position 1 in row 2, and so on. The bottom right k by k triangle of the array A is not referenced. The following program segment will transfer the lower triangular part of a symmetric band matrix from conventional full matrix storage to band storage: </p>
<pre class="fragment">  DO 20, J = 1, N
     M = 1 - J
     DO 10, I = J, MIN( N, J + K )
        A( M + I, J ) = matrix( I, J )
</pre><p> 10 CONTINUE 20 CONTINUE</p>
<p>Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least ( k + 1 ). Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of DIMENSION at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the vector x. Unchanged on exit.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>BETA - DOUBLE PRECISION. On entry, BETA specifies the scalar beta. Unchanged on exit.</p>
<p>Y - DOUBLE PRECISION array of DIMENSION at least ( 1 + ( n - 1 )*abs( INCY ) ). Before entry, the incremented array Y must contain the vector y. On exit, Y is overwritten by the updated vector y.</p>
<p>INCY - INTEGER. On entry, INCY specifies the increment for the elements of Y. INCY must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_af8ef675ad1d23833b56dcfa08c472a6f_icgraph.svg" width="296" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9471f67f2d911f87d0f884dc5bc6a5fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSBTRD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSBTRD reduces a real symmetric band matrix A to symmetric tridiagonal form T by an orthogonal similarity transformation: Q**T * A * Q = T.</p>
<h1>Arguments</h1>
<p>VECT (input) CHARACTER*1 = 'N': do not form Q; = 'V': form Q; = 'U': update a matrix X, by forming X*Q.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals of the matrix A if UPLO = 'U', or the number of subdiagonals if UPLO = 'L'. KD &gt;= 0.</p>
<p>AB (input/output) DOUBLE PRECISION array, dimension (LDAB,N) On entry, the upper or lower triangle of the symmetric band matrix A, stored in the first KD+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd). On exit, the diagonal elements of AB are overwritten by the diagonal elements of the tridiagonal matrix T; if KD &gt; 0, the elements on the first superdiagonal (if UPLO = 'U') or the first subdiagonal (if UPLO = 'L') are overwritten by the off-diagonal elements of T; the rest of AB is overwritten by values generated during the reduction.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD+1.</p>
<p>D (output) DOUBLE PRECISION array, dimension (N) The diagonal elements of the tridiagonal matrix T.</p>
<p>E (output) DOUBLE PRECISION array, dimension (N-1) The off-diagonal elements of the tridiagonal matrix T: E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.</p>
<p>Q (input/output) DOUBLE PRECISION array, dimension (LDQ,N) On entry, if VECT = 'U', then Q must contain an N-by-N matrix X; if VECT = 'N' or 'V', then Q need not be set.</p>
<p>On exit: if VECT = 'V', Q contains the N-by-N orthogonal matrix Q; if VECT = 'U', Q contains the product X*Q; if VECT = 'N', the array Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= 1, and LDQ &gt;= N if VECT = 'V' or 'U'.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>Modified by Linda Kaufman, Bell Labs. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a9471f67f2d911f87d0f884dc5bc6a5fa_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aef3344df9539b9b6eed9c3969818eb7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSGESV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSGESV computes the solution to a real system of linear equations A * X = B, where A is an N-by-N matrix and X and B are N-by-NRHS matrices.</p>
<p>DSGESV first attempts to factorize the matrix in SINGLE PRECISION and use this factorization within an iterative refinement procedure to produce a solution with DOUBLE PRECISION normwise backward error quality (see below). If the approach fails the method switches to a DOUBLE PRECISION factorization and solve.</p>
<p>The iterative refinement is not going to be a winning strategy if the ratio SINGLE PRECISION performance over DOUBLE PRECISION performance is too small. A reasonable strategy should take the number of right-hand sides and the size of the matrix into account. This might be done with a call to ILAENV in the future. Up to now, we always try iterative refinement.</p>
<p>The iterative refinement process is stopped if ITER &gt; ITERMAX or for all the RHS we have: RNRM &lt; SQRT(N)*XNRM*ANRM*EPS*BWDMAX where o ITER is the number of the current iteration in the iterative refinement process o RNRM is the infinity-norm of the residual o XNRM is the infinity-norm of the solution o ANRM is the infinity-operator-norm of the matrix A o EPS is the machine epsilon returned by DLAMCH('Epsilon') The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00 respectively.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the N-by-N coefficient matrix A. On exit, if iterative refinement has been successfully used (INFO.EQ.0 and ITER.GE.0, see description below), then A is unchanged, if double precision factorization has been used (INFO.EQ.0 and ITER.LT.0, see description below), then the array A contains the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>IPIV (output) INTEGER array, dimension (N) The pivot indices that define the permutation matrix P; row i of the matrix was interchanged with row IPIV(i). Corresponds either to the single precision factorization (if INFO.EQ.0 and ITER.GE.0) or the double precision factorization (if INFO.EQ.0 and ITER.LT.0).</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The N-by-NRHS right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,NRHS) If INFO = 0, the N-by-NRHS solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (N,NRHS) This array is used to hold the residual vectors.</p>
<p>SWORK (workspace) REAL array, dimension (N*(N+NRHS)) This array is used to use the single precision matrix and the right-hand sides or solutions in single precision.</p>
<p>ITER (output) INTEGER &lt; 0: iterative refinement has failed, double precision factorization has been performed -1 : the routine fell back to full precision for implementation- or machine-specific reasons -2 : narrowing the precision induced an overflow, the routine fell back to full precision -3 : failure of SGETRF -31: stop the iterative refinement after the 30th iterations &gt; 0: iterative refinement has been sucessfully used. Returns the number of iterations</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, U(i,i) computed in DOUBLE PRECISION is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution could not be computed. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aef3344df9539b9b6eed9c3969818eb7f_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a079f302685332edb74db4e2b399bdd43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPCON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPCON estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric packed matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by DSPTRF.</p>
<p>An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 Specifies whether the details of the factorization are stored as an upper or lower triangular matrix. = 'U': Upper triangular, form is A = U*D*U**T; = 'L': Lower triangular, form is A = L*D*L**T.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The block diagonal matrix D and the multipliers used to obtain the factor U or L as computed by DSPTRF, stored as a packed triangular matrix.</p>
<p>IPIV (input) INTEGER array, dimension (N) Details of the interchanges and the block structure of D as determined by DSPTRF.</p>
<p>ANORM (input) DOUBLE PRECISION The 1-norm of the original matrix A.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an estimate of the 1-norm of inv(A) computed in this routine.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (2*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a979eb3cbb7c080a18ee092680c1e0982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPEV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPEV computes all the eigenvalues and, optionally, eigenvectors of a real symmetric matrix A in packed storage.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, AP is overwritten by values generated during the reduction to tridiagonal form. If UPLO = 'U', the diagonal and first superdiagonal of the tridiagonal matrix T overwrite the corresponding elements of A, and if UPLO = 'L', the diagonal and first subdiagonal of T overwrite the corresponding elements of A.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal eigenvectors of the matrix A, with the i-th column of Z holding the eigenvector associated with W(i). If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if INFO = i, the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero. </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a17e6125652b2dd217328e1851cc65bed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPEVD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPEVD computes all the eigenvalues and, optionally, eigenvectors of a real symmetric matrix A in packed storage. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, AP is overwritten by values generated during the reduction to tridiagonal form. If UPLO = 'U', the diagonal and first superdiagonal of the tridiagonal matrix T overwrite the corresponding elements of A, and if UPLO = 'L', the diagonal and first subdiagonal of T overwrite the corresponding elements of A.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal eigenvectors of the matrix A, with the i-th column of Z holding the eigenvector associated with W(i). If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (LWORK) On exit, if INFO = 0, WORK(1) returns the required LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If N &lt;= 1, LWORK must be at least 1. If JOBZ = 'N' and N &gt; 1, LWORK must be at least 2*N. If JOBZ = 'V' and N &gt; 1, LWORK must be at least 1 + 6*N + N**2.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the required sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the required LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. If JOBZ = 'N' or N &lt;= 1, LIWORK must be at least 1. If JOBZ = 'V' and N &gt; 1, LIWORK must be at least 3 + 5*N.</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the required sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if INFO = i, the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero. </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="ad8e080eaebf68024c7753e52b94b804b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPEVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPEVX computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A in packed storage. Eigenvalues/vectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>RANGE (input) CHARACTER*1 = 'A': all eigenvalues will be found; = 'V': all eigenvalues in the half-open interval (VL,VU] will be found; = 'I': the IL-th through IU-th eigenvalues will be found.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, AP is overwritten by values generated during the reduction to tridiagonal form. If UPLO = 'U', the diagonal and first superdiagonal of the tridiagonal matrix T overwrite the corresponding elements of A, and if UPLO = 'L', the diagonal and first subdiagonal of T overwrite the corresponding elements of A.</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to </p>
<pre class="fragment">    ABSTOL + EPS *   max( |a|,|b| ) ,
</pre><p>where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix obtained by reducing AP to tridiagonal form.</p>
<p>Eigenvalues will be computed most accurately when ABSTOL is set to twice the underflow threshold 2*DLAMCH('S'), not zero. If this routine returns with INFO&gt;0, indicating that some eigenvectors did not converge, try setting ABSTOL to 2*DLAMCH('S').</p>
<p>See "Computing Small Singular Values of Bidiagonal Matrices
        with Guaranteed High Relative Accuracy," by Demmel and Kahan, LAPACK Working Note #3.</p>
<p>M (output) INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the selected eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M)) If JOBZ = 'V', then if INFO = 0, the first M columns of Z contain the orthonormal eigenvectors of the matrix A corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). If an eigenvector fails to converge, then that column of Z contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in IFAIL. If JOBZ = 'N', then Z is not referenced. Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = 'V', the exact value of M is not known in advance and an upper bound must be used.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (8*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (5*N)</p>
<p>IFAIL (output) INTEGER array, dimension (N) If JOBZ = 'V', then if INFO = 0, the first M elements of IFAIL are zero. If INFO &gt; 0, then IFAIL contains the indices of the eigenvectors that failed to converge. If JOBZ = 'N', then IFAIL is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, then i eigenvectors failed to converge. Their indices are stored in array IFAIL. </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="ad0531dcae3e59b9ec2acbb5aee2e916e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPGST </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPGST reduces a real symmetric-definite generalized eigenproblem to standard form, using packed storage.</p>
<p>If ITYPE = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)</p>
<p>If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.</p>
<p>B must have been previously factorized as U**T*U or L*L**T by DPPTRF.</p>
<h1>Arguments</h1>
<p>ITYPE (input) INTEGER = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T); = 2 or 3: compute U*A*U**T or L**T*A*L.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored and B is factored as U**T*U; = 'L': Lower triangle of A is stored and B is factored as L*L**T.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, if INFO = 0, the transformed matrix, stored in the same format as A.</p>
<p>BP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The triangular factor from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization of B, stored in the same format as A, as returned by DPPTRF.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a3a9cc01d070543fa81c5ab0a0ad65116"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPGV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPGV computes all the eigenvalues and, optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric, stored in packed format, and B is also positive definite.</p>
<h1>Arguments</h1>
<p>ITYPE (input) INTEGER Specifies the problem type to be solved: = 1: A*x = (lambda)*B*x = 2: A*B*x = (lambda)*x = 3: B*A*x = (lambda)*x</p>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangles of A and B are stored; = 'L': Lower triangles of A and B are stored.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, the contents of AP are destroyed.</p>
<p>BP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix B, packed columnwise in a linear array. The j-th column of B is stored in the array BP as follows: if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization B = U**T*U or B = L*L**T, in the same storage format as B.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of eigenvectors. The eigenvectors are normalized as follows: if ITYPE = 1 or 2, Z**T*B*Z = I; if ITYPE = 3, Z**T*inv(B)*Z = I. If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: DPPTRF or DSPEV returned an error code: &lt;= N: if INFO = i, DSPEV failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero. &gt; N: if INFO = n + i, for 1 &lt;= i &lt;= n, then the leading minor of order i of B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed. </p>
<hr/>
<p>.. Local Scalars .. </p>

</div>
</div>
<a class="anchor" id="a1fb3db557e88b7ff4e174d4ff581af44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPGVD </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPGVD computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric, stored in packed format, and B is also positive definite. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<h1>Arguments</h1>
<p>ITYPE (input) INTEGER Specifies the problem type to be solved: = 1: A*x = (lambda)*B*x = 2: A*B*x = (lambda)*x = 3: B*A*x = (lambda)*x</p>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangles of A and B are stored; = 'L': Lower triangles of A and B are stored.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, the contents of AP are destroyed.</p>
<p>BP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix B, packed columnwise in a linear array. The j-th column of B is stored in the array BP as follows: if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization B = U**T*U or B = L*L**T, in the same storage format as B.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of eigenvectors. The eigenvectors are normalized as follows: if ITYPE = 1 or 2, Z**T*B*Z = I; if ITYPE = 3, Z**T*inv(B)*Z = I. If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the required LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = 'N' and N &gt; 1, LWORK &gt;= 2*N. If JOBZ = 'V' and N &gt; 1, LWORK &gt;= 1 + 6*N + 2*N**2.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the required sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the required LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. If JOBZ = 'N' or N &lt;= 1, LIWORK &gt;= 1. If JOBZ = 'V' and N &gt; 1, LIWORK &gt;= 3 + 5*N.</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the required sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: DPPTRF or DSPEVD returned an error code: &lt;= N: if INFO = i, DSPEVD failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; &gt; N: if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading minor of order i of B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed.</p>
<h1>Further Details</h1>
<p>Based on contributions by Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="ae92ec5119f779bf6beab320323c5d8b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPGVX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPGVX computes selected eigenvalues, and optionally, eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric, stored in packed storage, and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<h1>Arguments</h1>
<p>ITYPE (input) INTEGER Specifies the problem type to be solved: = 1: A*x = (lambda)*B*x = 2: A*B*x = (lambda)*x = 3: B*A*x = (lambda)*x</p>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>RANGE (input) CHARACTER*1 = 'A': all eigenvalues will be found. = 'V': all eigenvalues in the half-open interval (VL,VU] will be found. = 'I': the IL-th through IU-th eigenvalues will be found.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A and B are stored; = 'L': Lower triangle of A and B are stored.</p>
<p>N (input) INTEGER The order of the matrix pencil (A,B). N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, the contents of AP are destroyed.</p>
<p>BP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix B, packed columnwise in a linear array. The j-th column of B is stored in the array BP as follows: if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization B = U**T*U or B = L*L**T, in the same storage format as B.</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to </p>
<pre class="fragment">    ABSTOL + EPS *   max( |a|,|b| ) ,
</pre><p>where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.</p>
<p>Eigenvalues will be computed most accurately when ABSTOL is set to twice the underflow threshold 2*DLAMCH('S'), not zero. If this routine returns with INFO&gt;0, indicating that some eigenvectors did not converge, try setting ABSTOL to 2*DLAMCH('S').</p>
<p>M (output) INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) On normal exit, the first M elements contain the selected eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M)) If JOBZ = 'N', then Z is not referenced. If JOBZ = 'V', then if INFO = 0, the first M columns of Z contain the orthonormal eigenvectors of the matrix A corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). The eigenvectors are normalized as follows: if ITYPE = 1 or 2, Z**T*B*Z = I; if ITYPE = 3, Z**T*inv(B)*Z = I.</p>
<p>If an eigenvector fails to converge, then that column of Z contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in IFAIL. Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = 'V', the exact value of M is not known in advance and an upper bound must be used.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (8*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (5*N)</p>
<p>IFAIL (output) INTEGER array, dimension (N) If JOBZ = 'V', then if INFO = 0, the first M elements of IFAIL are zero. If INFO &gt; 0, then IFAIL contains the indices of the eigenvectors that failed to converge. If JOBZ = 'N', then IFAIL is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: DPPTRF or DSPEVX returned an error code: &lt;= N: if INFO = i, DSPEVX failed to converge; i eigenvectors failed to converge. Their indices are stored in array IFAIL. &gt; N: if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading minor of order i of B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed.</p>
<h1>Further Details</h1>
<p>Based on contributions by Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA </p>
<hr/>
 <pre class="fragment">.. Local Scalars ..</pre> 
</div>
</div>
<a class="anchor" id="a578640bdc458d6255fb3574cf44458e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSPMV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPMV performs the matrix-vector operation</p>
<p>y := alpha*A*x + beta*y,</p>
<p>where alpha and beta are scalars, x and y are n element vectors and A is an n by n symmetric matrix, supplied in packed form.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the upper or lower triangular part of the matrix A is supplied in the packed array AP as follows:</p>
<p>UPLO = 'U' or 'u' The upper triangular part of A is supplied in AP.</p>
<p>UPLO = 'L' or 'l' The lower triangular part of A is supplied in AP.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>AP - DOUBLE PRECISION array of DIMENSION at least ( ( n*( n + 1 ) )/2 ). Before entry with UPLO = 'U' or 'u', the array AP must contain the upper triangular part of the symmetric matrix packed sequentially, column by column, so that AP( 1 ) contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) respectively, and so on. Before entry with UPLO = 'L' or 'l', the array AP must contain the lower triangular part of the symmetric matrix packed sequentially, column by column, so that AP( 1 ) contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) respectively, and so on. Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element vector x. Unchanged on exit.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>BETA - DOUBLE PRECISION. On entry, BETA specifies the scalar beta. When BETA is supplied as zero then Y need not be set on input. Unchanged on exit.</p>
<p>Y - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCY ) ). Before entry, the incremented array Y must contain the n element vector y. On exit, Y is overwritten by the updated vector y.</p>
<p>INCY - INTEGER. On entry, INCY specifies the increment for the elements of Y. INCY must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a03dc1454fea66f51e69160ce81c93dad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSPR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPR performs the symmetric rank 1 operation</p>
<p>A := alpha*x*x' + A,</p>
<p>where alpha is a real scalar, x is an n element vector and A is an n by n symmetric matrix, supplied in packed form.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the upper or lower triangular part of the matrix A is supplied in the packed array AP as follows:</p>
<p>UPLO = 'U' or 'u' The upper triangular part of A is supplied in AP.</p>
<p>UPLO = 'L' or 'l' The lower triangular part of A is supplied in AP.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element vector x. Unchanged on exit.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>AP - DOUBLE PRECISION array of DIMENSION at least ( ( n*( n + 1 ) )/2 ). Before entry with UPLO = 'U' or 'u', the array AP must contain the upper triangular part of the symmetric matrix packed sequentially, column by column, so that AP( 1 ) contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) respectively, and so on. On exit, the array AP is overwritten by the upper triangular part of the updated matrix. Before entry with UPLO = 'L' or 'l', the array AP must contain the lower triangular part of the symmetric matrix packed sequentially, column by column, so that AP( 1 ) contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) respectively, and so on. On exit, the array AP is overwritten by the lower triangular part of the updated matrix.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a802f990824aac31392726f25ae485dfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSPR2 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPR2 performs the symmetric rank 2 operation</p>
<p>A := alpha*x*y' + alpha*y*x' + A,</p>
<p>where alpha is a scalar, x and y are n element vectors and A is an n by n symmetric matrix, supplied in packed form.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the upper or lower triangular part of the matrix A is supplied in the packed array AP as follows:</p>
<p>UPLO = 'U' or 'u' The upper triangular part of A is supplied in AP.</p>
<p>UPLO = 'L' or 'l' The lower triangular part of A is supplied in AP.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element vector x. Unchanged on exit.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>Y - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCY ) ). Before entry, the incremented array Y must contain the n element vector y. Unchanged on exit.</p>
<p>INCY - INTEGER. On entry, INCY specifies the increment for the elements of Y. INCY must not be zero. Unchanged on exit.</p>
<p>AP - DOUBLE PRECISION array of DIMENSION at least ( ( n*( n + 1 ) )/2 ). Before entry with UPLO = 'U' or 'u', the array AP must contain the upper triangular part of the symmetric matrix packed sequentially, column by column, so that AP( 1 ) contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) respectively, and so on. On exit, the array AP is overwritten by the upper triangular part of the updated matrix. Before entry with UPLO = 'L' or 'l', the array AP must contain the lower triangular part of the symmetric matrix packed sequentially, column by column, so that AP( 1 ) contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) respectively, and so on. On exit, the array AP is overwritten by the lower triangular part of the updated matrix.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a23efc11886c1bd29767bc02d06e9f925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPRFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>afp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPRFS improves the computed solution to a system of linear equations when the coefficient matrix is symmetric indefinite and packed, and provides error bounds and backward error estimates for the solution.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>AFP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The factored form of the matrix A. AFP contains the block diagonal matrix D and the multipliers used to obtain the factor U or L from the factorization A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as a packed triangular matrix.</p>
<p>IPIV (input) INTEGER array, dimension (N) Details of the interchanges and the block structure of D as determined by DSPTRF.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS) On entry, the solution matrix X, as computed by DSPTRS. On exit, the improved solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Internal Parameters</h1>
<p>ITMAX is the maximum number of steps of iterative refinement. </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="afd1052626c015581134620245f7b9dde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPSV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPSV computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix stored in packed format and X and B are N-by-NRHS matrices.</p>
<p>The diagonal pivoting method is used to factor A as A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then used to solve the system of equations A * X = B.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n. See below for further details.</p>
<p>On exit, the block diagonal matrix D and the multipliers used to obtain the factor U or L from the factorization A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as a packed triangular matrix in the same storage format as A.</p>
<p>IPIV (output) INTEGER array, dimension (N) Details of the interchanges and the block structure of D, as determined by DSPTRF. If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1 diagonal block. If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) = IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if INFO = 0, the N-by-NRHS solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, D(i,i) is exactly zero. The factorization has been completed, but the block diagonal matrix D is exactly singular, so the solution could not be computed.</p>
<h1>Further Details</h1>
<p>The packed storage scheme is illustrated by the following example when N = 4, UPLO = 'U':</p>
<p>Two-dimensional storage of the symmetric matrix A:</p>
<p>a11 a12 a13 a14 a22 a23 a24 a33 a34 (aij = aji) a44</p>
<p>Packed storage of the upper triangle of A:</p>
<p>AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ] </p>
<hr/>
<p>.. External Functions .. </p>

</div>
</div>
<a class="anchor" id="a43c9dd2a9d0c7938487e3004543e49ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPSVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>afp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or A = L*D*L**T to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix stored in packed format and X and B are N-by-NRHS matrices.</p>
<p>Error bounds on the solution and a condition estimate are also provided.</p>
<h1>Description</h1>
<p>The following steps are performed:</p>
<ol type="1">
<li>If FACT = 'N', the diagonal pivoting method is used to factor A as A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</li>
</ol>
<ol type="1">
<li>If some D(i,i)=0, so that D is exactly singular, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A. If the reciprocal of the condition number is less than machine precision, C++ Return value: INFO (output) INTEGER to solve for X and compute error bounds as described below.</li>
</ol>
<ol type="1">
<li>The system of equations is solved for X using the factored form of A.</li>
</ol>
<ol type="1">
<li>Iterative refinement is applied to improve the computed solution matrix and calculate error bounds and backward error estimates for it.</li>
</ol>
<h1>Arguments</h1>
<p>FACT (input) CHARACTER*1 Specifies whether or not the factored form of A has been supplied on entry. = 'F': On entry, AFP and IPIV contain the factored form of A. AP, AFP and IPIV will not be modified. = 'N': The matrix A will be copied to AFP and factored.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n. See below for further details.</p>
<p>AFP (input or output) DOUBLE PRECISION array, dimension (N*(N+1)/2) If FACT = 'F', then AFP is an input argument and on entry contains the block diagonal matrix D and the multipliers used to obtain the factor U or L from the factorization A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as a packed triangular matrix in the same storage format as A.</p>
<p>If FACT = 'N', then AFP is an output argument and on exit contains the block diagonal matrix D and the multipliers used to obtain the factor U or L from the factorization A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as a packed triangular matrix in the same storage format as A.</p>
<p>IPIV (input or output) INTEGER array, dimension (N) If FACT = 'F', then IPIV is an input argument and on entry contains details of the interchanges and the block structure of D, as determined by DSPTRF. If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were interchanged and D(k,k) is a 1-by-1 diagonal block. If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) = IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.</p>
<p>If FACT = 'N', then IPIV is an output argument and on exit contains details of the interchanges and the block structure of D, as determined by DSPTRF.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The N-by-NRHS right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,NRHS) If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>RCOND (output) DOUBLE PRECISION The estimate of the reciprocal condition number of the matrix A. If RCOND is less than the machine precision (in particular, if RCOND = 0), the matrix is singular to working precision. This condition is indicated by a return code of C++ Return value: INFO (output) INTEGER</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= N: D(i,i) is exactly zero. The factorization has been completed but the factor D is exactly singular, so the solution and error bounds could not be computed. RCOND = 0 is returned. = N+1: D is nonsingular, but RCOND is less than machine precision, meaning that the matrix is singular to working precision. Nevertheless, the solution and error bounds are computed because there are a number of situations where the computed solution can be more accurate than the value of RCOND would suggest.</p>
<h1>Further Details</h1>
<p>The packed storage scheme is illustrated by the following example when N = 4, UPLO = 'U':</p>
<p>Two-dimensional storage of the symmetric matrix A:</p>
<p>a11 a12 a13 a14 a22 a23 a24 a33 a34 (aij = aji) a44</p>
<p>Packed storage of the upper triangle of A:</p>
<p>AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ] </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a774be5cf4c97977ee0fbf6d1c9ee6867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPTRD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPTRD reduces a real symmetric matrix A stored in packed form to symmetric tridiagonal form T by an orthogonal similarity transformation: Q**T * A * Q = T.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n. On exit, if UPLO = 'U', the diagonal and first superdiagonal of A are overwritten by the corresponding elements of the tridiagonal matrix T, and the elements above the first superdiagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors; if UPLO = 'L', the diagonal and first subdiagonal of A are over- written by the corresponding elements of the tridiagonal matrix T, and the elements below the first subdiagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</p>
<p>D (output) DOUBLE PRECISION array, dimension (N) The diagonal elements of the tridiagonal matrix T: D(i) = A(i,i).</p>
<p>E (output) DOUBLE PRECISION array, dimension (N-1) The off-diagonal elements of the tridiagonal matrix T: E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (N-1) The scalar factors of the elementary reflectors (see Further Details).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>If UPLO = 'U', the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(n-1) . . . H(2) H(1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in AP, overwriting A(1:i-1,i+1), and tau is stored in TAU(i).</p>
<p>If UPLO = 'L', the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(n-1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in AP, overwriting A(i+2:n,i), and tau is stored in TAU(i). </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a6937933d11e3fd69ef24a18cd506763f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPTRF </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPTRF computes the factorization of a real symmetric matrix A stored in packed format using the Bunch-Kaufman diagonal pivoting method:</p>
<p>A = U*D*U**T or A = L*D*L**T</p>
<p>where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangle of the symmetric matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>On exit, the block diagonal matrix D and the multipliers used to obtain the factor U or L, stored as a packed triangular matrix overwriting A (see below for further details).</p>
<p>IPIV (output) INTEGER array, dimension (N) Details of the interchanges and the block structure of D. If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were interchanged and D(k,k) is a 1-by-1 diagonal block. If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) = IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, D(i,i) is exactly zero. The factorization has been completed, but the block diagonal matrix D is exactly singular, and division by zero will occur if it is used to solve a system of equations.</p>
<h1>Further Details</h1>
<p>5-96 - Based on modifications by J. Lewis, Boeing Computer Services Company</p>
<p>If UPLO = 'U', then A = U*D*U', where U = P(n)*U(n)* ... <em>P(k)U(k)</em> ..., i.e., U is a product of terms P(k)*U(k), where k decreases from n to 1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks D(k). P(k) is a permutation matrix as defined by IPIV(k), and U(k) is a unit upper triangular matrix, such that if the diagonal block D(k) is of order s (s = 1 or 2), then </p>
<pre class="fragment">       (   I    v    0   )   k-s
</pre><p> U(k) = ( 0 I 0 ) s ( 0 0 I ) n-k k-s s n-k</p>
<p>If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k). If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k), and A(k,k), and v overwrites A(1:k-2,k-1:k).</p>
<p>If UPLO = 'L', then A = L*D*L', where L = P(1)*L(1)* ... <em>P(k)*L(k)</em> ..., i.e., L is a product of terms P(k)*L(k), where k increases from 1 to n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks D(k). P(k) is a permutation matrix as defined by IPIV(k), and L(k) is a unit lower triangular matrix, such that if the diagonal block D(k) is of order s (s = 1 or 2), then </p>
<pre class="fragment">       (   I    0     0   )  k-1
</pre><p> L(k) = ( 0 I 0 ) s ( 0 v I ) n-k-s+1 k-1 s n-k-s+1</p>
<p>If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k). If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k), and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1). </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a8b29cf443eeaaed9505c4de7b2864613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPTRI </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPTRI computes the inverse of a real symmetric indefinite matrix A in packed storage using the factorization A = U*D*U**T or A = L*D*L**T computed by DSPTRF.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 Specifies whether the details of the factorization are stored as an upper or lower triangular matrix. = 'U': Upper triangular, form is A = U*D*U**T; = 'L': Lower triangular, form is A = L*D*L**T.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the block diagonal matrix D and the multipliers used to obtain the factor U or L as computed by DSPTRF, stored as a packed triangular matrix.</p>
<p>On exit, if INFO = 0, the (symmetric) inverse of the original matrix, stored as a packed triangular matrix. The j-th column of inv(A) is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j&lt;=i&lt;=n.</p>
<p>IPIV (input) INTEGER array, dimension (N) Details of the interchanges and the block structure of D as determined by DSPTRF.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, D(i,i) = 0; the matrix is singular and its inverse could not be computed. </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a3779f0894c0dfb14147efa365c7878fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSPTRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSPTRS solves a system of linear equations A*X = B with a real symmetric matrix A stored in packed format using the factorization A = U*D*U**T or A = L*D*L**T computed by DSPTRF.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 Specifies whether the details of the factorization are stored as an upper or lower triangular matrix. = 'U': Upper triangular, form is A = U*D*U**T; = 'L': Lower triangular, form is A = L*D*L**T.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The block diagonal matrix D and the multipliers used to obtain the factor U or L as computed by DSPTRF, stored as a packed triangular matrix.</p>
<p>IPIV (input) INTEGER array, dimension (N) Details of the interchanges and the block structure of D as determined by DSPTRF.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a9ccdb2cc0bdadd686c605da111dd32f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSTEBZ </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nsplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>isplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSTEBZ computes the eigenvalues of a symmetric tridiagonal matrix T. The user may ask for all eigenvalues, all eigenvalues in the half-open interval (VL, VU], or the IL-th through IU-th eigenvalues.</p>
<p>To avoid overflow, the matrix must be scaled so that its largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest accuracy, it should not be much smaller than that.</p>
<p>See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
Matrix", Report CS41, Computer Science Dept., Stanford University, July 21, 1966.</p>
<h1>Arguments</h1>
<p>RANGE (input) CHARACTER*1 = 'A': ("All") all eigenvalues will be found. = 'V': ("Value") all eigenvalues in the half-open interval (VL, VU] will be found. = 'I': ("Index") the IL-th through IU-th eigenvalues (of the entire matrix) will be found.</p>
<p>ORDER (input) CHARACTER*1 = 'B': ("By Block") the eigenvalues will be grouped by split-off block (see IBLOCK, ISPLIT) and ordered from smallest to largest within the block. = 'E': ("Entire matrix") the eigenvalues for the entire matrix will be ordered from smallest to largest.</p>
<p>N (input) INTEGER The order of the tridiagonal matrix T. N &gt;= 0.</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. Eigenvalues less than or equal to VL, or greater than VU, will not be returned. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION The absolute tolerance for the eigenvalues. An eigenvalue (or cluster) is considered to be located if it has been determined to lie in an interval whose width is ABSTOL or less. If ABSTOL is less than or equal to zero, then ULP*|T| will be used, where |T| means the 1-norm of T.</p>
<p>Eigenvalues will be computed most accurately when ABSTOL is set to twice the underflow threshold 2*DLAMCH('S'), not zero.</p>
<p>D (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of the tridiagonal matrix T.</p>
<p>E (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) off-diagonal elements of the tridiagonal matrix T.</p>
<p>M (output) INTEGER The actual number of eigenvalues found. 0 &lt;= M &lt;= N. (See also the description of INFO=2,3.)</p>
<p>NSPLIT (output) INTEGER The number of diagonal blocks in the matrix T. 1 &lt;= NSPLIT &lt;= N.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) On exit, the first M elements of W will contain the eigenvalues. (DSTEBZ may use the remaining N-M elements as workspace.)</p>
<p>IBLOCK (output) INTEGER array, dimension (N) At each row/column j where E(j) is zero or small, the matrix T is considered to split into a block diagonal matrix. On exit, if INFO = 0, IBLOCK(i) specifies to which block (from 1 to the number of blocks) the eigenvalue W(i) belongs. (DSTEBZ may use the remaining N-M elements as workspace.)</p>
<p>ISPLIT (output) INTEGER array, dimension (N) The splitting points, at which T breaks up into submatrices. The first submatrix consists of rows/columns 1 to ISPLIT(1), the second of rows/columns ISPLIT(1)+1 through ISPLIT(2), etc., and the NSPLIT-th consists of rows/columns ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N. (Only the first NSPLIT elements will actually be used, but since the user cannot know a priori what value NSPLIT will have, N words must be reserved for ISPLIT.)</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (4*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (3*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: some or all of the eigenvalues failed to converge or were not computed: =1 or 3: Bisection failed to converge for some eigenvalues; these eigenvalues are flagged by a negative block number. The effect is that the eigenvalues may not be as accurate as the absolute and relative tolerances. This is generally caused by unexpectedly inaccurate arithmetic. =2 or 3: RANGE='I' only: Not all of the eigenvalues IL:IU were found. Effect: M &lt; IU+1-IL Cause: non-monotonic arithmetic, causing the Sturm sequence to be non-monotonic. Cure: recalculate, using RANGE='A', and pick out eigenvalues IL:IU. In some cases, increasing the PARAMETER "FUDGE" may make things work. = 4: RANGE='I', and the Gershgorin interval initially used was too small. No eigenvalues were computed. Probable cause: your machine has sloppy floating-point arithmetic. Cure: Increase the PARAMETER "FUDGE", recompile, and try again.</p>
<h1>Internal Parameters</h1>
<p>RELFAC DOUBLE PRECISION, default = 2.0e0 The relative tolerance. An interval (a,b] lies within "relative tolerance" if b-a &lt; RELFAC*ulp*max(|a|,|b|), where "ulp" is the machine precision (distance from 1 to the next larger floating point number.)</p>
<p>FUDGE DOUBLE PRECISION, default = 2 A "fudge factor" to widen the Gershgorin intervals. Ideally, a value of 1 should work, but on machines with sloppy arithmetic, this needs to be larger. The default for publicly released versions should be large enough to handle the worst machine around. Note that this has no effect on accuracy of the solution. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a9ccdb2cc0bdadd686c605da111dd32f7_icgraph.svg" width="307" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a12fcb3a924dac52b996f73bbb389fc19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSTEDC </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSTEDC computes all eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. The eigenvectors of a full or band real symmetric matrix can also be found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to tridiagonal form.</p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See DLAED3 for details.</p>
<h1>Arguments</h1>
<p>COMPZ (input) CHARACTER*1 = 'N': Compute eigenvalues only. = 'I': Compute eigenvectors of tridiagonal matrix also. = 'V': Compute eigenvectors of original dense symmetric matrix also. On entry, Z contains the orthogonal matrix used to reduce the original matrix to tridiagonal form.</p>
<p>N (input) INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</p>
<p>Z (input/output) DOUBLE PRECISION array, dimension (LDZ,N) On entry, if COMPZ = 'V', then Z contains the orthogonal matrix used in the reduction to tridiagonal form. On exit, if INFO = 0, then if COMPZ = 'V', Z contains the orthonormal eigenvectors of the original symmetric matrix, and if COMPZ = 'I', Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix. If COMPZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1. If eigenvectors are desired, then LDZ &gt;= max(1,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (LWORK) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If COMPZ = 'N' or N &lt;= 1 then LWORK must be at least 1. If COMPZ = 'V' and N &gt; 1 then LWORK must be at least ( 1 + 3*N + 2*N*lg N + 3*N**2 ), where lg( N ) = smallest integer k such that 2**k &gt;= N. If COMPZ = 'I' and N &gt; 1 then LWORK must be at least ( 1 + 4*N + N**2 ). Note that for COMPZ = 'I' or 'V', then if N is less than or equal to the minimum divide size, usually 25, then LWORK need only be max(1,2*(N-1)).</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. If COMPZ = 'N' or N &lt;= 1 then LIWORK must be at least 1. If COMPZ = 'V' and N &gt; 1 then LIWORK must be at least ( 6 + 6*N + 5*N*lg N ). If COMPZ = 'I' and N &gt; 1 then LIWORK must be at least ( 3 + 5*N ). Note that for COMPZ = 'I' or 'V', then if N is less than or equal to the minimum divide size, usually 25, then LIWORK need only be 1.</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the IWORK array, returns this value as the first entry of the IWORK array, and no error message related to LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns C++ Return value: INFO (output) INTEGER</p>
<h1>Further Details</h1>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA Modified by Francoise Tisseur, University of Tennessee. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a12fcb3a924dac52b996f73bbb389fc19_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad6c2f4488a32b7a0d137300a5f052b32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSTEGR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>isuppz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSTEGR computes selected eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix T. Any such unreduced matrix has a well defined set of pairwise different real eigenvalues, the corresponding real eigenvectors are pairwise orthogonal.</p>
<p>The spectrum may be computed either completely or partially by specifying either an interval (VL,VU] or a range of indices IL:IU for the desired eigenvalues.</p>
<p>DSTEGR is a compatability wrapper around the improved DSTEMR routine. See DSTEMR for further details.</p>
<p>One important change is that the ABSTOL parameter no longer provides any benefit and hence is no longer used.</p>
<p>Note : DSTEGR and DSTEMR work only on machines which follow IEEE-754 floating-point standard in their handling of infinities and NaNs. Normal execution may create these exceptiona values and hence may abort due to a floating point exception in environments which do not conform to the IEEE-754 standard.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>RANGE (input) CHARACTER*1 = 'A': all eigenvalues will be found. = 'V': all eigenvalues in the half-open interval (VL,VU] will be found. = 'I': the IL-th through IU-th eigenvalues will be found.</p>
<p>N (input) INTEGER The order of the matrix. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the N diagonal elements of the tridiagonal matrix T. On exit, D is overwritten.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N) On entry, the (N-1) subdiagonal elements of the tridiagonal matrix T in elements 1 to N-1 of E. E(N) need not be set on input, but is used internally as workspace. On exit, E is overwritten.</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION Unused. Was the absolute error tolerance for the eigenvalues/eigenvectors in previous versions.</p>
<p>M (output) INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) The first M elements contain the selected eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M) ) If JOBZ = 'V', and if INFO = 0, then the first M columns of Z contain the orthonormal eigenvectors of the matrix T corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). If JOBZ = 'N', then Z is not referenced. Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = 'V', the exact value of M is not known in advance and an upper bound must be used. Supplying N columns is always safe.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', then LDZ &gt;= max(1,N).</p>
<p>ISUPPZ (output) INTEGER ARRAY, dimension ( 2*max(1,M) ) The support of the eigenvectors in Z, i.e., the indices indicating the nonzero elements in Z. The i-th computed eigenvector is nonzero only in elements ISUPPZ( 2*i-1 ) through ISUPPZ( 2*i ). This is relevant in the case when the matrix is split. ISUPPZ is only accessed when JOBZ is 'V' and N &gt; 0.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (LWORK) On exit, if INFO = 0, WORK(1) returns the optimal (and minimal) LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,18*N) if JOBZ = 'V', and LWORK &gt;= max(1,12*N) if JOBZ = 'N'. If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (LIWORK) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. LIWORK &gt;= max(1,10*N) if the eigenvectors are desired, and LIWORK &gt;= max(1,8*N) if only the eigenvalues are to be computed. If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the IWORK array, returns this value as the first entry of the IWORK array, and no error message related to LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER On exit, INFO = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = 1X, internal error in DLARRE, if INFO = 2X, internal error in DLARRV. Here, the digit X = ABS( IINFO ) &lt; 10, where IINFO is the nonzero error code returned by DLARRE or DLARRV, respectively.</p>
<h1>Further Details</h1>
<p>Based on contributions by Inderjit Dhillon, IBM Almaden, USA Osni Marques, LBNL/NERSC, USA Christof Voemel, LBNL/NERSC, USA </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ad6c2f4488a32b7a0d137300a5f052b32_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ade618e86ec14c482f06a940503d5f4db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSTEIN </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>isplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSTEIN computes the eigenvectors of a real symmetric tridiagonal matrix T corresponding to specified eigenvalues, using inverse iteration.</p>
<p>The maximum number of iterations allowed for each eigenvector is specified by an internal parameter MAXITS (currently set to 5).</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix. N &gt;= 0.</p>
<p>D (input) DOUBLE PRECISION array, dimension (N) The n diagonal elements of the tridiagonal matrix T.</p>
<p>E (input) DOUBLE PRECISION array, dimension (N-1) The (n-1) subdiagonal elements of the tridiagonal matrix T, in elements 1 to N-1.</p>
<p>M (input) INTEGER The number of eigenvectors to be found. 0 &lt;= M &lt;= N.</p>
<p>W (input) DOUBLE PRECISION array, dimension (N) The first M elements of W contain the eigenvalues for which eigenvectors are to be computed. The eigenvalues should be grouped by split-off block and ordered from smallest to largest within the block. ( The output array W from DSTEBZ with ORDER = 'B' is expected here. )</p>
<p>IBLOCK (input) INTEGER array, dimension (N) The submatrix indices associated with the corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to the first submatrix from the top, =2 if W(i) belongs to the second submatrix, etc. ( The output array IBLOCK from DSTEBZ is expected here. )</p>
<p>ISPLIT (input) INTEGER array, dimension (N) The splitting points, at which T breaks up into submatrices. The first submatrix consists of rows/columns 1 to ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1 through ISPLIT( 2 ), etc. ( The output array ISPLIT from DSTEBZ is expected here. )</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, M) The computed eigenvectors. The eigenvector associated with the eigenvalue W(i) is stored in the i-th column of Z. Any vector which fails to converge is set to its current iterate after MAXITS iterations.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (5*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>IFAIL (output) INTEGER array, dimension (M) On normal exit, all elements of IFAIL are zero. If one or more eigenvectors fail to converge after MAXITS iterations, then their indices are stored in array IFAIL.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, then i eigenvectors failed to converge in MAXITS iterations. Their indices are stored in array IFAIL.</p>
<h1>Internal Parameters</h1>
<p>MAXITS INTEGER, default = 5 The maximum number of iterations performed.</p>
<p>EXTRA INTEGER, default = 2 The number of iterations performed after norm growth criterion is satisfied, should be at least 1. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ade618e86ec14c482f06a940503d5f4db_icgraph.svg" width="302" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a849a6e07d46f18b6f3f77bf1ee1cd2b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSTEQR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSTEQR computes all eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the implicit QL or <a class="el" href="classpsi_1_1QR.html">QR</a> method. The eigenvectors of a full or band symmetric matrix can also be found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to tridiagonal form.</p>
<h1>Arguments</h1>
<p>COMPZ (input) CHARACTER*1 = 'N': Compute eigenvalues only. = 'V': Compute eigenvalues and eigenvectors of the original symmetric matrix. On entry, Z must contain the orthogonal matrix used to reduce the original matrix to tridiagonal form. = 'I': Compute eigenvalues and eigenvectors of the tridiagonal matrix. Z is initialized to the identity matrix.</p>
<p>N (input) INTEGER The order of the matrix. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, the (n-1) subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</p>
<p>Z (input/output) DOUBLE PRECISION array, dimension (LDZ, N) On entry, if COMPZ = 'V', then Z contains the orthogonal matrix used in the reduction to tridiagonal form. On exit, if INFO = 0, then if COMPZ = 'V', Z contains the orthonormal eigenvectors of the original symmetric matrix, and if COMPZ = 'I', Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix. If COMPZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if eigenvectors are desired, then LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (max(1,2*N-2)) If COMPZ = 'N', then WORK is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: the algorithm has failed to find all the eigenvalues in a total of 30*N iterations; if INFO = i, then i elements of E have not converged to zero; on exit, D and E contain the elements of a symmetric tridiagonal matrix which is orthogonally similar to the original matrix. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a849a6e07d46f18b6f3f77bf1ee1cd2b0_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3208e0c14fb60d2616eee866b52d2345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSTERF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSTERF computes all eigenvalues of a symmetric tridiagonal matrix using the Pal-Walker-Kahan variant of the QL or <a class="el" href="classpsi_1_1QR.html">QR</a> algorithm.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the n diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, the (n-1) subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: the algorithm failed to find all of the eigenvalues in a total of 30*N iterations; if INFO = i, then i elements of E have not converged to zero. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a3208e0c14fb60d2616eee866b52d2345_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a09ee20a7469bddcbbdb23004fd00eec2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSTEV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSTEV computes all eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix A.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>N (input) INTEGER The order of the matrix. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the n diagonal elements of the tridiagonal matrix A. On exit, if INFO = 0, the eigenvalues in ascending order.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, the (n-1) subdiagonal elements of the tridiagonal matrix A, stored in elements 1 to N-1 of E. On exit, the contents of E are destroyed.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal eigenvectors of the matrix A, with the i-th column of Z holding the eigenvector associated with D(i). If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (max(1,2*N-2)) If JOBZ = 'N', WORK is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the algorithm failed to converge; i off-diagonal elements of E did not converge to zero. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a09ee20a7469bddcbbdb23004fd00eec2_icgraph.svg" width="291" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0053713408e9efb4c356ad2385b957d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSTEVD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSTEVD computes all eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>N (input) INTEGER The order of the matrix. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the n diagonal elements of the tridiagonal matrix A. On exit, if INFO = 0, the eigenvalues in ascending order.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (N-1) On entry, the (n-1) subdiagonal elements of the tridiagonal matrix A, stored in elements 1 to N-1 of E. On exit, the contents of E are destroyed.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, N) If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal eigenvectors of the matrix A, with the i-th column of Z holding the eigenvector associated with D(i). If JOBZ = 'N', then Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (LWORK) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If JOBZ = 'N' or N &lt;= 1 then LWORK must be at least 1. If JOBZ = 'V' and N &gt; 1 then LWORK must be at least ( 1 + 4*N + N**2 ).</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. If JOBZ = 'N' or N &lt;= 1 then LIWORK must be at least 1. If JOBZ = 'V' and N &gt; 1 then LIWORK must be at least 3+5*N.</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the algorithm failed to converge; i off-diagonal elements of E did not converge to zero. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a0053713408e9efb4c356ad2385b957d9_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a662f3a711c2da8007259f3bb307880f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSTEVR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>isuppz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSTEVR computes selected eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix T. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<p>Whenever possible, DSTEVR calls DSTEMR to compute the eigenspectrum using Relatively Robust Representations. DSTEMR computes eigenvalues by the dqds algorithm, while orthogonal eigenvectors are computed from various "good" L D L^T representations (also known as Relatively Robust Representations). Gram-Schmidt orthogonalization is avoided as far as possible. More specifically, the various steps of the algorithm are as follows. For the i-th unreduced block of T, (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T is a relatively robust representation, (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high relative accuracy by the dqds algorithm, (c) If there is a cluster of close eigenvalues, "choose" sigma_i close to the cluster, and go to step (a), (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T, compute the corresponding eigenvector by forming a rank-revealing twisted factorization. The desired accuracy of the output can be specified by the input parameter ABSTOL.</p>
<p>For more details, see "A new O(n^2) algorithm for the symmetric
tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon, Computer Science Division Technical Report No. UCB//CSD-97-971, UC Berkeley, May 1997.</p>
<p>Note 1 : DSTEVR calls DSTEMR when the full spectrum is requested on machines which conform to the ieee-754 floating point standard. DSTEVR calls DSTEBZ and DSTEIN on non-ieee machines and when partial spectrum requests are made.</p>
<p>Normal execution of DSTEMR may create NaNs and infinities and hence may abort due to a floating point exception in environments which do not handle NaNs and infinities in the ieee standard default manner.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>RANGE (input) CHARACTER*1 = 'A': all eigenvalues will be found. = 'V': all eigenvalues in the half-open interval (VL,VU] will be found. = 'I': the IL-th through IU-th eigenvalues will be found. For RANGE = 'V' or 'I' and IU - IL &lt; N - 1, DSTEBZ and DSTEIN are called</p>
<p>N (input) INTEGER The order of the matrix. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the n diagonal elements of the tridiagonal matrix A. On exit, D may be multiplied by a constant factor chosen to avoid over/underflow in computing the eigenvalues.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (max(1,N-1)) On entry, the (n-1) subdiagonal elements of the tridiagonal matrix A in elements 1 to N-1 of E. On exit, E may be multiplied by a constant factor chosen to avoid over/underflow in computing the eigenvalues.</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to </p>
<pre class="fragment">    ABSTOL + EPS *   max( |a|,|b| ) ,
</pre><p>where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.</p>
<p>See "Computing Small Singular Values of Bidiagonal Matrices
        with Guaranteed High Relative Accuracy," by Demmel and Kahan, LAPACK Working Note #3.</p>
<p>If high relative accuracy is important, set ABSTOL to DLAMCH( 'Safe minimum' ). Doing so will guarantee that eigenvalues are computed to high relative accuracy when possible in future releases. The current code does not make any guarantees about high relative accuracy, but future releases will. See J. Barlow and J. Demmel, "Computing Accurate Eigensystems of Scaled Diagonally
        Dominant Matrices", LAPACK Working Note #7, for a discussion of which matrices define their eigenvalues to high relative accuracy.</p>
<p>M (output) INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) The first M elements contain the selected eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M) ) If JOBZ = 'V', then if INFO = 0, the first M columns of Z contain the orthonormal eigenvectors of the matrix A corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = 'V', the exact value of M is not known in advance and an upper bound must be used.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>ISUPPZ (output) INTEGER array, dimension ( 2*max(1,M) ) The support of the eigenvectors in Z, i.e., the indices indicating the nonzero elements in Z. The i-th eigenvector is nonzero only in elements ISUPPZ( 2*i-1 ) through ISUPPZ( 2*i ). Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal (and minimal) LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,20*N).</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal (and minimal) LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. LIWORK &gt;= max(1,10*N).</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: Internal error</p>
<h1>Further Details</h1>
<p>Based on contributions by Inderjit Dhillon, IBM Almaden, USA Osni Marques, LBNL/NERSC, USA Ken Stanley, Computer Science Division, University of California at Berkeley, USA </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a662f3a711c2da8007259f3bb307880f5_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8b6fcd02cab491aac4ca96996b9eda50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSTEVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSTEVX computes selected eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>RANGE (input) CHARACTER*1 = 'A': all eigenvalues will be found. = 'V': all eigenvalues in the half-open interval (VL,VU] will be found. = 'I': the IL-th through IU-th eigenvalues will be found.</p>
<p>N (input) INTEGER The order of the matrix. N &gt;= 0.</p>
<p>D (input/output) DOUBLE PRECISION array, dimension (N) On entry, the n diagonal elements of the tridiagonal matrix A. On exit, D may be multiplied by a constant factor chosen to avoid over/underflow in computing the eigenvalues.</p>
<p>E (input/output) DOUBLE PRECISION array, dimension (max(1,N-1)) On entry, the (n-1) subdiagonal elements of the tridiagonal matrix A in elements 1 to N-1 of E. On exit, E may be multiplied by a constant factor chosen to avoid over/underflow in computing the eigenvalues.</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to </p>
<pre class="fragment">    ABSTOL + EPS *   max( |a|,|b| ) ,
</pre><p>where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix.</p>
<p>Eigenvalues will be computed most accurately when ABSTOL is set to twice the underflow threshold 2*DLAMCH('S'), not zero. If this routine returns with INFO&gt;0, indicating that some eigenvectors did not converge, try setting ABSTOL to 2*DLAMCH('S').</p>
<p>See "Computing Small Singular Values of Bidiagonal Matrices
        with Guaranteed High Relative Accuracy," by Demmel and Kahan, LAPACK Working Note #3.</p>
<p>M (output) INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) The first M elements contain the selected eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M) ) If JOBZ = 'V', then if INFO = 0, the first M columns of Z contain the orthonormal eigenvectors of the matrix A corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). If an eigenvector fails to converge (INFO &gt; 0), then that column of Z contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in IFAIL. If JOBZ = 'N', then Z is not referenced. Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = 'V', the exact value of M is not known in advance and an upper bound must be used.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (5*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (5*N)</p>
<p>IFAIL (output) INTEGER array, dimension (N) If JOBZ = 'V', then if INFO = 0, the first M elements of IFAIL are zero. If INFO &gt; 0, then IFAIL contains the indices of the eigenvectors that failed to converge. If JOBZ = 'N', then IFAIL is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, then i eigenvectors failed to converge. Their indices are stored in array IFAIL. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a8b6fcd02cab491aac4ca96996b9eda50_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a389a81cbc866e8dee641f73d681da8c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYCON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYCON estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by DSYTRF.</p>
<p>An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 Specifies whether the details of the factorization are stored as an upper or lower triangular matrix. = 'U': Upper triangular, form is A = U*D*U**T; = 'L': Lower triangular, form is A = L*D*L**T.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The block diagonal matrix D and the multipliers used to obtain the factor U or L as computed by DSYTRF.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>IPIV (input) INTEGER array, dimension (N) Details of the interchanges and the block structure of D as determined by DSYTRF.</p>
<p>ANORM (input) DOUBLE PRECISION The 1-norm of the original matrix A.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an estimate of the 1-norm of inv(A) computed in this routine.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (2*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a389a81cbc866e8dee641f73d681da8c2_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0f2fc4438a32f99205642062ddafe9d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYEVD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYEVD computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<p>Because of large use of BLAS of level 3, DSYEVD needs N**2 more workspace than DSYEVX.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, if JOBZ = 'V', then if INFO = 0, A contains the orthonormal eigenvectors of the matrix A. If JOBZ = 'N', then on exit the lower triangle (if UPLO='L') or the upper triangle (if UPLO='U') of A, including the diagonal, is destroyed.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (LWORK) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If N &lt;= 1, LWORK must be at least 1. If JOBZ = 'N' and N &gt; 1, LWORK must be at least 2*N+1. If JOBZ = 'V' and N &gt; 1, LWORK must be at least 1 + 6*N + 2*N**2.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. If N &lt;= 1, LIWORK must be at least 1. If JOBZ = 'N' and N &gt; 1, LIWORK must be at least 1. If JOBZ = 'V' and N &gt; 1, LIWORK must be at least 3 + 5*N.</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i and JOBZ = 'N', then the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; if INFO = i and JOBZ = 'V', then the algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</p>
<h1>Further Details</h1>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA Modified by Francoise Tisseur, University of Tennessee.</p>
<h1>Modified description of INFO. Sven, 16 Feb 05.</h1>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a0f2fc4438a32f99205642062ddafe9d0_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4621af093a70f5fb7b86c2a11012c721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYEVR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>isuppz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYEVR computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<p>DSYEVR first reduces the matrix A to tridiagonal form T with a call to DSYTRD. Then, whenever possible, DSYEVR calls DSTEMR to compute the eigenspectrum using Relatively Robust Representations. DSTEMR computes eigenvalues by the dqds algorithm, while orthogonal eigenvectors are computed from various "good" L D L^T representations (also known as Relatively Robust Representations). Gram-Schmidt orthogonalization is avoided as far as possible. More specifically, the various steps of the algorithm are as follows.</p>
<p>For each unreduced block (submatrix) of T, (a) Compute T - sigma I = L D L^T, so that L and D define all the wanted eigenvalues to high relative accuracy. This means that small relative changes in the entries of D and L cause only small relative changes in the eigenvalues and eigenvectors. The standard (unfactored) representation of the tridiagonal matrix T does not have this property in general. (b) Compute the eigenvalues to suitable accuracy. If the eigenvectors are desired, the algorithm attains full accuracy of the computed eigenvalues only right before the corresponding vectors have to be computed, see steps c) and d). (c) For each cluster of close eigenvalues, select a new shift close to the cluster, find a new factorization, and refine the shifted eigenvalues to suitable accuracy. (d) For each eigenvalue with a large enough relative separation compute the corresponding eigenvector by forming a rank revealing twisted factorization. Go back to (c) for any clusters that remain.</p>
<p>The desired accuracy of the output can be specified by the input parameter ABSTOL.</p>
<p>For more details, see DSTEMR's documentation and:</p>
<ul>
<li>Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
   to compute orthogonal eigenvectors of symmetric tridiagonal matrices," Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.</li>
<li>Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
   Relative Gaps," SIAM Journal on <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Analysis and Applications, Vol. 25,<ol type="1">
<li>Also LAPACK Working Note 154.</li>
</ol>
</li>
<li>Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
   tridiagonal eigenvalue/eigenvector problem", Computer Science Division Technical Report No. UCB/CSD-97-971, UC Berkeley, May 1997.</li>
</ul>
<p>Note 1 : DSYEVR calls DSTEMR when the full spectrum is requested on machines which conform to the ieee-754 floating point standard. DSYEVR calls DSTEBZ and SSTEIN on non-ieee machines and when partial spectrum requests are made.</p>
<p>Normal execution of DSTEMR may create NaNs and infinities and hence may abort due to a floating point exception in environments which do not handle NaNs and infinities in the ieee standard default manner.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>RANGE (input) CHARACTER*1 = 'A': all eigenvalues will be found. = 'V': all eigenvalues in the half-open interval (VL,VU] will be found. = 'I': the IL-th through IU-th eigenvalues will be found. For RANGE = 'V' or 'I' and IU - IL &lt; N - 1, DSTEBZ and DSTEIN are called</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, the lower triangle (if UPLO='L') or the upper triangle (if UPLO='U') of A, including the diagonal, is destroyed.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to </p>
<pre class="fragment">    ABSTOL + EPS *   max( |a|,|b| ) ,
</pre><p>where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.</p>
<p>See "Computing Small Singular Values of Bidiagonal Matrices
         with Guaranteed High Relative Accuracy," by Demmel and Kahan, LAPACK Working Note #3.</p>
<p>If high relative accuracy is important, set ABSTOL to DLAMCH( 'Safe minimum' ). Doing so will guarantee that eigenvalues are computed to high relative accuracy when possible in future releases. The current code does not make any guarantees about high relative accuracy, but future releases will. See J. Barlow and J. Demmel, "Computing Accurate Eigensystems of Scaled Diagonally
         Dominant Matrices", LAPACK Working Note #7, for a discussion of which matrices define their eigenvalues to high relative accuracy.</p>
<p>M (output) INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) The first M elements contain the selected eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M)) If JOBZ = 'V', then if INFO = 0, the first M columns of Z contain the orthonormal eigenvectors of the matrix A corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). If JOBZ = 'N', then Z is not referenced. Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = 'V', the exact value of M is not known in advance and an upper bound must be used. Supplying N columns is always safe.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>ISUPPZ (output) INTEGER array, dimension ( 2*max(1,M) ) The support of the eigenvectors in Z, i.e., the indices indicating the nonzero elements in Z. The i-th eigenvector is nonzero only in elements ISUPPZ( 2*i-1 ) through ISUPPZ( 2*i ). Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,26*N). For optimal efficiency, LWORK &gt;= (NB+6)*N, where NB is the max of the blocksize for DSYTRD and DORMTR returned by ILAENV.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. LIWORK &gt;= max(1,10*N).</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the IWORK array, returns this value as the first entry of the IWORK array, and no error message related to LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: Internal error</p>
<h1>Further Details</h1>
<p>Based on contributions by Inderjit Dhillon, IBM Almaden, USA Osni Marques, LBNL/NERSC, USA Ken Stanley, Computer Science Division, University of California at Berkeley, USA Jason Riedy, Computer Science Division, University of California at Berkeley, USA </p>
<hr/>
 <pre class="fragment">.. Parameters ..</pre> 
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a4621af093a70f5fb7b86c2a11012c721_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa2ac2a767e860128c10ac1e11a0ef6c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYEVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYEVX computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>RANGE (input) CHARACTER*1 = 'A': all eigenvalues will be found. = 'V': all eigenvalues in the half-open interval (VL,VU] will be found. = 'I': the IL-th through IU-th eigenvalues will be found.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, the lower triangle (if UPLO='L') or the upper triangle (if UPLO='U') of A, including the diagonal, is destroyed.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to </p>
<pre class="fragment">    ABSTOL + EPS *   max( |a|,|b| ) ,
</pre><p>where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.</p>
<p>Eigenvalues will be computed most accurately when ABSTOL is set to twice the underflow threshold 2*DLAMCH('S'), not zero. If this routine returns with INFO&gt;0, indicating that some eigenvectors did not converge, try setting ABSTOL to 2*DLAMCH('S').</p>
<p>See "Computing Small Singular Values of Bidiagonal Matrices
         with Guaranteed High Relative Accuracy," by Demmel and Kahan, LAPACK Working Note #3.</p>
<p>M (output) INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) On normal exit, the first M elements contain the selected eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M)) If JOBZ = 'V', then if INFO = 0, the first M columns of Z contain the orthonormal eigenvectors of the matrix A corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). If an eigenvector fails to converge, then that column of Z contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in IFAIL. If JOBZ = 'N', then Z is not referenced. Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = 'V', the exact value of M is not known in advance and an upper bound must be used.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The length of the array WORK. LWORK &gt;= 1, when N &lt;= 1; otherwise 8*N. For optimal efficiency, LWORK &gt;= (NB+3)*N, where NB is the max of the blocksize for DSYTRD and DORMTR returned by ILAENV.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace) INTEGER array, dimension (5*N)</p>
<p>IFAIL (output) INTEGER array, dimension (N) If JOBZ = 'V', then if INFO = 0, the first M elements of IFAIL are zero. If INFO &gt; 0, then IFAIL contains the indices of the eigenvectors that failed to converge. If JOBZ = 'N', then IFAIL is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, then i eigenvectors failed to converge. Their indices are stored in array IFAIL. </p>
<hr/>
 <pre class="fragment">.. Parameters ..</pre> 
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa2ac2a767e860128c10ac1e11a0ef6c9_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac9863ad1a7ebcd3b94c5bf287f70df75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYGST </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYGST reduces a real symmetric-definite generalized eigenproblem to standard form.</p>
<p>If ITYPE = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)</p>
<p>If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.</p>
<p>B must have been previously factorized as U**T*U or L*L**T by DPOTRF.</p>
<h1>Arguments</h1>
<p>ITYPE (input) INTEGER = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T); = 2 or 3: compute U*A*U**T or L**T*A*L.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored and B is factored as U**T*U; = 'L': Lower triangle of A is stored and B is factored as L*L**T.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced.</p>
<p>On exit, if INFO = 0, the transformed matrix, stored in the same format as A.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,N) The triangular factor from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization of B, as returned by DPOTRF.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ac9863ad1a7ebcd3b94c5bf287f70df75_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="af232942c441a9b4cfcba6b00bafbe718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYGV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYGV computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric and B is also positive definite.</p>
<h1>Arguments</h1>
<p>ITYPE (input) INTEGER Specifies the problem type to be solved: = 1: A*x = (lambda)*B*x = 2: A*B*x = (lambda)*x = 3: B*A*x = (lambda)*x</p>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangles of A and B are stored; = 'L': Lower triangles of A and B are stored.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A.</p>
<p>On exit, if JOBZ = 'V', then if INFO = 0, A contains the matrix Z of eigenvectors. The eigenvectors are normalized as follows: if ITYPE = 1 or 2, Z**T*B*Z = I; if ITYPE = 3, Z**T*inv(B)*Z = I. If JOBZ = 'N', then on exit the upper triangle (if UPLO='U') or the lower triangle (if UPLO='L') of A, including the diagonal, is destroyed.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB, N) On entry, the symmetric positive definite matrix B. If UPLO = 'U', the leading N-by-N upper triangular part of B contains the upper triangular part of the matrix B. If UPLO = 'L', the leading N-by-N lower triangular part of B contains the lower triangular part of the matrix B.</p>
<p>On exit, if INFO &lt;= N, the part of B containing the matrix is overwritten by the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization B = U**T*U or B = L*L**T.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The length of the array WORK. LWORK &gt;= max(1,3*N-1). For optimal efficiency, LWORK &gt;= (NB+2)*N, where NB is the blocksize for DSYTRD returned by ILAENV.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: DPOTRF or DSYEV returned an error code: &lt;= N: if INFO = i, DSYEV failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; &gt; N: if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading minor of order i of B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_af232942c441a9b4cfcba6b00bafbe718_icgraph.svg" width="328" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac469286f3ac08952591a8d29349f9d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYGVD </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYGVD computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric and B is also positive definite. If eigenvectors are desired, it uses a divide and conquer algorithm.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<h1>Arguments</h1>
<p>ITYPE (input) INTEGER Specifies the problem type to be solved: = 1: A*x = (lambda)*B*x = 2: A*B*x = (lambda)*x = 3: B*A*x = (lambda)*x</p>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangles of A and B are stored; = 'L': Lower triangles of A and B are stored.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A.</p>
<p>On exit, if JOBZ = 'V', then if INFO = 0, A contains the matrix Z of eigenvectors. The eigenvectors are normalized as follows: if ITYPE = 1 or 2, Z**T*B*Z = I; if ITYPE = 3, Z**T*inv(B)*Z = I. If JOBZ = 'N', then on exit the upper triangle (if UPLO='U') or the lower triangle (if UPLO='L') of A, including the diagonal, is destroyed.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB, N) On entry, the symmetric matrix B. If UPLO = 'U', the leading N-by-N upper triangular part of B contains the upper triangular part of the matrix B. If UPLO = 'L', the leading N-by-N lower triangular part of B contains the lower triangular part of the matrix B.</p>
<p>On exit, if INFO &lt;= N, the part of B containing the matrix is overwritten by the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization B = U**T*U or B = L*L**T.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If N &lt;= 1, LWORK &gt;= 1. If JOBZ = 'N' and N &gt; 1, LWORK &gt;= 2*N+1. If JOBZ = 'V' and N &gt; 1, LWORK &gt;= 1 + 6*N + 2*N**2.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. If N &lt;= 1, LIWORK &gt;= 1. If JOBZ = 'N' and N &gt; 1, LIWORK &gt;= 1. If JOBZ = 'V' and N &gt; 1, LIWORK &gt;= 3 + 5*N.</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK and IWORK arrays, returns these values as the first entries of the WORK and IWORK arrays, and no error message related to LWORK or LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: DPOTRF or DSYEVD returned an error code: &lt;= N: if INFO = i and JOBZ = 'N', then the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero; if INFO = i and JOBZ = 'V', then the algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1); &gt; N: if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading minor of order i of B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed.</p>
<h1>Further Details</h1>
<p>Based on contributions by Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA</p>
<p>Modified so that no backsubstitution is performed if DSYEVD fails to converge (NEIG in old code could be greater than N causing out of bounds reference to A - reported by Ralf Meyer). Also corrected the </p>
<h1>description of INFO and the test on ITYPE. Sven, 16 Feb 05.</h1>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ac469286f3ac08952591a8d29349f9d1b_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab4ea3c58ae33fe5b6813a080c5f52f7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYGVX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYGVX computes selected eigenvalues, and optionally, eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<h1>Arguments</h1>
<p>ITYPE (input) INTEGER Specifies the problem type to be solved: = 1: A*x = (lambda)*B*x = 2: A*B*x = (lambda)*x = 3: B*A*x = (lambda)*x</p>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>RANGE (input) CHARACTER*1 = 'A': all eigenvalues will be found. = 'V': all eigenvalues in the half-open interval (VL,VU] will be found. = 'I': the IL-th through IU-th eigenvalues will be found.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A and B are stored; = 'L': Lower triangle of A and B are stored.</p>
<p>N (input) INTEGER The order of the matrix pencil (A,B). N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A.</p>
<p>On exit, the lower triangle (if UPLO='L') or the upper triangle (if UPLO='U') of A, including the diagonal, is destroyed.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB, N) On entry, the symmetric matrix B. If UPLO = 'U', the leading N-by-N upper triangular part of B contains the upper triangular part of the matrix B. If UPLO = 'L', the leading N-by-N lower triangular part of B contains the lower triangular part of the matrix B.</p>
<p>On exit, if INFO &lt;= N, the part of B containing the matrix is overwritten by the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization B = U**T*U or B = L*L**T.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>VL (input) DOUBLE PRECISION VU (input) DOUBLE PRECISION If RANGE='V', the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = 'A' or 'I'.</p>
<p>IL (input) INTEGER IU (input) INTEGER If RANGE='I', the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = 'A' or 'V'.</p>
<p>ABSTOL (input) DOUBLE PRECISION The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to </p>
<pre class="fragment">    ABSTOL + EPS *   max( |a|,|b| ) ,
</pre><p>where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.</p>
<p>Eigenvalues will be computed most accurately when ABSTOL is set to twice the underflow threshold 2*DLAMCH('S'), not zero. If this routine returns with INFO&gt;0, indicating that some eigenvectors did not converge, try setting ABSTOL to 2*DLAMCH('S').</p>
<p>M (output) INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) On normal exit, the first M elements contain the selected eigenvalues in ascending order.</p>
<p>Z (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M)) If JOBZ = 'N', then Z is not referenced. If JOBZ = 'V', then if INFO = 0, the first M columns of Z contain the orthonormal eigenvectors of the matrix A corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). The eigenvectors are normalized as follows: if ITYPE = 1 or 2, Z**T*B*Z = I; if ITYPE = 3, Z**T*inv(B)*Z = I.</p>
<p>If an eigenvector fails to converge, then that column of Z contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in IFAIL. Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = 'V', the exact value of M is not known in advance and an upper bound must be used.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = 'V', LDZ &gt;= max(1,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The length of the array WORK. LWORK &gt;= max(1,8*N). For optimal efficiency, LWORK &gt;= (NB+3)*N, where NB is the blocksize for DSYTRD returned by ILAENV.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace) INTEGER array, dimension (5*N)</p>
<p>IFAIL (output) INTEGER array, dimension (N) If JOBZ = 'V', then if INFO = 0, the first M elements of IFAIL are zero. If INFO &gt; 0, then IFAIL contains the indices of the eigenvectors that failed to converge. If JOBZ = 'N', then IFAIL is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: DPOTRF or DSYEVX returned an error code: &lt;= N: if INFO = i, DSYEVX failed to converge; i eigenvectors failed to converge. Their indices are stored in array IFAIL. &gt; N: if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading minor of order i of B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed.</p>
<h1>Further Details</h1>
<p>Based on contributions by Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA </p>
<hr/>
 <pre class="fragment">.. Parameters ..</pre> 
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ab4ea3c58ae33fe5b6813a080c5f52f7b_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0e145bee7a002ac8c18e937785bd9458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSYMM </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYMM performs one of the matrix-matrix operations</p>
<p>C := alpha*A*B + beta*C,</p>
<p>or</p>
<p>C := alpha*B*A + beta*C,</p>
<p>where alpha and beta are scalars, A is a symmetric matrix and B and C are m by n matrices.</p>
<h1>Arguments</h1>
<p>SIDE - CHARACTER*1. On entry, SIDE specifies whether the symmetric matrix A appears on the left or right in the operation as follows:</p>
<p>SIDE = 'L' or 'l' C := alpha*A*B + beta*C,</p>
<p>SIDE = 'R' or 'r' C := alpha*B*A + beta*C,</p>
<p>Unchanged on exit.</p>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the upper or lower triangular part of the symmetric matrix A is to be referenced as follows:</p>
<p>UPLO = 'U' or 'u' Only the upper triangular part of the symmetric matrix is to be referenced.</p>
<p>UPLO = 'L' or 'l' Only the lower triangular part of the symmetric matrix is to be referenced.</p>
<p>Unchanged on exit.</p>
<p>M - INTEGER. On entry, M specifies the number of rows of the matrix C. M must be at least zero. Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the number of columns of the matrix C. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is m when SIDE = 'L' or 'l' and is n otherwise. Before entry with SIDE = 'L' or 'l', the m by m part of the array A must contain the symmetric matrix, such that when UPLO = 'U' or 'u', the leading m by m upper triangular part of the array A must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of A is not referenced, and when UPLO = 'L' or 'l', the leading m by m lower triangular part of the array A must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced. Before entry with SIDE = 'R' or 'r', the n by n part of the array A must contain the symmetric matrix, such that when UPLO = 'U' or 'u', the leading n by n upper triangular part of the array A must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of A is not referenced, and when UPLO = 'L' or 'l', the leading n by n lower triangular part of the array A must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. When SIDE = 'L' or 'l' then LDA must be at least max( 1, m ), otherwise LDA must be at least max( 1, n ). Unchanged on exit.</p>
<p>B - DOUBLE PRECISION array of DIMENSION ( LDB, n ). Before entry, the leading m by n part of the array B must contain the matrix B. Unchanged on exit.</p>
<p>LDB - INTEGER. On entry, LDB specifies the first dimension of B as declared in the calling (sub) program. LDB must be at least max( 1, m ). Unchanged on exit.</p>
<p>BETA - DOUBLE PRECISION. On entry, BETA specifies the scalar beta. When BETA is supplied as zero then C need not be set on input. Unchanged on exit.</p>
<p>C - DOUBLE PRECISION array of DIMENSION ( LDC, n ). Before entry, the leading m by n part of the array C must contain the matrix C, except when beta is zero, in which case C need not be set on entry. On exit, the array C is overwritten by the m by n updated matrix.</p>
<p>LDC - INTEGER. On entry, LDC specifies the first dimension of C as declared in the calling (sub) program. LDC must be at least max( 1, m ). Unchanged on exit.</p>
<p>Level 3 Blas routine.</p>
<p>&ndash; Written on 8-February-1989. Jack Dongarra, Argonne National Laboratory. Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical Algorithms Group Ltd.</p>
<p>.. External Functions .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a0e145bee7a002ac8c18e937785bd9458_icgraph.svg" width="323" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aacdb48b49b81618559003ca88bba0fd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSYMV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYMV performs the matrix-vector operation</p>
<p>y := alpha*A*x + beta*y,</p>
<p>where alpha and beta are scalars, x and y are n element vectors and A is an n by n symmetric matrix.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the upper or lower triangular part of the array A is to be referenced as follows:</p>
<p>UPLO = 'U' or 'u' Only the upper triangular part of A is to be referenced.</p>
<p>UPLO = 'L' or 'l' Only the lower triangular part of A is to be referenced.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry with UPLO = 'U' or 'u', the leading n by n upper triangular part of the array A must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of A is not referenced. Before entry with UPLO = 'L' or 'l', the leading n by n lower triangular part of the array A must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least max( 1, n ). Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element vector x. Unchanged on exit.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>BETA - DOUBLE PRECISION. On entry, BETA specifies the scalar beta. When BETA is supplied as zero then Y need not be set on input. Unchanged on exit.</p>
<p>Y - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCY ) ). Before entry, the incremented array Y must contain the n element vector y. On exit, Y is overwritten by the updated vector y.</p>
<p>INCY - INTEGER. On entry, INCY specifies the increment for the elements of Y. INCY must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aacdb48b49b81618559003ca88bba0fd7_icgraph.svg" width="296" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5d05ad2ab40ece27f2c94bec3657934a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSYR </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYR performs the symmetric rank 1 operation</p>
<p>A := alpha*x*x' + A,</p>
<p>where alpha is a real scalar, x is an n element vector and A is an n by n symmetric matrix.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the upper or lower triangular part of the array A is to be referenced as follows:</p>
<p>UPLO = 'U' or 'u' Only the upper triangular part of A is to be referenced.</p>
<p>UPLO = 'L' or 'l' Only the lower triangular part of A is to be referenced.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element vector x. Unchanged on exit.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry with UPLO = 'U' or 'u', the leading n by n upper triangular part of the array A must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of A is not referenced. On exit, the upper triangular part of the array A is overwritten by the upper triangular part of the updated matrix. Before entry with UPLO = 'L' or 'l', the leading n by n lower triangular part of the array A must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced. On exit, the lower triangular part of the array A is overwritten by the lower triangular part of the updated matrix.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least max( 1, n ). Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a5d05ad2ab40ece27f2c94bec3657934a_icgraph.svg" width="278" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8aedb5dd9fe6d44750869f3be82bc046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSYR2 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYR2 performs the symmetric rank 2 operation</p>
<p>A := alpha*x*y' + alpha*y*x' + A,</p>
<p>where alpha is a scalar, x and y are n element vectors and A is an n by n symmetric matrix.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the upper or lower triangular part of the array A is to be referenced as follows:</p>
<p>UPLO = 'U' or 'u' Only the upper triangular part of A is to be referenced.</p>
<p>UPLO = 'L' or 'l' Only the lower triangular part of A is to be referenced.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element vector x. Unchanged on exit.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>Y - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCY ) ). Before entry, the incremented array Y must contain the n element vector y. Unchanged on exit.</p>
<p>INCY - INTEGER. On entry, INCY specifies the increment for the elements of Y. INCY must not be zero. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry with UPLO = 'U' or 'u', the leading n by n upper triangular part of the array A must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of A is not referenced. On exit, the upper triangular part of the array A is overwritten by the upper triangular part of the updated matrix. Before entry with UPLO = 'L' or 'l', the leading n by n lower triangular part of the array A must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced. On exit, the lower triangular part of the array A is overwritten by the lower triangular part of the updated matrix.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least max( 1, n ). Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a8aedb5dd9fe6d44750869f3be82bc046_icgraph.svg" width="291" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a10b3243d6eabf332ee415467850ef4d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSYR2K </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYR2K performs one of the symmetric rank 2k operations</p>
<p>C := alpha*A*B' + alpha*B*A' + beta*C,</p>
<p>or</p>
<p>C := alpha*A'*B + alpha*B'*A + beta*C,</p>
<p>where alpha and beta are scalars, C is an n by n symmetric matrix and A and B are n by k matrices in the first case and k by n matrices in the second case.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the upper or lower triangular part of the array C is to be referenced as follows:</p>
<p>UPLO = 'U' or 'u' Only the upper triangular part of C is to be referenced.</p>
<p>UPLO = 'L' or 'l' Only the lower triangular part of C is to be referenced.</p>
<p>Unchanged on exit.</p>
<p>TRANS - CHARACTER*1. On entry, TRANS specifies the operation to be performed as follows:</p>
<p>TRANS = 'N' or 'n' C := alpha*A*B' + alpha*B*A' + beta*C.</p>
<p>TRANS = 'T' or 't' C := alpha*A'*B + alpha*B'*A + beta*C.</p>
<p>TRANS = 'C' or 'c' C := alpha*A'*B + alpha*B'*A + beta*C.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix C. N must be at least zero. Unchanged on exit.</p>
<p>K - INTEGER. On entry with TRANS = 'N' or 'n', K specifies the number of columns of the matrices A and B, and on entry with TRANS = 'T' or 't' or 'C' or 'c', K specifies the number of rows of the matrices A and B. K must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is k when TRANS = 'N' or 'n', and is n otherwise. Before entry with TRANS = 'N' or 'n', the leading n by k part of the array A must contain the matrix A, otherwise the leading k by n part of the array A must contain the matrix A. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. When TRANS = 'N' or 'n' then LDA must be at least max( 1, n ), otherwise LDA must be at least max( 1, k ). Unchanged on exit.</p>
<p>B - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is k when TRANS = 'N' or 'n', and is n otherwise. Before entry with TRANS = 'N' or 'n', the leading n by k part of the array B must contain the matrix B, otherwise the leading k by n part of the array B must contain the matrix B. Unchanged on exit.</p>
<p>LDB - INTEGER. On entry, LDB specifies the first dimension of B as declared in the calling (sub) program. When TRANS = 'N' or 'n' then LDB must be at least max( 1, n ), otherwise LDB must be at least max( 1, k ). Unchanged on exit.</p>
<p>BETA - DOUBLE PRECISION. On entry, BETA specifies the scalar beta. Unchanged on exit.</p>
<p>C - DOUBLE PRECISION array of DIMENSION ( LDC, n ). Before entry with UPLO = 'U' or 'u', the leading n by n upper triangular part of the array C must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of C is not referenced. On exit, the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix. Before entry with UPLO = 'L' or 'l', the leading n by n lower triangular part of the array C must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced. On exit, the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix.</p>
<p>LDC - INTEGER. On entry, LDC specifies the first dimension of C as declared in the calling (sub) program. LDC must be at least max( 1, n ). Unchanged on exit.</p>
<p>Level 3 Blas routine.</p>
<p>&ndash; Written on 8-February-1989. Jack Dongarra, Argonne National Laboratory. Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical Algorithms Group Ltd.</p>
<p>.. External Functions .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a10b3243d6eabf332ee415467850ef4d8_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a711b203e28514a83b002697670287db8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYRFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYRFS improves the computed solution to a system of linear equations when the coefficient matrix is symmetric indefinite, and provides error bounds and backward error estimates for the solution.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>AF (input) DOUBLE PRECISION array, dimension (LDAF,N) The factored form of the matrix A. AF contains the block diagonal matrix D and the multipliers used to obtain the factor U or L from the factorization A = U*D*U**T or A = L*D*L**T as computed by DSYTRF.</p>
<p>LDAF (input) INTEGER The leading dimension of the array AF. LDAF &gt;= max(1,N).</p>
<p>IPIV (input) INTEGER array, dimension (N) Details of the interchanges and the block structure of D as determined by DSYTRF.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS) On entry, the solution matrix X, as computed by DSYTRS. On exit, the improved solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Internal Parameters</h1>
<p>ITMAX is the maximum number of steps of iterative refinement. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a711b203e28514a83b002697670287db8_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="af0c68c2448c385f06cfa6c742ce07a73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSYRK </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYRK performs one of the symmetric rank k operations</p>
<p>C := alpha*A*A' + beta*C,</p>
<p>or</p>
<p>C := alpha*A'*A + beta*C,</p>
<p>where alpha and beta are scalars, C is an n by n symmetric matrix and A is an n by k matrix in the first case and a k by n matrix in the second case.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the upper or lower triangular part of the array C is to be referenced as follows:</p>
<p>UPLO = 'U' or 'u' Only the upper triangular part of C is to be referenced.</p>
<p>UPLO = 'L' or 'l' Only the lower triangular part of C is to be referenced.</p>
<p>Unchanged on exit.</p>
<p>TRANS - CHARACTER*1. On entry, TRANS specifies the operation to be performed as follows:</p>
<p>TRANS = 'N' or 'n' C := alpha*A*A' + beta*C.</p>
<p>TRANS = 'T' or 't' C := alpha*A'*A + beta*C.</p>
<p>TRANS = 'C' or 'c' C := alpha*A'*A + beta*C.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix C. N must be at least zero. Unchanged on exit.</p>
<p>K - INTEGER. On entry with TRANS = 'N' or 'n', K specifies the number of columns of the matrix A, and on entry with TRANS = 'T' or 't' or 'C' or 'c', K specifies the number of rows of the matrix A. K must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is k when TRANS = 'N' or 'n', and is n otherwise. Before entry with TRANS = 'N' or 'n', the leading n by k part of the array A must contain the matrix A, otherwise the leading k by n part of the array A must contain the matrix A. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. When TRANS = 'N' or 'n' then LDA must be at least max( 1, n ), otherwise LDA must be at least max( 1, k ). Unchanged on exit.</p>
<p>BETA - DOUBLE PRECISION. On entry, BETA specifies the scalar beta. Unchanged on exit.</p>
<p>C - DOUBLE PRECISION array of DIMENSION ( LDC, n ). Before entry with UPLO = 'U' or 'u', the leading n by n upper triangular part of the array C must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of C is not referenced. On exit, the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix. Before entry with UPLO = 'L' or 'l', the leading n by n lower triangular part of the array C must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced. On exit, the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix.</p>
<p>LDC - INTEGER. On entry, LDC specifies the first dimension of C as declared in the calling (sub) program. LDC must be at least max( 1, n ). Unchanged on exit.</p>
<p>Level 3 Blas routine.</p>
<p>&ndash; Written on 8-February-1989. Jack Dongarra, Argonne National Laboratory. Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical Algorithms Group Ltd.</p>
<p>.. External Functions .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_af0c68c2448c385f06cfa6c742ce07a73_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a251178e9ccd92bb186e845f7d0378a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYSV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYSV computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.</p>
<p>The diagonal pivoting method is used to factor A as A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then used to solve the system of equations A * X = B.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced.</p>
<p>On exit, if INFO = 0, the block diagonal matrix D and the multipliers used to obtain the factor U or L from the factorization A = U*D*U**T or A = L*D*L**T as computed by DSYTRF.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>IPIV (output) INTEGER array, dimension (N) Details of the interchanges and the block structure of D, as determined by DSYTRF. If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1 diagonal block. If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) = IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS right hand side matrix B. On exit, if INFO = 0, the N-by-NRHS solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The length of WORK. LWORK &gt;= 1, and for best performance LWORK &gt;= max(1,N*NB), where NB is the optimal blocksize for DSYTRF.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, D(i,i) is exactly zero. The factorization has been completed, but the block diagonal matrix D is exactly singular, so the solution could not be computed. </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a251178e9ccd92bb186e845f7d0378a14_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab27161d1f90c9fac873dbec55fbc3d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYSVX </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYSVX uses the diagonal pivoting factorization to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.</p>
<p>Error bounds on the solution and a condition estimate are also provided.</p>
<h1>Description</h1>
<p>The following steps are performed:</p>
<ol type="1">
<li>If FACT = 'N', the diagonal pivoting method is used to factor A. The form of the factorization is A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</li>
</ol>
<ol type="1">
<li>If some D(i,i)=0, so that D is exactly singular, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A. If the reciprocal of the condition number is less than machine precision, C++ Return value: INFO (output) INTEGER to solve for X and compute error bounds as described below.</li>
</ol>
<ol type="1">
<li>The system of equations is solved for X using the factored form of A.</li>
</ol>
<ol type="1">
<li>Iterative refinement is applied to improve the computed solution matrix and calculate error bounds and backward error estimates for it.</li>
</ol>
<h1>Arguments</h1>
<p>FACT (input) CHARACTER*1 Specifies whether or not the factored form of A has been supplied on entry. = 'F': On entry, AF and IPIV contain the factored form of A. AF and IPIV will not be modified. = 'N': The matrix A will be copied to AF and factored.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>AF (input or output) DOUBLE PRECISION array, dimension (LDAF,N) If FACT = 'F', then AF is an input argument and on entry contains the block diagonal matrix D and the multipliers used to obtain the factor U or L from the factorization A = U*D*U**T or A = L*D*L**T as computed by DSYTRF.</p>
<p>If FACT = 'N', then AF is an output argument and on exit returns the block diagonal matrix D and the multipliers used to obtain the factor U or L from the factorization A = U*D*U**T or A = L*D*L**T.</p>
<p>LDAF (input) INTEGER The leading dimension of the array AF. LDAF &gt;= max(1,N).</p>
<p>IPIV (input or output) INTEGER array, dimension (N) If FACT = 'F', then IPIV is an input argument and on entry contains details of the interchanges and the block structure of D, as determined by DSYTRF. If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were interchanged and D(k,k) is a 1-by-1 diagonal block. If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) = IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.</p>
<p>If FACT = 'N', then IPIV is an output argument and on exit contains details of the interchanges and the block structure of D, as determined by DSYTRF.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The N-by-NRHS right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (output) DOUBLE PRECISION array, dimension (LDX,NRHS) If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>RCOND (output) DOUBLE PRECISION The estimate of the reciprocal condition number of the matrix A. If RCOND is less than the machine precision (in particular, if RCOND = 0), the matrix is singular to working precision. This condition is indicated by a return code of C++ Return value: INFO (output) INTEGER</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The length of WORK. LWORK &gt;= max(1,3*N), and for best performance, when FACT = 'N', LWORK &gt;= max(1,3*N,N*NB), where NB is the optimal blocksize for DSYTRF.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, and i is &lt;= N: D(i,i) is exactly zero. The factorization has been completed but the factor D is exactly singular, so the solution and error bounds could not be computed. RCOND = 0 is returned. = N+1: D is nonsingular, but RCOND is less than machine precision, meaning that the matrix is singular to working precision. Nevertheless, the solution and error bounds are computed because there are a number of situations where the computed solution can be more accurate than the value of RCOND would suggest. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ab27161d1f90c9fac873dbec55fbc3d79_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a94ec09e6ab99d78995daf7d11e418b64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYTRD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYTRD reduces a real symmetric matrix A to real symmetric tridiagonal form T by an orthogonal similarity transformation: Q**T * A * Q = T.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if UPLO = 'U', the diagonal and first superdiagonal of A are overwritten by the corresponding elements of the tridiagonal matrix T, and the elements above the first superdiagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors; if UPLO = 'L', the diagonal and first subdiagonal of A are over- written by the corresponding elements of the tridiagonal matrix T, and the elements below the first subdiagonal, with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>D (output) DOUBLE PRECISION array, dimension (N) The diagonal elements of the tridiagonal matrix T: D(i) = A(i,i).</p>
<p>E (output) DOUBLE PRECISION array, dimension (N-1) The off-diagonal elements of the tridiagonal matrix T: E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (N-1) The scalar factors of the elementary reflectors (see Further Details).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= 1. For optimum performance LWORK &gt;= N*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>If UPLO = 'U', the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(n-1) . . . H(2) H(1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in A(1:i-1,i+1), and tau in TAU(i).</p>
<p>If UPLO = 'L', the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(n-1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i), and tau in TAU(i).</p>
<p>The contents of A on exit are illustrated by the following examples with n = 5:</p>
<p>if UPLO = 'U': if UPLO = 'L':</p>
<p>( d e v2 v3 v4 ) ( d ) ( d e v3 v4 ) ( e d ) ( d e v4 ) ( v1 e d ) ( d e ) ( v1 v2 e d ) ( d ) ( v1 v2 v3 e d )</p>
<p>where d and e denote diagonal and off-diagonal elements of T, and vi denotes an element of the vector defining H(i). </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a94ec09e6ab99d78995daf7d11e418b64_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae382cb8b4eab672cc21afc743c293e9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYTRF </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYTRF computes the factorization of a real symmetric matrix A using the Bunch-Kaufman diagonal pivoting method. The form of the factorization is</p>
<p>A = U*D*U**T or A = L*D*L**T</p>
<p>where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</p>
<p>This is the blocked version of the algorithm, calling Level 3 BLAS.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced.</p>
<p>On exit, the block diagonal matrix D and the multipliers used to obtain the factor U or L (see below for further details).</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>IPIV (output) INTEGER array, dimension (N) Details of the interchanges and the block structure of D. If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were interchanged and D(k,k) is a 1-by-1 diagonal block. If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) = IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The length of WORK. LWORK &gt;=1. For best performance LWORK &gt;= N*NB, where NB is the block size returned by ILAENV.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, D(i,i) is exactly zero. The factorization has been completed, but the block diagonal matrix D is exactly singular, and division by zero will occur if it is used to solve a system of equations.</p>
<h1>Further Details</h1>
<p>If UPLO = 'U', then A = U*D*U', where U = P(n)*U(n)* ... <em>P(k)U(k)</em> ..., i.e., U is a product of terms P(k)*U(k), where k decreases from n to 1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks D(k). P(k) is a permutation matrix as defined by IPIV(k), and U(k) is a unit upper triangular matrix, such that if the diagonal block D(k) is of order s (s = 1 or 2), then </p>
<pre class="fragment">       (   I    v    0   )   k-s
</pre><p> U(k) = ( 0 I 0 ) s ( 0 0 I ) n-k k-s s n-k</p>
<p>If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k). If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k), and A(k,k), and v overwrites A(1:k-2,k-1:k).</p>
<p>If UPLO = 'L', then A = L*D*L', where L = P(1)*L(1)* ... <em>P(k)*L(k)</em> ..., i.e., L is a product of terms P(k)*L(k), where k increases from 1 to n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks D(k). P(k) is a permutation matrix as defined by IPIV(k), and L(k) is a unit lower triangular matrix, such that if the diagonal block D(k) is of order s (s = 1 or 2), then </p>
<pre class="fragment">       (   I    0     0   )  k-1
</pre><p> L(k) = ( 0 I 0 ) s ( 0 v I ) n-k-s+1 k-1 s n-k-s+1</p>
<p>If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k). If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k), and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1). </p>
<hr/>
<p>.. Local Scalars .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ae382cb8b4eab672cc21afc743c293e9c_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a686c5afc306530113b3e5108f198bce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYTRI </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYTRI computes the inverse of a real symmetric indefinite matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by DSYTRF.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 Specifies whether the details of the factorization are stored as an upper or lower triangular matrix. = 'U': Upper triangular, form is A = U*D*U**T; = 'L': Lower triangular, form is A = L*D*L**T.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the block diagonal matrix D and the multipliers used to obtain the factor U or L as computed by DSYTRF.</p>
<p>On exit, if INFO = 0, the (symmetric) inverse of the original matrix. If UPLO = 'U', the upper triangular part of the inverse is formed and the part of A below the diagonal is not referenced; if UPLO = 'L' the lower triangular part of the inverse is formed and the part of A above the diagonal is not referenced.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>IPIV (input) INTEGER array, dimension (N) Details of the interchanges and the block structure of D as determined by DSYTRF.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, D(i,i) = 0; the matrix is singular and its inverse could not be computed. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a686c5afc306530113b3e5108f198bce9_icgraph.svg" width="302" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa9ecdaf384b08b4da7a46e175ec2c051"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYTRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYTRS solves a system of linear equations A*X = B with a real symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by DSYTRF.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 Specifies whether the details of the factorization are stored as an upper or lower triangular matrix. = 'U': Upper triangular, form is A = U*D*U**T; = 'L': Lower triangular, form is A = L*D*L**T.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The block diagonal matrix D and the multipliers used to obtain the factor U or L as computed by DSYTRF.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>IPIV (input) INTEGER array, dimension (N) Details of the interchanges and the block structure of D as determined by DSYTRF.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa9ecdaf384b08b4da7a46e175ec2c051_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a84fcb194ae0e30df62cbd1d6ea8dc2f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTBCON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTBCON estimates the reciprocal of the condition number of a triangular band matrix A, in either the 1-norm or the infinity-norm.</p>
<p>The norm of A is computed and an estimate is obtained for norm(inv(A)), then the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).</p>
<h1>Arguments</h1>
<p>NORM (input) CHARACTER*1 Specifies whether the 1-norm condition number or the infinity-norm condition number is required: = '1' or 'O': 1-norm; = 'I': Infinity-norm.</p>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals or subdiagonals of the triangular band matrix A. KD &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) The upper or lower triangular band matrix A, stored in the first kd+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd). If DIAG = 'U', the diagonal elements of A are not referenced and are assumed to be 1.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD+1.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(norm(A) * norm(inv(A))).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a84fcb194ae0e30df62cbd1d6ea8dc2f4_icgraph.svg" width="315" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0f17a8c5a84c684b22abf73bb511201d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DTBMV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTBMV performs one of the matrix-vector operations</p>
<p>x := A*x, or x := A'*x,</p>
<p>where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular band matrix, with ( k + 1 ) diagonals.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the matrix is an upper or lower triangular matrix as follows:</p>
<p>UPLO = 'U' or 'u' A is an upper triangular matrix.</p>
<p>UPLO = 'L' or 'l' A is a lower triangular matrix.</p>
<p>Unchanged on exit.</p>
<p>TRANS - CHARACTER*1. On entry, TRANS specifies the operation to be performed as follows:</p>
<p>TRANS = 'N' or 'n' x := A*x.</p>
<p>TRANS = 'T' or 't' x := A'*x.</p>
<p>TRANS = 'C' or 'c' x := A'*x.</p>
<p>Unchanged on exit.</p>
<p>DIAG - CHARACTER*1. On entry, DIAG specifies whether or not A is unit triangular as follows:</p>
<p>DIAG = 'U' or 'u' A is assumed to be unit triangular.</p>
<p>DIAG = 'N' or 'n' A is not assumed to be unit triangular.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>K - INTEGER. On entry with UPLO = 'U' or 'u', K specifies the number of super-diagonals of the matrix A. On entry with UPLO = 'L' or 'l', K specifies the number of sub-diagonals of the matrix A. K must satisfy 0 .le. K. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the matrix of coefficients, supplied column by column, with the leading diagonal of the matrix in row ( k + 1 ) of the array, the first super-diagonal starting at position 2 in row k, and so on. The top left k by k triangle of the array A is not referenced. The following program segment will transfer an upper triangular band matrix from conventional full matrix storage to band storage: </p>
<pre class="fragment">  DO 20, J = 1, N
     M = K + 1 - J
     DO 10, I = MAX( 1, J - K ), J
        A( M + I, J ) = matrix( I, J )
</pre><p> 10 CONTINUE 20 CONTINUE</p>
<p>Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients, supplied column by column, with the leading diagonal of the matrix in row 1 of the array, the first sub-diagonal starting at position 1 in row 2, and so on. The bottom right k by k triangle of the array A is not referenced. The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage: </p>
<pre class="fragment">  DO 20, J = 1, N
     M = 1 - J
     DO 10, I = J, MIN( N, J + K )
        A( M + I, J ) = matrix( I, J )
</pre><p> 10 CONTINUE 20 CONTINUE</p>
<p>Note that when DIAG = 'U' or 'u' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced, but are assumed to be unity. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least ( k + 1 ). Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element vector x. On exit, X is overwritten with the tranformed vector x.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a0f17a8c5a84c684b22abf73bb511201d_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac8934b7e2d896e58abea1467c70ddacb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTBRFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTBRFS provides error bounds and backward error estimates for the solution to a system of linear equations with a triangular band coefficient matrix.</p>
<p>The solution matrix X must be computed by DTBTRS or some other means before entering this routine. DTBRFS does not do iterative refinement because doing so cannot improve the backward error.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Conjugate transpose = Transpose)</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals or subdiagonals of the triangular band matrix A. KD &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) The upper or lower triangular band matrix A, stored in the first kd+1 rows of the array. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd). If DIAG = 'U', the diagonal elements of A are not referenced and are assumed to be 1.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD+1.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input) DOUBLE PRECISION array, dimension (LDX,NRHS) The solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ac8934b7e2d896e58abea1467c70ddacb_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2f17f7a08338252e157868c4d66d7db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DTBSV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTBSV solves one of the systems of equations</p>
<p>A*x = b, or A'*x = b,</p>
<p>where b and x are n element vectors and A is an n by n unit, or non-unit, upper or lower triangular band matrix, with ( k + 1 ) diagonals.</p>
<p>No test for singularity or near-singularity is included in this routine. Such tests must be performed before calling this routine.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the matrix is an upper or lower triangular matrix as follows:</p>
<p>UPLO = 'U' or 'u' A is an upper triangular matrix.</p>
<p>UPLO = 'L' or 'l' A is a lower triangular matrix.</p>
<p>Unchanged on exit.</p>
<p>TRANS - CHARACTER*1. On entry, TRANS specifies the equations to be solved as follows:</p>
<p>TRANS = 'N' or 'n' A*x = b.</p>
<p>TRANS = 'T' or 't' A'*x = b.</p>
<p>TRANS = 'C' or 'c' A'*x = b.</p>
<p>Unchanged on exit.</p>
<p>DIAG - CHARACTER*1. On entry, DIAG specifies whether or not A is unit triangular as follows:</p>
<p>DIAG = 'U' or 'u' A is assumed to be unit triangular.</p>
<p>DIAG = 'N' or 'n' A is not assumed to be unit triangular.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>K - INTEGER. On entry with UPLO = 'U' or 'u', K specifies the number of super-diagonals of the matrix A. On entry with UPLO = 'L' or 'l', K specifies the number of sub-diagonals of the matrix A. K must satisfy 0 .le. K. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the matrix of coefficients, supplied column by column, with the leading diagonal of the matrix in row ( k + 1 ) of the array, the first super-diagonal starting at position 2 in row k, and so on. The top left k by k triangle of the array A is not referenced. The following program segment will transfer an upper triangular band matrix from conventional full matrix storage to band storage: </p>
<pre class="fragment">  DO 20, J = 1, N
     M = K + 1 - J
     DO 10, I = MAX( 1, J - K ), J
        A( M + I, J ) = matrix( I, J )
</pre><p> 10 CONTINUE 20 CONTINUE</p>
<p>Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients, supplied column by column, with the leading diagonal of the matrix in row 1 of the array, the first sub-diagonal starting at position 1 in row 2, and so on. The bottom right k by k triangle of the array A is not referenced. The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage: </p>
<pre class="fragment">  DO 20, J = 1, N
     M = 1 - J
     DO 10, I = J, MIN( N, J + K )
        A( M + I, J ) = matrix( I, J )
</pre><p> 10 CONTINUE 20 CONTINUE</p>
<p>Note that when DIAG = 'U' or 'u' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced, but are assumed to be unity. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least ( k + 1 ). Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element right-hand side vector b. On exit, X is overwritten with the solution vector x.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a2f17f7a08338252e157868c4d66d7db0_icgraph.svg" width="291" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab04d529bdd5bec94ea3b217ce8d74377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTBTRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTBTRS solves a triangular system of the form</p>
<p>A * X = B or A**T * X = B,</p>
<p>where A is a triangular band matrix of order N, and B is an N-by NRHS matrix. A check is made to verify that A is nonsingular.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>TRANS (input) CHARACTER*1 Specifies the form the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Conjugate transpose = Transpose)</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>KD (input) INTEGER The number of superdiagonals or subdiagonals of the triangular band matrix A. KD &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>AB (input) DOUBLE PRECISION array, dimension (LDAB,N) The upper or lower triangular band matrix A, stored in the first kd+1 rows of AB. The j-th column of A is stored in the j-th column of the array AB as follows: if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j; if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j&lt;=i&lt;=min(n,j+kd). If DIAG = 'U', the diagonal elements of A are not referenced and are assumed to be 1.</p>
<p>LDAB (input) INTEGER The leading dimension of the array AB. LDAB &gt;= KD+1.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, if INFO = 0, the solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the i-th diagonal element of A is zero, indicating that the matrix is singular and the solutions X have not been computed. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ab04d529bdd5bec94ea3b217ce8d74377_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2e968e64f80edc37c74ec9bd5e83dbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTGEVC </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>howmny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTGEVC computes some or all of the right and/or left eigenvectors of a pair of real matrices (S,P), where S is a quasi-triangular matrix and P is upper triangular. <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> pairs of this type are produced by the generalized Schur factorization of a matrix pair (A,B):</p>
<p>A = Q*S*Z**T, B = Q*P*Z**T</p>
<p>as computed by DGGHRD + DHGEQZ.</p>
<p>The right eigenvector x and the left eigenvector y of (S,P) corresponding to an eigenvalue w are defined by:</p>
<p>S*x = w*P*x, (y**H)*S = w*(y**H)*P,</p>
<p>where y**H denotes the conjugate tranpose of y. The eigenvalues are not input to this routine, but are computed directly from the diagonal blocks of S and P.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of (S,P), or the products Z*X and/or Q*Y, where Z and Q are input matrices. If Q and Z are the orthogonal factors from the generalized Schur factorization of a matrix pair (A,B), then Z*X and Q*Y are the matrices of right and left eigenvectors of (A,B).</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'R': compute right eigenvectors only; = 'L': compute left eigenvectors only; = 'B': compute both right and left eigenvectors.</p>
<p>HOWMNY (input) CHARACTER*1 = 'A': compute all right and/or left eigenvectors; = 'B': compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL; = 'S': compute selected right and/or left eigenvectors, specified by the logical array SELECT.</p>
<p>SELECT (input) LOGICAL array, dimension (N) If HOWMNY='S', SELECT specifies the eigenvectors to be computed. If w(j) is a real eigenvalue, the corresponding real eigenvector is computed if SELECT(j) is .TRUE.. If w(j) and w(j+1) are the real and imaginary parts of a complex eigenvalue, the corresponding complex eigenvector is computed if either SELECT(j) or SELECT(j+1) is .TRUE., and on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to .FALSE.. Not referenced if HOWMNY = 'A' or 'B'.</p>
<p>N (input) INTEGER The order of the matrices S and P. N &gt;= 0.</p>
<p>S (input) DOUBLE PRECISION array, dimension (LDS,N) The upper quasi-triangular matrix S from a generalized Schur factorization, as computed by DHGEQZ.</p>
<p>LDS (input) INTEGER The leading dimension of array S. LDS &gt;= max(1,N).</p>
<p>P (input) DOUBLE PRECISION array, dimension (LDP,N) The upper triangular matrix P from a generalized Schur factorization, as computed by DHGEQZ. 2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S must be in positive diagonal form.</p>
<p>LDP (input) INTEGER The leading dimension of array P. LDP &gt;= max(1,N).</p>
<p>VL (input/output) DOUBLE PRECISION array, dimension (LDVL,MM) On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must contain an N-by-N matrix Q (usually the orthogonal matrix Q of left Schur vectors returned by DHGEQZ). On exit, if SIDE = 'L' or 'B', VL contains: if HOWMNY = 'A', the matrix Y of left eigenvectors of (S,P); if HOWMNY = 'B', the matrix Q*Y; if HOWMNY = 'S', the left eigenvectors of (S,P) specified by SELECT, stored consecutively in the columns of VL, in the same order as their eigenvalues.</p>
<p>A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part, and the second the imaginary part.</p>
<p>Not referenced if SIDE = 'R'.</p>
<p>LDVL (input) INTEGER The leading dimension of array VL. LDVL &gt;= 1, and if SIDE = 'L' or 'B', LDVL &gt;= N.</p>
<p>VR (input/output) DOUBLE PRECISION array, dimension (LDVR,MM) On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must contain an N-by-N matrix Z (usually the orthogonal matrix Z of right Schur vectors returned by DHGEQZ).</p>
<p>On exit, if SIDE = 'R' or 'B', VR contains: if HOWMNY = 'A', the matrix X of right eigenvectors of (S,P); if HOWMNY = 'B' or 'b', the matrix Z*X; if HOWMNY = 'S' or 's', the right eigenvectors of (S,P) specified by SELECT, stored consecutively in the columns of VR, in the same order as their eigenvalues.</p>
<p>A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part and the second the imaginary part.</p>
<p>Not referenced if SIDE = 'L'.</p>
<p>LDVR (input) INTEGER The leading dimension of the array VR. LDVR &gt;= 1, and if SIDE = 'R' or 'B', LDVR &gt;= N.</p>
<p>MM (input) INTEGER The number of columns in the arrays VL and/or VR. MM &gt;= M.</p>
<p>M (output) INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If HOWMNY = 'A' or 'B', M is set to N. Each selected real eigenvector occupies one column and each selected complex eigenvector occupies two columns.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (6*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: the 2-by-2 block (INFO:INFO+1) does not have a complex eigenvalue.</p>
<h1>Further Details</h1>
<p>Allocation of workspace: </p>
<hr/>
<p>WORK( j ) = 1-norm of j-th column of A, above the diagonal WORK( N+j ) = 1-norm of j-th column of B, above the diagonal WORK( 2*N+1:3*N ) = real part of eigenvector WORK( 3*N+1:4*N ) = imaginary part of eigenvector WORK( 4*N+1:5*N ) = real part of back-transformed eigenvector WORK( 5*N+1:6*N ) = imaginary part of back-transformed eigenvector</p>
<p>Rowwise vs. columnwise solution methods: </p>
<hr/>
<p>Finding a generalized eigenvector consists basically of solving the singular triangular system</p>
<p>(A - w B) x = 0 (for right) or: (A - w B)**H y = 0 (for left)</p>
<p>Consider finding the i-th right eigenvector (assume all eigenvalues are real). The equation to be solved is: n i 0 = sum C(j,k) v(k) = sum C(j,k) v(k) for j = i,. . .,1 k=j k=j</p>
<p>where C = (A - w B) (The components v(i+1:n) are 0.)</p>
<p>The "rowwise" method is:</p>
<p>(1) v(i) := 1 for j = i-1,. . .,1: i (2) compute s = - sum C(j,k) v(k) and k=j+1</p>
<p>(3) v(j) := s / C(j,j)</p>
<p>Step 2 is sometimes called the "dot product" step, since it is an inner product between the j-th row and the portion of the eigenvector that has been computed so far.</p>
<p>The "columnwise" method consists basically in doing the sums for all the rows in parallel. As each v(j) is computed, the contribution of v(j) times the j-th column of C is added to the partial sums. Since FORTRAN arrays are stored columnwise, this has the advantage that at each step, the elements of C that are accessed are adjacent to one another, whereas with the rowwise method, the elements accessed at a step are spaced LDS (and LDP) words apart.</p>
<p>When finding left eigenvectors, the matrix in question is the transpose of the one in storage, so the rowwise method then actually accesses columns of A and B at each step, and so is the preferred method. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a2e968e64f80edc37c74ec9bd5e83dbfa_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a78ea0cd9464014247bbdfd4eab7361a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTGEXC </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ilst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTGEXC reorders the generalized real Schur decomposition of a real matrix pair (A,B) using an orthogonal equivalence transformation </p>
<pre class="fragment">           (A, B) = Q * (A, B) * Z',
</pre><p>so that the diagonal block of (A, B) with row index IFST is moved to row ILST.</p>
<p>(A, B) must be in generalized real Schur canonical form (as returned by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper triangular.</p>
<p>Optionally, the matrices Q and Z of generalized Schur vectors are updated. </p>
<pre class="fragment">   Q(in) * A(in) * Z(in)' = Q(out) * A(out) * Z(out)'
   Q(in) * B(in) * Z(in)' = Q(out) * B(out) * Z(out)'
</pre><h1>Arguments</h1>
<p>WANTQ (input) LOGICAL .TRUE. : update the left transformation matrix Q; .FALSE.: do not update Q.</p>
<p>WANTZ (input) LOGICAL .TRUE. : update the right transformation matrix Z; .FALSE.: do not update Z.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the matrix A in generalized real Schur canonical form. On exit, the updated matrix A, again in generalized real Schur canonical form.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,N) On entry, the matrix B in generalized real Schur canonical form (A,B). On exit, the updated matrix B, again in generalized real Schur canonical form (A,B).</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>Q (input/output) DOUBLE PRECISION array, dimension (LDQ,N) On entry, if WANTQ = .TRUE., the orthogonal matrix Q. On exit, the updated matrix Q. If WANTQ = .FALSE., Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= 1. If WANTQ = .TRUE., LDQ &gt;= N.</p>
<p>Z (input/output) DOUBLE PRECISION array, dimension (LDZ,N) On entry, if WANTZ = .TRUE., the orthogonal matrix Z. On exit, the updated matrix Z. If WANTZ = .FALSE., Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1. If WANTZ = .TRUE., LDZ &gt;= N.</p>
<p>IFST (input/output) INTEGER ILST (input/output) INTEGER Specify the reordering of the diagonal blocks of (A, B). The block with row index IFST is moved to row ILST, by a sequence of swapping between adjacent blocks. On exit, if IFST pointed on entry to the second row of a 2-by-2 block, it is changed to point to the first row; ILST always points to the first row of the block in its final position (which may differ from its input value by +1 or -1). 1 &lt;= IFST, ILST &lt;= N.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= 1 when N &lt;= 1, otherwise LWORK &gt;= 4*N + 16.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER =0: successful exit. &lt;0: if INFO = -i, the i-th argument had an illegal value. =1: The transformed matrix pair (A, B) would be too far from generalized Schur form; the problem is ill- conditioned. (A, B) may have been partially reordered, and ILST points to the first row of the current position of the block being moved.</p>
<h1>Further Details</h1>
<p>Based on contributions by Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea, Sweden.</p>
<p>[1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the Generalized Real Schur Form of a Regular <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Pair (A, B), in M.S. Moonen et al (eds), Linear Algebra for Large Scale and Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a78ea0cd9464014247bbdfd4eab7361a5_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a547b8b07e9484fd80a073cdf0e5eb4b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTGSEN </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ijob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alphai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTGSEN reorders the generalized real Schur decomposition of a real matrix pair (A, B) (in terms of an orthonormal equivalence trans- formation Q' * (A, B) * Z), so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper quasi-triangular matrix A and the upper triangular B. The leading columns of Q and Z form orthonormal bases of the corresponding left and right eigen- spaces (deflating subspaces). (A, B) must be in generalized real Schur canonical form (as returned by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper triangular.</p>
<p>DTGSEN also computes the generalized eigenvalues </p>
<pre class="fragment">        w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
</pre><p>of the reordered matrix pair (A, B).</p>
<p>Optionally, DTGSEN computes the estimates of reciprocal condition numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11), (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s) between the matrix pairs (A11, B11) and (A22,B22) that correspond to the selected cluster and the eigenvalues outside the cluster, resp., and norms of "projections" onto left and right eigenspaces w.r.t. the selected cluster in the (1,1)-block.</p>
<h1>Arguments</h1>
<p>IJOB (input) INTEGER Specifies whether condition numbers are required for the cluster of eigenvalues (PL and PR) or the deflating subspaces (Difu and Difl): =0: Only reorder w.r.t. SELECT. No extras. =1: Reciprocal of norms of "projections" onto left and right eigenspaces w.r.t. the selected cluster (PL and PR). =2: Upper bounds on Difu and Difl. F-norm-based estimate (DIF(1:2)). =3: Estimate of Difu and Difl. 1-norm-based estimate (DIF(1:2)). About 5 times as expensive as IJOB = 2. =4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic version to get it all. =5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above)</p>
<p>WANTQ (input) LOGICAL .TRUE. : update the left transformation matrix Q; .FALSE.: do not update Q.</p>
<p>WANTZ (input) LOGICAL .TRUE. : update the right transformation matrix Z; .FALSE.: do not update Z.</p>
<p>SELECT (input) LOGICAL array, dimension (N) SELECT specifies the eigenvalues in the selected cluster. To select a real eigenvalue w(j), SELECT(j) must be set to .TRUE.. To select a complex conjugate pair of eigenvalues w(j) and w(j+1), corresponding to a 2-by-2 diagonal block, either SELECT(j) or SELECT(j+1) or both must be set to .TRUE.; a complex conjugate pair of eigenvalues must be either both included in the cluster or both excluded.</p>
<p>N (input) INTEGER The order of the matrices A and B. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension(LDA,N) On entry, the upper quasi-triangular matrix A, with (A, B) in generalized real Schur canonical form. On exit, A is overwritten by the reordered matrix A.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension(LDB,N) On entry, the upper triangular matrix B, with (A, B) in generalized real Schur canonical form. On exit, B is overwritten by the reordered matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>ALPHAR (output) DOUBLE PRECISION array, dimension (N) ALPHAI (output) DOUBLE PRECISION array, dimension (N) BETA (output) DOUBLE PRECISION array, dimension (N) On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will be the generalized eigenvalues. ALPHAR(j) + ALPHAI(j)*i and BETA(j),j=1,...,N are the diagonals of the complex Schur form (S,T) that would result if the 2-by-2 diagonal blocks of the real generalized Schur form of (A,B) were further reduced to triangular form using complex unitary transformations. If ALPHAI(j) is zero, then the j-th eigenvalue is real; if positive, then the j-th and (j+1)-st eigenvalues are a complex conjugate pair, with ALPHAI(j+1) negative.</p>
<p>Q (input/output) DOUBLE PRECISION array, dimension (LDQ,N) On entry, if WANTQ = .TRUE., Q is an N-by-N matrix. On exit, Q has been postmultiplied by the left orthogonal transformation matrix which reorder (A, B); The leading M columns of Q form orthonormal bases for the specified pair of left eigenspaces (deflating subspaces). If WANTQ = .FALSE., Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= 1; and if WANTQ = .TRUE., LDQ &gt;= N.</p>
<p>Z (input/output) DOUBLE PRECISION array, dimension (LDZ,N) On entry, if WANTZ = .TRUE., Z is an N-by-N matrix. On exit, Z has been postmultiplied by the left orthogonal transformation matrix which reorder (A, B); The leading M columns of Z form orthonormal bases for the specified pair of left eigenspaces (deflating subspaces). If WANTZ = .FALSE., Z is not referenced.</p>
<p>LDZ (input) INTEGER The leading dimension of the array Z. LDZ &gt;= 1; If WANTZ = .TRUE., LDZ &gt;= N.</p>
<p>M (output) INTEGER The dimension of the specified pair of left and right eigen- spaces (deflating subspaces). 0 &lt;= M &lt;= N.</p>
<p>PL (output) DOUBLE PRECISION PR (output) DOUBLE PRECISION If IJOB = 1, 4 or 5, PL, PR are lower bounds on the reciprocal of the norm of "projections" onto left and right eigenspaces with respect to the selected cluster. 0 &lt; PL, PR &lt;= 1. If M = 0 or M = N, PL = PR = 1. If IJOB = 0, 2 or 3, PL and PR are not referenced.</p>
<p>DIF (output) DOUBLE PRECISION array, dimension (2). If IJOB &gt;= 2, DIF(1:2) store the estimates of Difu and Difl. If IJOB = 2 or 4, DIF(1:2) are F-norm-based upper bounds on Difu and Difl. If IJOB = 3 or 5, DIF(1:2) are 1-norm-based estimates of Difu and Difl. If M = 0 or N, DIF(1:2) = F-norm([A, B]). If IJOB = 0 or 1, DIF is not referenced.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= 4*N+16. If IJOB = 1, 2 or 4, LWORK &gt;= MAX(4*N+16, 2*M*(N-M)). If IJOB = 3 or 5, LWORK &gt;= MAX(4*N+16, 4*M*(N-M)).</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace/output) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. LIWORK &gt;= 1. If IJOB = 1, 2 or 4, LIWORK &gt;= N+6. If IJOB = 3 or 5, LIWORK &gt;= MAX(2*M*(N-M), N+6).</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the IWORK array, returns this value as the first entry of the IWORK array, and no error message related to LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER =0: Successful exit. &lt;0: If INFO = -i, the i-th argument had an illegal value. =1: Reordering of (A, B) failed because the transformed matrix pair (A, B) would be too far from generalized Schur form; the problem is very ill-conditioned. (A, B) may have been partially reordered. If requested, 0 is returned in DIF(*), PL and PR.</p>
<h1>Further Details</h1>
<p>DTGSEN first collects the selected eigenvalues by computing orthogonal U and W that move them to the top left corner of (A, B). In other words, the selected eigenvalues are the eigenvalues of (A11, B11) in: </p>
<pre class="fragment">          U'*(A, B)*W = (A11 A12) (B11 B12) n1
                        ( 0  A22),( 0  B22) n2
                          n1  n2    n1  n2
</pre><p>where N = n1+n2 and U' means the transpose of U. The first n1 columns of U and W span the specified pair of left and right eigenspaces (deflating subspaces) of (A, B).</p>
<p>If (A, B) has been obtained from the generalized real Schur decomposition of a matrix pair (C, D) = Q*(A, B)*Z', then the reordered generalized real Schur form of (C, D) is given by </p>
<pre class="fragment">     (C, D) = (Q*U)*(U'*(A, B)*W)*(Z*W)',
</pre><p>and the first n1 columns of Q*U and Z*W span the corresponding deflating subspaces of (C, D) (Q and Z store Q*U and Z*W, resp.).</p>
<p>Note that if the selected eigenvalue is sufficiently ill-conditioned, then its value may differ significantly from its value before reordering.</p>
<p>The reciprocal condition numbers of the left and right eigenspaces spanned by the first n1 columns of U and W (or Q*U and Z*W) may be returned in DIF(1:2), corresponding to Difu and Difl, resp.</p>
<p>The Difu and Difl are defined as: </p>
<pre class="fragment"> Difu[(A11, B11), (A22, B22)] = sigma-min( Zu )
</pre><p> and Difl[(A11, B11), (A22, B22)] = Difu[(A22, B22), (A11, B11)],</p>
<p>where sigma-min(Zu) is the smallest singular value of the (2*n1*n2)-by-(2*n1*n2) matrix </p>
<pre class="fragment"> Zu = [ kron(In2, A11)  -kron(A22', In1) ]
      [ kron(In2, B11)  -kron(B22', In1) ].
</pre><p>Here, Inx is the identity matrix of size nx and A22' is the transpose of A22. kron(X, Y) is the Kronecker product between the matrices X and Y.</p>
<p>When DIF(2) is small, small changes in (A, B) can cause large changes in the deflating subspace. An approximate (asymptotic) bound on the maximum angular error in the computed deflating subspaces is </p>
<pre class="fragment"> EPS * norm((A, B)) / DIF(2),
</pre><p>where EPS is the machine precision.</p>
<p>The reciprocal norm of the projectors on the left and right eigenspaces associated with (A11, B11) may be returned in PL and PR. They are computed as follows. First we compute L and R so that P*(A, B)*Q is block diagonal, where </p>
<pre class="fragment"> P = ( I -L ) n1           Q = ( I R ) n1
     ( 0  I ) n2    and        ( 0 I ) n2
       n1 n2                    n1 n2
</pre><p>and (L, R) is the solution to the generalized Sylvester equation </p>
<pre class="fragment"> A11*R - L*A22 = -A12
 B11*R - L*B22 = -B12
</pre><p>Then PL = (F-norm(L)**2+1)**(-1/2) and PR = (F-norm(R)**2+1)**(-1/2). An approximate (asymptotic) bound on the average absolute error of the selected eigenvalues is </p>
<pre class="fragment"> EPS * norm((A, B)) / PL.
</pre><p>There are also global error bounds which valid for perturbations up to a certain restriction: A lower bound (x) on the smallest F-norm(E,F) for which an eigenvalue of (A11, B11) may move and coalesce with an eigenvalue of (A22, B22) under perturbation (E,F), (i.e. (A + E, B + F), is</p>
<p>x = min(Difu,Difl)/((1/(PL*PL)+1/(PR*PR))**(1/2)+2*max(1/PL,1/PR)).</p>
<p>An approximate bound on x can be computed from DIF(1:2), PL and PR.</p>
<p>If y = ( F-norm(E,F) / x) &lt;= 1, the angles between the perturbed (L', R') and unperturbed (L, R) left and right deflating subspaces associated with the selected cluster in the (1,1)-blocks can be bounded as</p>
<p>max-angle(L, L') &lt;= arctan( y * PL / (1 - y * (1 - PL * PL)**(1/2)) max-angle(R, R') &lt;= arctan( y * PR / (1 - y * (1 - PR * PR)**(1/2))</p>
<p>See LAPACK User's Guide section 4.11 or the following references for more information.</p>
<p>Note that if the default method for computing the Frobenius-norm- based estimate DIF is not wanted (see DLATDF), then the parameter IDIFJB (see below) should be changed from 3 to 4 (routine DLATDF (IJOB = 2 will be used)). See DTGSYL for more details.</p>
<p>Based on contributions by Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea, Sweden.</p>
<h1>References</h1>
<p>[1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the Generalized Real Schur Form of a Regular <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Pair (A, B), in M.S. Moonen et al (eds), Linear Algebra for Large Scale and Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.</p>
<p>[2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified Eigenvalues of a Regular <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Pair (A, B) and Condition Estimation: Theory, Algorithms and Software, Report UMINF - 94.04, Department of Computing Science, Umea University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87. To appear in Numerical Algorithms, 1996.</p>
<p>[3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software for Solving the Generalized Sylvester Equation and Estimating the Separation between Regular <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Pairs, Report UMINF - 93.23, Department of Computing Science, Umea University, S-901 87 Umea, Sweden, December 1993, Revised April 1994, Also as LAPACK Working Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1, 1996. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a547b8b07e9484fd80a073cdf0e5eb4b9_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="adb7d7c0f7de40de4084bcb693322e582"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTGSJA </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tola</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ncycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTGSJA computes the generalized singular value decomposition (GSVD) of two real upper triangular (or trapezoidal) matrices A and B.</p>
<p>On entry, it is assumed that matrices A and B have the following forms, which may be obtained by the preprocessing subroutine DGGSVP from a general M-by-N matrix A and P-by-N matrix B: </p>
<pre class="fragment">         N-K-L  K    L
</pre><p> A = K ( 0 A12 A13 ) if M-K-L &gt;= 0; L ( 0 0 A23 ) M-K-L ( 0 0 0 ) </p>
<pre class="fragment"> N-K-L  K    L
</pre><p> A = K ( 0 A12 A13 ) if M-K-L &lt; 0; M-K ( 0 0 A23 ) </p>
<pre class="fragment"> N-K-L  K    L
</pre><p> B = L ( 0 0 B13 ) P-L ( 0 0 0 )</p>
<p>where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular upper triangular; A23 is L-by-L upper triangular if M-K-L &gt;= 0, otherwise A23 is (M-K)-by-L upper trapezoidal.</p>
<p>On exit, </p>
<pre class="fragment">        U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R ),
</pre><p>where U, V and Q are orthogonal matrices, Z' denotes the transpose of Z, R is a nonsingular upper triangular matrix, and D1 and D2 are ``diagonal'' matrices, which are of the following structures:</p>
<p>If M-K-L &gt;= 0, </p>
<pre class="fragment">                K  L
   D1 =     K ( I  0 )
            L ( 0  C )
        M-K-L ( 0  0 )

              K  L
   D2 = L   ( 0  S )
        P-L ( 0  0 )

           N-K-L  K    L
</pre><p> ( 0 R ) = K ( 0 R11 R12 ) K L ( 0 0 R22 ) L</p>
<p>where</p>
<p>C = diag( ALPHA(K+1), ... , ALPHA(K+L) ), S = diag( BETA(K+1), ... , BETA(K+L) ), C**2 + S**2 = I.</p>
<p>R is stored in A(1:K+L,N-K-L+1:N) on exit.</p>
<p>If M-K-L &lt; 0, </p>
<pre class="fragment">           K M-K K+L-M
D1 =   K ( I  0    0   )
     M-K ( 0  C    0   )

             K M-K K+L-M
D2 =   M-K ( 0  S    0   )
     K+L-M ( 0  0    I   )
       P-L ( 0  0    0   )

           N-K-L  K   M-K  K+L-M
</pre><p> ( 0 R ) = K ( 0 R11 R12 R13 ) M-K ( 0 0 R22 R23 ) K+L-M ( 0 0 0 R33 )</p>
<p>where C = diag( ALPHA(K+1), ... , ALPHA(M) ), S = diag( BETA(K+1), ... , BETA(M) ), C**2 + S**2 = I.</p>
<p>R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored ( 0 R22 R23 ) in B(M-K+1:L,N+M-K-L+1:N) on exit.</p>
<p>The computation of the orthogonal transformation matrices U, V or Q is optional. These matrices may either be formed explicitly, or they may be postmultiplied into input matrices U1, V1, or Q1.</p>
<h1>Arguments</h1>
<p>JOBU (input) CHARACTER*1 = 'U': U must contain an orthogonal matrix U1 on entry, and the product U1*U is returned; = 'I': U is initialized to the unit matrix, and the orthogonal matrix U is returned; = 'N': U is not computed.</p>
<p>JOBV (input) CHARACTER*1 = 'V': V must contain an orthogonal matrix V1 on entry, and the product V1*V is returned; = 'I': V is initialized to the unit matrix, and the orthogonal matrix V is returned; = 'N': V is not computed.</p>
<p>JOBQ (input) CHARACTER*1 = 'Q': Q must contain an orthogonal matrix Q1 on entry, and the product Q1*Q is returned; = 'I': Q is initialized to the unit matrix, and the orthogonal matrix Q is returned; = 'N': Q is not computed.</p>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>P (input) INTEGER The number of rows of the matrix B. P &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrices A and B. N &gt;= 0.</p>
<p>K (input) INTEGER L (input) INTEGER K and L specify the subblocks in the input matrices A and B: A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,N-L+1:N) of A and B, whose GSVD is going to be computed by DTGSJA. See Further Details.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular matrix R or part of R. See Purpose for details.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,N) On entry, the P-by-N matrix B. On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains a part of R. See Purpose for details.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,P).</p>
<p>TOLA (input) DOUBLE PRECISION TOLB (input) DOUBLE PRECISION TOLA and TOLB are the convergence criteria for the Jacobi- Kogbetliantz iteration procedure. Generally, they are the same as used in the preprocessing step, say TOLA = max(M,N)*norm(A)*MAZHEPS, TOLB = max(P,N)*norm(B)*MAZHEPS.</p>
<p>ALPHA (output) DOUBLE PRECISION array, dimension (N) BETA (output) DOUBLE PRECISION array, dimension (N) On exit, ALPHA and BETA contain the generalized singular value pairs of A and B; ALPHA(1:K) = 1, BETA(1:K) = 0, and if M-K-L &gt;= 0, ALPHA(K+1:K+L) = diag(C), BETA(K+1:K+L) = diag(S), or if M-K-L &lt; 0, ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0 BETA(K+1:M) = S, BETA(M+1:K+L) = 1. Furthermore, if K+L &lt; N, ALPHA(K+L+1:N) = 0 and BETA(K+L+1:N) = 0.</p>
<p>U (input/output) DOUBLE PRECISION array, dimension (LDU,M) On entry, if JOBU = 'U', U must contain a matrix U1 (usually the orthogonal matrix returned by DGGSVP). On exit, if JOBU = 'I', U contains the orthogonal matrix U; if JOBU = 'U', U contains the product U1*U. If JOBU = 'N', U is not referenced.</p>
<p>LDU (input) INTEGER The leading dimension of the array U. LDU &gt;= max(1,M) if JOBU = 'U'; LDU &gt;= 1 otherwise.</p>
<p>V (input/output) DOUBLE PRECISION array, dimension (LDV,P) On entry, if JOBV = 'V', V must contain a matrix V1 (usually the orthogonal matrix returned by DGGSVP). On exit, if JOBV = 'I', V contains the orthogonal matrix V; if JOBV = 'V', V contains the product V1*V. If JOBV = 'N', V is not referenced.</p>
<p>LDV (input) INTEGER The leading dimension of the array V. LDV &gt;= max(1,P) if JOBV = 'V'; LDV &gt;= 1 otherwise.</p>
<p>Q (input/output) DOUBLE PRECISION array, dimension (LDQ,N) On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually the orthogonal matrix returned by DGGSVP). On exit, if JOBQ = 'I', Q contains the orthogonal matrix Q; if JOBQ = 'Q', Q contains the product Q1*Q. If JOBQ = 'N', Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= max(1,N) if JOBQ = 'Q'; LDQ &gt;= 1 otherwise.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (2*N)</p>
<p>NCYCLE (output) INTEGER The number of cycles required for convergence.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value. = 1: the procedure does not converge after MAXIT cycles.</p>
<h1>Internal Parameters</h1>
<p>MAXIT INTEGER MAXIT specifies the total loops that the iterative procedure may take. If after MAXIT cycles, the routine fails to converge, we return INFO = 1.</p>
<h1>Further Details</h1>
<p>DTGSJA essentially uses a variant of Kogbetliantz algorithm to reduce min(L,M-K)-by-L triangular (or trapezoidal) matrix A23 and L-by-L matrix B13 to the form: </p>
<pre class="fragment">     U1'*A13*Q1 = C1*R1; V1'*B13*Q1 = S1*R1,
</pre><p>where U1, V1 and Q1 are orthogonal matrix, and Z' is the transpose of Z. C1 and S1 are diagonal matrices satisfying </p>
<pre class="fragment">          C1**2 + S1**2 = I,
</pre><p>and R1 is an L-by-L nonsingular upper triangular matrix. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_adb7d7c0f7de40de4084bcb693322e582_icgraph.svg" width="307" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2aacde015922e60e4c9dc0a3c513a02c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTGSNA </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>howmny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTGSNA estimates reciprocal condition numbers for specified eigenvalues and/or eigenvectors of a matrix pair (A, B) in generalized real Schur canonical form (or of any matrix pair (Q*A*Z', Q*B*Z') with orthogonal matrices Q and Z, where Z' denotes the transpose of Z.</p>
<p>(A, B) must be in generalized real Schur form (as returned by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper triangular.</p>
<h1>Arguments</h1>
<p>JOB (input) CHARACTER*1 Specifies whether condition numbers are required for eigenvalues (S) or eigenvectors (DIF): = 'E': for eigenvalues only (S); = 'V': for eigenvectors only (DIF); = 'B': for both eigenvalues and eigenvectors (S and DIF).</p>
<p>HOWMNY (input) CHARACTER*1 = 'A': compute condition numbers for all eigenpairs; = 'S': compute condition numbers for selected eigenpairs specified by the array SELECT.</p>
<p>SELECT (input) LOGICAL array, dimension (N) If HOWMNY = 'S', SELECT specifies the eigenpairs for which condition numbers are required. To select condition numbers for the eigenpair corresponding to a real eigenvalue w(j), SELECT(j) must be set to .TRUE.. To select condition numbers corresponding to a complex conjugate pair of eigenvalues w(j) and w(j+1), either SELECT(j) or SELECT(j+1) or both, must be set to .TRUE.. If HOWMNY = 'A', SELECT is not referenced.</p>
<p>N (input) INTEGER The order of the square matrix pair (A, B). N &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The upper quasi-triangular matrix A in the pair (A,B).</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,N) The upper triangular matrix B in the pair (A,B).</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>VL (input) DOUBLE PRECISION array, dimension (LDVL,M) If JOB = 'E' or 'B', VL must contain left eigenvectors of (A, B), corresponding to the eigenpairs specified by HOWMNY and SELECT. The eigenvectors must be stored in consecutive columns of VL, as returned by DTGEVC. If JOB = 'V', VL is not referenced.</p>
<p>LDVL (input) INTEGER The leading dimension of the array VL. LDVL &gt;= 1. If JOB = 'E' or 'B', LDVL &gt;= N.</p>
<p>VR (input) DOUBLE PRECISION array, dimension (LDVR,M) If JOB = 'E' or 'B', VR must contain right eigenvectors of (A, B), corresponding to the eigenpairs specified by HOWMNY and SELECT. The eigenvectors must be stored in consecutive columns ov VR, as returned by DTGEVC. If JOB = 'V', VR is not referenced.</p>
<p>LDVR (input) INTEGER The leading dimension of the array VR. LDVR &gt;= 1. If JOB = 'E' or 'B', LDVR &gt;= N.</p>
<p>S (output) DOUBLE PRECISION array, dimension (MM) If JOB = 'E' or 'B', the reciprocal condition numbers of the selected eigenvalues, stored in consecutive elements of the array. For a complex conjugate pair of eigenvalues two consecutive elements of S are set to the same value. Thus S(j), DIF(j), and the j-th columns of VL and VR all correspond to the same eigenpair (but not in general the j-th eigenpair, unless all eigenpairs are selected). If JOB = 'V', S is not referenced.</p>
<p>DIF (output) DOUBLE PRECISION array, dimension (MM) If JOB = 'V' or 'B', the estimated reciprocal condition numbers of the selected eigenvectors, stored in consecutive elements of the array. For a complex eigenvector two consecutive elements of DIF are set to the same value. If the eigenvalues cannot be reordered to compute DIF(j), DIF(j) is set to 0; this can only occur when the true value would be very small anyway. If JOB = 'E', DIF is not referenced.</p>
<p>MM (input) INTEGER The number of elements in the arrays S and DIF. MM &gt;= M.</p>
<p>M (output) INTEGER The number of elements of the arrays S and DIF used to store the specified condition numbers; for each selected real eigenvalue one element is used, and for each selected complex conjugate pair of eigenvalues, two elements are used. If HOWMNY = 'A', M is set to N.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N). If JOB = 'V' or 'B' LWORK &gt;= 2*N*(N+2)+16.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace) INTEGER array, dimension (N + 6) If JOB = 'E', IWORK is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER =0: Successful exit &lt;0: If INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>The reciprocal of the condition number of a generalized eigenvalue w = (a, b) is defined as </p>
<pre class="fragment"> S(w) = (|u'Av|**2 + |u'Bv|**2)**(1/2) / (norm(u)*norm(v))
</pre><p>where u and v are the left and right eigenvectors of (A, B) corresponding to w; |z| denotes the absolute value of the complex number, and norm(u) denotes the 2-norm of the vector u. The pair (a, b) corresponds to an eigenvalue w = a/b (= u'Av/u'Bv) of the matrix pair (A, B). If both a and b equal zero, then (A B) is singular and S(I) = -1 is returned.</p>
<p>An approximate error bound on the chordal distance between the i-th computed generalized eigenvalue w and the corresponding exact eigenvalue lambda is </p>
<pre class="fragment"> chord(w, lambda) &lt;= EPS * norm(A, B) / S(I)
</pre><p>where EPS is the machine precision.</p>
<p>The reciprocal of the condition number DIF(i) of right eigenvector u and left eigenvector v corresponding to the generalized eigenvalue w is defined as follows:</p>
<p>a) If the i-th eigenvalue w = (a,b) is real</p>
<p>Suppose U and V are orthogonal transformations such that </p>
<pre class="fragment">       U'*(A, B)*V  = (S, T) = ( a   *  ) ( b  *  )  1
                               ( 0  S22 ),( 0 T22 )  n-1
                                 1  n-1     1 n-1
</pre><p>Then the reciprocal condition number DIF(i) is </p>
<pre class="fragment">       Difl((a, b), (S22, T22)) = sigma-min( Zl ),
</pre><p>where sigma-min(Zl) denotes the smallest singular value of the 2(n-1)-by-2(n-1) matrix </p>
<pre class="fragment">Zl = [ kron(a, In-1)  -kron(1, S22) ]
     [ kron(b, In-1)  -kron(1, T22) ] .
</pre><p>Here In-1 is the identity matrix of size n-1. kron(X, Y) is the Kronecker product between the matrices X and Y.</p>
<p>Note that if the default method for computing DIF(i) is wanted (see DLATDF), then the parameter DIFDRI (see below) should be changed from 3 to 4 (routine DLATDF(IJOB = 2 will be used)). See DTGSYL for more details.</p>
<p>b) If the i-th and (i+1)-th eigenvalues are complex conjugate pair,</p>
<p>Suppose U and V are orthogonal transformations such that </p>
<pre class="fragment">       U'*(A, B)*V = (S, T) = ( S11  *   ) ( T11  *  )  2
                              ( 0    S22 ),( 0    T22) n-2
                                2    n-2     2    n-2
</pre><p>and (S11, T11) corresponds to the complex conjugate eigenvalue pair (w, conjg(w)). There exist unitary matrices U1 and V1 such that </p>
<pre class="fragment">U1'*S11*V1 = ( s11 s12 )   and U1'*T11*V1 = ( t11 t12 )
             (  0  s22 )                    (  0  t22 )
</pre><p>where the generalized eigenvalues w = s11/t11 and conjg(w) = s22/t22.</p>
<p>Then the reciprocal condition number DIF(i) is bounded by </p>
<pre class="fragment">min( d1, max( 1, |real(s11)/real(s22)| )*d2 )
</pre><p>where, d1 = Difl((s11, t11), (s22, t22)) = sigma-min(Z1), where Z1 is the complex 2-by-2 matrix </p>
<pre class="fragment">     Z1 =  [ s11  -s22 ]
           [ t11  -t22 ],
</pre><p>This is done by computing (using real arithmetic) the roots of the characteristical polynomial det(Z1' * Z1 - lambda I), where Z1' denotes the conjugate transpose of Z1 and det(X) denotes the determinant of X.</p>
<p>and d2 is an upper bound on Difl((S11, T11), (S22, T22)), i.e. an upper bound on sigma-min(Z2), where Z2 is (2n-2)-by-(2n-2) </p>
<pre class="fragment">     Z2 = [ kron(S11', In-2)  -kron(I2, S22) ]
          [ kron(T11', In-2)  -kron(I2, T22) ]
</pre><p>Note that if the default method for computing DIF is wanted (see DLATDF), then the parameter DIFDRI (see below) should be changed from 3 to 4 (routine DLATDF(IJOB = 2 will be used)). See DTGSYL for more details.</p>
<p>For each eigenvalue/vector specified by SELECT, DIF stores a Frobenius norm-based estimate of Difl.</p>
<p>An approximate error bound for the i-th computed eigenvector VL(i) or VR(i) is given by </p>
<pre class="fragment">       EPS * norm(A, B) / DIF(i).
</pre><p>See ref. [2-3] for more details and further references.</p>
<p>Based on contributions by Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea, Sweden.</p>
<h1>References</h1>
<p>[1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the Generalized Real Schur Form of a Regular <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Pair (A, B), in M.S. Moonen et al (eds), Linear Algebra for Large Scale and Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.</p>
<p>[2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified Eigenvalues of a Regular <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Pair (A, B) and Condition Estimation: Theory, Algorithms and Software, Report UMINF - 94.04, Department of Computing Science, Umea University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87. To appear in Numerical Algorithms, 1996.</p>
<p>[3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software for Solving the Generalized Sylvester Equation and Estimating the Separation between Regular <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Pairs, Report UMINF - 93.23, Department of Computing Science, Umea University, S-901 87 Umea, Sweden, December 1993, Revised April 1994, Also as LAPACK Working Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1, 1996. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a2aacde015922e60e4c9dc0a3c513a02c_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a34329b47cf967d5a2e199527098ad965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTGSYL </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ijob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTGSYL solves the generalized Sylvester equation: </p>
<pre class="fragment">        A * R - L * B = scale * C                 (1)
        D * R - L * E = scale * F
</pre><p>where R and L are unknown m-by-n matrices, (A, D), (B, E) and (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n, respectively, with real entries. (A, D) and (B, E) must be in generalized (real) Schur canonical form, i.e. A, B are upper quasi triangular and D, E are upper triangular.</p>
<p>The solution (R, L) overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output scaling factor chosen to avoid overflow.</p>
<p>In matrix notation (1) is equivalent to solve Zx = scale b, where Z is defined as </p>
<pre class="fragment">       Z = [ kron(In, A)  -kron(B', Im) ]         (2)
           [ kron(In, D)  -kron(E', Im) ].
</pre><p>Here Ik is the identity matrix of size k and X' is the transpose of X. kron(X, Y) is the Kronecker product between the matrices X and Y.</p>
<p>If TRANS = 'T', DTGSYL solves the transposed system Z'*y = scale*b, which is equivalent to solve for R and L in </p>
<pre class="fragment">        A' * R  + D' * L   = scale *  C           (3)
        R  * B' + L  * E'  = scale * (-F)
</pre><p>This case (TRANS = 'T') is used to compute an one-norm-based estimate of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D) and (B,E), using DLACON.</p>
<p>If IJOB &gt;= 1, DTGSYL computes a Frobenius norm-based estimate of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the reciprocal of the smallest singular value of Z. See [1-2] for more information.</p>
<p>This is a level 3 BLAS algorithm.</p>
<h1>Arguments</h1>
<p>TRANS (input) CHARACTER*1 = 'N', solve the generalized Sylvester equation (1). = 'T', solve the 'transposed' system (3).</p>
<p>IJOB (input) INTEGER Specifies what kind of functionality to be performed. =0: solve (1) only. =1: The functionality of 0 and 3. =2: The functionality of 0 and 4. =3: Only an estimate of Dif[(A,D), (B,E)] is computed. (look ahead strategy IJOB = 1 is used). =4: Only an estimate of Dif[(A,D), (B,E)] is computed. ( DGECON on sub-systems is used ). Not referenced if TRANS = 'T'.</p>
<p>M (input) INTEGER The order of the matrices A and D, and the row dimension of the matrices C, F, R and L.</p>
<p>N (input) INTEGER The order of the matrices B and E, and the column dimension of the matrices C, F, R and L.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA, M) The upper quasi triangular matrix A.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1, M).</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB, N) The upper quasi triangular matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1, N).</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC, N) On entry, C contains the right-hand-side of the first matrix equation in (1) or (3). On exit, if IJOB = 0, 1 or 2, C has been overwritten by the solution R. If IJOB = 3 or 4 and TRANS = 'N', C holds R, the solution achieved during the computation of the Dif-estimate.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1, M).</p>
<p>D (input) DOUBLE PRECISION array, dimension (LDD, M) The upper triangular matrix D.</p>
<p>LDD (input) INTEGER The leading dimension of the array D. LDD &gt;= max(1, M).</p>
<p>E (input) DOUBLE PRECISION array, dimension (LDE, N) The upper triangular matrix E.</p>
<p>LDE (input) INTEGER The leading dimension of the array E. LDE &gt;= max(1, N).</p>
<p>F (input/output) DOUBLE PRECISION array, dimension (LDF, N) On entry, F contains the right-hand-side of the second matrix equation in (1) or (3). On exit, if IJOB = 0, 1 or 2, F has been overwritten by the solution L. If IJOB = 3 or 4 and TRANS = 'N', F holds L, the solution achieved during the computation of the Dif-estimate.</p>
<p>LDF (input) INTEGER The leading dimension of the array F. LDF &gt;= max(1, M).</p>
<p>DIF (output) DOUBLE PRECISION On exit DIF is the reciprocal of a lower bound of the reciprocal of the Dif-function, i.e. DIF is an upper bound of Dif[(A,D), (B,E)] = sigma_min(Z), where Z as in (2). IF IJOB = 0 or TRANS = 'T', DIF is not touched.</p>
<p>SCALE (output) DOUBLE PRECISION On exit SCALE is the scaling factor in (1) or (3). If 0 &lt; SCALE &lt; 1, C and F hold the solutions R and L, resp., to a slightly perturbed system but the input matrices A, B, D and E have not been changed. If SCALE = 0, C and F hold the solutions R and L, respectively, to the homogeneous system with C = F = 0. Normally, SCALE = 1.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt; = 1. If IJOB = 1 or 2 and TRANS = 'N', LWORK &gt;= max(1,2*M*N).</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace) INTEGER array, dimension (M+N+6)</p>
<p>C++ Return value: INFO (output) INTEGER =0: successful exit &lt;0: If INFO = -i, the i-th argument had an illegal value. &gt;0: (A, D) and (B, E) have common or close eigenvalues.</p>
<h1>Further Details</h1>
<p>Based on contributions by Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea, Sweden.</p>
<p>[1] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software for Solving the Generalized Sylvester Equation and Estimating the Separation between Regular <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Pairs, Report UMINF - 93.23, Department of Computing Science, Umea University, S-901 87 Umea, Sweden, December 1993, Revised April 1994, Also as LAPACK Working Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1, 1996.</p>
<p>[2] B. Kagstrom, A Perturbation Analysis of the Generalized Sylvester Equation (AR - LB, DR - LE ) = (C, F), SIAM J. <a class="el" href="classpsi_1_1Matrix.html" title="Makes using matrices just a little easier.">Matrix</a> Anal. Appl., 15(4):1045-1060, 1994</p>
<p>[3] B. Kagstrom and L. Westin, Generalized Schur Methods with Condition Estimators for Solving the Generalized Sylvester Equation, IEEE Transactions on Automatic Control, Vol. 34, No. 7, July 1989, pp 745-751. </p>
<hr/>
<p> Replaced various illegal calls to DCOPY by calls to DLASET. Sven Hammarling, 1/5/02.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a34329b47cf967d5a2e199527098ad965_icgraph.svg" width="307" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a60011294324d6ff0548f89cc31eb8618"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTPCON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTPCON estimates the reciprocal of the condition number of a packed triangular matrix A, in either the 1-norm or the infinity-norm.</p>
<p>The norm of A is computed and an estimate is obtained for norm(inv(A)), then the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).</p>
<h1>Arguments</h1>
<p>NORM (input) CHARACTER*1 Specifies whether the 1-norm condition number or the infinity-norm condition number is required: = '1' or 'O': 1-norm; = 'I': Infinity-norm.</p>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The upper or lower triangular matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n. If DIAG = 'U', the diagonal elements of A are not referenced and are assumed to be 1.</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(norm(A) * norm(inv(A))).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a0db6b9a025813c7aea8455a75567dbee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DTPMV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTPMV performs one of the matrix-vector operations</p>
<p>x := A*x, or x := A'*x,</p>
<p>where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix, supplied in packed form.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the matrix is an upper or lower triangular matrix as follows:</p>
<p>UPLO = 'U' or 'u' A is an upper triangular matrix.</p>
<p>UPLO = 'L' or 'l' A is a lower triangular matrix.</p>
<p>Unchanged on exit.</p>
<p>TRANS - CHARACTER*1. On entry, TRANS specifies the operation to be performed as follows:</p>
<p>TRANS = 'N' or 'n' x := A*x.</p>
<p>TRANS = 'T' or 't' x := A'*x.</p>
<p>TRANS = 'C' or 'c' x := A'*x.</p>
<p>Unchanged on exit.</p>
<p>DIAG - CHARACTER*1. On entry, DIAG specifies whether or not A is unit triangular as follows:</p>
<p>DIAG = 'U' or 'u' A is assumed to be unit triangular.</p>
<p>DIAG = 'N' or 'n' A is not assumed to be unit triangular.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>AP - DOUBLE PRECISION array of DIMENSION at least ( ( n*( n + 1 ) )/2 ). Before entry with UPLO = 'U' or 'u', the array AP must contain the upper triangular matrix packed sequentially, column by column, so that AP( 1 ) contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) respectively, and so on. Before entry with UPLO = 'L' or 'l', the array AP must contain the lower triangular matrix packed sequentially, column by column, so that AP( 1 ) contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) respectively, and so on. Note that when DIAG = 'U' or 'u', the diagonal elements of A are not referenced, but are assumed to be unity. Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element vector x. On exit, X is overwritten with the tranformed vector x.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="ae1bc863b8ea536f7e92227f30bed11e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTPRFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTPRFS provides error bounds and backward error estimates for the solution to a system of linear equations with a triangular packed coefficient matrix.</p>
<p>The solution matrix X must be computed by DTPTRS or some other means before entering this routine. DTPRFS does not do iterative refinement because doing so cannot improve the backward error.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Conjugate transpose = Transpose)</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The upper or lower triangular matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n. If DIAG = 'U', the diagonal elements of A are not referenced and are assumed to be 1.</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input) DOUBLE PRECISION array, dimension (LDX,NRHS) The solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="acd5b5ba0433df8294c0def4896b138c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DTPSV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTPSV solves one of the systems of equations</p>
<p>A*x = b, or A'*x = b,</p>
<p>where b and x are n element vectors and A is an n by n unit, or non-unit, upper or lower triangular matrix, supplied in packed form.</p>
<p>No test for singularity or near-singularity is included in this routine. Such tests must be performed before calling this routine.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the matrix is an upper or lower triangular matrix as follows:</p>
<p>UPLO = 'U' or 'u' A is an upper triangular matrix.</p>
<p>UPLO = 'L' or 'l' A is a lower triangular matrix.</p>
<p>Unchanged on exit.</p>
<p>TRANS - CHARACTER*1. On entry, TRANS specifies the equations to be solved as follows:</p>
<p>TRANS = 'N' or 'n' A*x = b.</p>
<p>TRANS = 'T' or 't' A'*x = b.</p>
<p>TRANS = 'C' or 'c' A'*x = b.</p>
<p>Unchanged on exit.</p>
<p>DIAG - CHARACTER*1. On entry, DIAG specifies whether or not A is unit triangular as follows:</p>
<p>DIAG = 'U' or 'u' A is assumed to be unit triangular.</p>
<p>DIAG = 'N' or 'n' A is not assumed to be unit triangular.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>AP - DOUBLE PRECISION array of DIMENSION at least ( ( n*( n + 1 ) )/2 ). Before entry with UPLO = 'U' or 'u', the array AP must contain the upper triangular matrix packed sequentially, column by column, so that AP( 1 ) contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) respectively, and so on. Before entry with UPLO = 'L' or 'l', the array AP must contain the lower triangular matrix packed sequentially, column by column, so that AP( 1 ) contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) respectively, and so on. Note that when DIAG = 'U' or 'u', the diagonal elements of A are not referenced, but are assumed to be unity. Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element right-hand side vector b. On exit, X is overwritten with the solution vector x.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="a8f7cd4d684f88bbd6f502102bdef366a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTPTRI </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTPTRI computes the inverse of a real upper or lower triangular matrix A stored in packed format.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>AP (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2) On entry, the upper or lower triangular matrix A, stored columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n. See below for further details. On exit, the (triangular) inverse of the original matrix, in the same packed storage format.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, A(i,i) is exactly zero. The triangular matrix is singular and its inverse can not be computed.</p>
<h1>Further Details</h1>
<p>A triangular matrix A can be transferred to packed storage using one of the following program segments:</p>
<p>UPLO = 'U': UPLO = 'L': </p>
<pre class="fragment">  JC = 1                           JC = 1
  DO 2 J = 1, N                    DO 2 J = 1, N
     DO 1 I = 1, J                    DO 1 I = J, N
        AP(JC+I-1) = A(I,J)              AP(JC+I-J) = A(I,J)
1    CONTINUE                    1    CONTINUE
     JC = JC + J                      JC = JC + N - J + 1
2 CONTINUE                       2 CONTINUE
</pre><p>=====================================================================</p>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="ad668ca911939ffd5dca320a977aadbf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTPTRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTPTRS solves a triangular system of the form</p>
<p>A * X = B or A**T * X = B,</p>
<p>where A is a triangular matrix of order N stored in packed format, and B is an N-by-NRHS matrix. A check is made to verify that A is nonsingular.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Conjugate transpose = Transpose)</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>AP (input) DOUBLE PRECISION array, dimension (N*(N+1)/2) The upper or lower triangular matrix A, packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows: if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j; if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, if INFO = 0, the solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the i-th diagonal element of A is zero, indicating that the matrix is singular and the solutions X have not been computed. </p>
<hr/>
<p>.. Parameters .. </p>

</div>
</div>
<a class="anchor" id="aac2cdead61919a224c281f5ef09a859e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTRCON </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRCON estimates the reciprocal of the condition number of a triangular matrix A, in either the 1-norm or the infinity-norm.</p>
<p>The norm of A is computed and an estimate is obtained for norm(inv(A)), then the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).</p>
<h1>Arguments</h1>
<p>NORM (input) CHARACTER*1 Specifies whether the 1-norm condition number or the infinity-norm condition number is required: = '1' or 'O': 1-norm; = 'I': Infinity-norm.</p>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The triangular matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If DIAG = 'U', the diagonal elements of A are also not referenced and are assumed to be 1.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>RCOND (output) DOUBLE PRECISION The reciprocal of the condition number of the matrix A, computed as RCOND = 1/(norm(A) * norm(inv(A))).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aac2cdead61919a224c281f5ef09a859e_icgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8206214f832343fea2981c4664423bc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTREVC </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>howmny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTREVC computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T. Matrices of this type are produced by the Schur factorization of a real general matrix: A = Q*T*Q**T, as computed by DHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by:</p>
<p>T*x = w*x, (y**H)*T = w*(y**H)</p>
<p>where y**H denotes the conjugate transpose of y. The eigenvalues are not input to this routine, but are read directly from the diagonal blocks of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the orthogonal factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<h1>Arguments</h1>
<p>SIDE (input) CHARACTER*1 = 'R': compute right eigenvectors only; = 'L': compute left eigenvectors only; = 'B': compute both right and left eigenvectors.</p>
<p>HOWMNY (input) CHARACTER*1 = 'A': compute all right and/or left eigenvectors; = 'B': compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL; = 'S': compute selected right and/or left eigenvectors, as indicated by the logical array SELECT.</p>
<p>SELECT (input/output) LOGICAL array, dimension (N) If HOWMNY = 'S', SELECT specifies the eigenvectors to be computed. If w(j) is a real eigenvalue, the corresponding real eigenvector is computed if SELECT(j) is .TRUE.. If w(j) and w(j+1) are the real and imaginary parts of a complex eigenvalue, the corresponding complex eigenvector is computed if either SELECT(j) or SELECT(j+1) is .TRUE., and on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to .FALSE.. Not referenced if HOWMNY = 'A' or 'B'.</p>
<p>N (input) INTEGER The order of the matrix T. N &gt;= 0.</p>
<p>T (input) DOUBLE PRECISION array, dimension (LDT,N) The upper quasi-triangular matrix T in Schur canonical form.</p>
<p>LDT (input) INTEGER The leading dimension of the array T. LDT &gt;= max(1,N).</p>
<p>VL (input/output) DOUBLE PRECISION array, dimension (LDVL,MM) On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must contain an N-by-N matrix Q (usually the orthogonal matrix Q of Schur vectors returned by DHSEQR). On exit, if SIDE = 'L' or 'B', VL contains: if HOWMNY = 'A', the matrix Y of left eigenvectors of T; if HOWMNY = 'B', the matrix Q*Y; if HOWMNY = 'S', the left eigenvectors of T specified by SELECT, stored consecutively in the columns of VL, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part, and the second the imaginary part. Not referenced if SIDE = 'R'.</p>
<p>LDVL (input) INTEGER The leading dimension of the array VL. LDVL &gt;= 1, and if SIDE = 'L' or 'B', LDVL &gt;= N.</p>
<p>VR (input/output) DOUBLE PRECISION array, dimension (LDVR,MM) On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must contain an N-by-N matrix Q (usually the orthogonal matrix Q of Schur vectors returned by DHSEQR). On exit, if SIDE = 'R' or 'B', VR contains: if HOWMNY = 'A', the matrix X of right eigenvectors of T; if HOWMNY = 'B', the matrix Q*X; if HOWMNY = 'S', the right eigenvectors of T specified by SELECT, stored consecutively in the columns of VR, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part and the second the imaginary part. Not referenced if SIDE = 'L'.</p>
<p>LDVR (input) INTEGER The leading dimension of the array VR. LDVR &gt;= 1, and if SIDE = 'R' or 'B', LDVR &gt;= N.</p>
<p>MM (input) INTEGER The number of columns in the arrays VL and/or VR. MM &gt;= M.</p>
<p>M (output) INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If HOWMNY = 'A' or 'B', M is set to N. Each selected real eigenvector occupies one column and each selected complex eigenvector occupies two columns.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a8206214f832343fea2981c4664423bc7_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7721141f3a8c20f09dcd068c84bd96c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTREXC </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ilst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTREXC reorders the real Schur factorization of a real matrix A = Q*T*Q**T, so that the diagonal block of T with row index IFST is moved to row ILST.</p>
<p>The real Schur form T is reordered by an orthogonal similarity transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors is updated by postmultiplying it with Z.</p>
<p>T must be in Schur canonical form (as returned by DHSEQR), that is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block has its diagonal elements equal and its off-diagonal elements of opposite sign.</p>
<h1>Arguments</h1>
<p>COMPQ (input) CHARACTER*1 = 'V': update the matrix Q of Schur vectors; = 'N': do not update Q.</p>
<p>N (input) INTEGER The order of the matrix T. N &gt;= 0.</p>
<p>T (input/output) DOUBLE PRECISION array, dimension (LDT,N) On entry, the upper quasi-triangular matrix T, in Schur Schur canonical form. On exit, the reordered upper quasi-triangular matrix, again in Schur canonical form.</p>
<p>LDT (input) INTEGER The leading dimension of the array T. LDT &gt;= max(1,N).</p>
<p>Q (input/output) DOUBLE PRECISION array, dimension (LDQ,N) On entry, if COMPQ = 'V', the matrix Q of Schur vectors. On exit, if COMPQ = 'V', Q has been postmultiplied by the orthogonal transformation matrix Z which reorders T. If COMPQ = 'N', Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= max(1,N).</p>
<p>IFST (input/output) INTEGER ILST (input/output) INTEGER Specify the reordering of the diagonal blocks of T. The block with row index IFST is moved to row ILST, by a sequence of transpositions between adjacent blocks. On exit, if IFST pointed on entry to the second row of a 2-by-2 block, it is changed to point to the first row; ILST always points to the first row of the block in its final position (which may differ from its input value by +1 or -1). 1 &lt;= IFST &lt;= N; 1 &lt;= ILST &lt;= N.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value = 1: two adjacent blocks were too close to swap (the problem is very ill-conditioned); T may have been partially reordered, and ILST points to the first row of the current position of the block being moved. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a7721141f3a8c20f09dcd068c84bd96c1_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3b620f8268d58b37f94c9fc266a0358b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DTRMM </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>transa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRMM performs one of the matrix-matrix operations</p>
<p>B := alpha*op( A )*B, or B := alpha*B*op( A ),</p>
<p>where alpha is a scalar, B is an m by n matrix, A is a unit, or non-unit, upper or lower triangular matrix and op( A ) is one of</p>
<p>op( A ) = A or op( A ) = A'.</p>
<h1>Arguments</h1>
<p>SIDE - CHARACTER*1. On entry, SIDE specifies whether op( A ) multiplies B from the left or right as follows:</p>
<p>SIDE = 'L' or 'l' B := alpha*op( A )*B.</p>
<p>SIDE = 'R' or 'r' B := alpha*B*op( A ).</p>
<p>Unchanged on exit.</p>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the matrix A is an upper or lower triangular matrix as follows:</p>
<p>UPLO = 'U' or 'u' A is an upper triangular matrix.</p>
<p>UPLO = 'L' or 'l' A is a lower triangular matrix.</p>
<p>Unchanged on exit.</p>
<p>TRANSA - CHARACTER*1. On entry, TRANSA specifies the form of op( A ) to be used in the matrix multiplication as follows:</p>
<p>TRANSA = 'N' or 'n' op( A ) = A.</p>
<p>TRANSA = 'T' or 't' op( A ) = A'.</p>
<p>TRANSA = 'C' or 'c' op( A ) = A'.</p>
<p>Unchanged on exit.</p>
<p>DIAG - CHARACTER*1. On entry, DIAG specifies whether or not A is unit triangular as follows:</p>
<p>DIAG = 'U' or 'u' A is assumed to be unit triangular.</p>
<p>DIAG = 'N' or 'n' A is not assumed to be unit triangular.</p>
<p>Unchanged on exit.</p>
<p>M - INTEGER. On entry, M specifies the number of rows of B. M must be at least zero. Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the number of columns of B. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. When alpha is zero then A is not referenced and B need not be set before entry. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m when SIDE = 'L' or 'l' and is n when SIDE = 'R' or 'r'. Before entry with UPLO = 'U' or 'u', the leading k by k upper triangular part of the array A must contain the upper triangular matrix and the strictly lower triangular part of A is not referenced. Before entry with UPLO = 'L' or 'l', the leading k by k lower triangular part of the array A must contain the lower triangular matrix and the strictly upper triangular part of A is not referenced. Note that when DIAG = 'U' or 'u', the diagonal elements of A are not referenced either, but are assumed to be unity. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. When SIDE = 'L' or 'l' then LDA must be at least max( 1, m ), when SIDE = 'R' or 'r' then LDA must be at least max( 1, n ). Unchanged on exit.</p>
<p>B - DOUBLE PRECISION array of DIMENSION ( LDB, n ). Before entry, the leading m by n part of the array B must contain the matrix B, and on exit is overwritten by the transformed matrix.</p>
<p>LDB - INTEGER. On entry, LDB specifies the first dimension of B as declared in the calling (sub) program. LDB must be at least max( 1, m ). Unchanged on exit.</p>
<p>Level 3 Blas routine.</p>
<p>&ndash; Written on 8-February-1989. Jack Dongarra, Argonne National Laboratory. Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical Algorithms Group Ltd.</p>
<p>.. External Functions .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a3b620f8268d58b37f94c9fc266a0358b_icgraph.svg" width="302" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a55c4e138f4d0df19978ce97df5c883d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DTRMV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRMV performs one of the matrix-vector operations</p>
<p>x := A*x, or x := A'*x,</p>
<p>where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the matrix is an upper or lower triangular matrix as follows:</p>
<p>UPLO = 'U' or 'u' A is an upper triangular matrix.</p>
<p>UPLO = 'L' or 'l' A is a lower triangular matrix.</p>
<p>Unchanged on exit.</p>
<p>TRANS - CHARACTER*1. On entry, TRANS specifies the operation to be performed as follows:</p>
<p>TRANS = 'N' or 'n' x := A*x.</p>
<p>TRANS = 'T' or 't' x := A'*x.</p>
<p>TRANS = 'C' or 'c' x := A'*x.</p>
<p>Unchanged on exit.</p>
<p>DIAG - CHARACTER*1. On entry, DIAG specifies whether or not A is unit triangular as follows:</p>
<p>DIAG = 'U' or 'u' A is assumed to be unit triangular.</p>
<p>DIAG = 'N' or 'n' A is not assumed to be unit triangular.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry with UPLO = 'U' or 'u', the leading n by n upper triangular part of the array A must contain the upper triangular matrix and the strictly lower triangular part of A is not referenced. Before entry with UPLO = 'L' or 'l', the leading n by n lower triangular part of the array A must contain the lower triangular matrix and the strictly upper triangular part of A is not referenced. Note that when DIAG = 'U' or 'u', the diagonal elements of A are not referenced either, but are assumed to be unity. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least max( 1, n ). Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element vector x. On exit, X is overwritten with the tranformed vector x.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a55c4e138f4d0df19978ce97df5c883d7_icgraph.svg" width="296" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab41dba57c69e75118353923fa54063b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTRRFS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRRFS provides error bounds and backward error estimates for the solution to a system of linear equations with a triangular coefficient matrix.</p>
<p>The solution matrix X must be computed by DTRTRS or some other means before entering this routine. DTRRFS does not do iterative refinement because doing so cannot improve the backward error.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Conjugate transpose = Transpose)</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The triangular matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If DIAG = 'U', the diagonal elements of A are also not referenced and are assumed to be 1.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,NRHS) The right hand side matrix B.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>X (input) DOUBLE PRECISION array, dimension (LDX,NRHS) The solution matrix X.</p>
<p>LDX (input) INTEGER The leading dimension of the array X. LDX &gt;= max(1,N).</p>
<p>FERR (output) DOUBLE PRECISION array, dimension (NRHS) The estimated forward error bound for each solution vector X(j) (the j-th column of the solution matrix X). If XTRUE is the true solution corresponding to X(j), FERR(j) is an estimated upper bound for the magnitude of the largest element in (X(j) - XTRUE) divided by the magnitude of the largest element in X(j). The estimate is as reliable as the estimate for RCOND, and is almost always a slight overestimate of the true error.</p>
<p>BERR (output) DOUBLE PRECISION array, dimension (NRHS) The componentwise relative backward error of each solution vector X(j) (i.e., the smallest relative change in any element of A or B that makes X(j) an exact solution).</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (3*N)</p>
<p>IWORK (workspace) INTEGER array, dimension (N)</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ab41dba57c69e75118353923fa54063b9_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="abf52b26732c3b34af0bdd6359c0645da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTRSEN </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRSEN reorders the real Schur factorization of a real matrix A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper quasi-triangular matrix T, and the leading columns of Q form an orthonormal basis of the corresponding right invariant subspace.</p>
<p>Optionally the routine computes the reciprocal condition numbers of the cluster of eigenvalues and/or the invariant subspace.</p>
<p>T must be in Schur canonical form (as returned by DHSEQR), that is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block has its diagonal elemnts equal and its off-diagonal elements of opposite sign.</p>
<h1>Arguments</h1>
<p>JOB (input) CHARACTER*1 Specifies whether condition numbers are required for the cluster of eigenvalues (S) or the invariant subspace (SEP): = 'N': none; = 'E': for eigenvalues only (S); = 'V': for invariant subspace only (SEP); = 'B': for both eigenvalues and invariant subspace (S and SEP).</p>
<p>COMPQ (input) CHARACTER*1 = 'V': update the matrix Q of Schur vectors; = 'N': do not update Q.</p>
<p>SELECT (input) LOGICAL array, dimension (N) SELECT specifies the eigenvalues in the selected cluster. To select a real eigenvalue w(j), SELECT(j) must be set to .TRUE.. To select a complex conjugate pair of eigenvalues w(j) and w(j+1), corresponding to a 2-by-2 diagonal block, either SELECT(j) or SELECT(j+1) or both must be set to .TRUE.; a complex conjugate pair of eigenvalues must be either both included in the cluster or both excluded.</p>
<p>N (input) INTEGER The order of the matrix T. N &gt;= 0.</p>
<p>T (input/output) DOUBLE PRECISION array, dimension (LDT,N) On entry, the upper quasi-triangular matrix T, in Schur canonical form. On exit, T is overwritten by the reordered matrix T, again in Schur canonical form, with the selected eigenvalues in the leading diagonal blocks.</p>
<p>LDT (input) INTEGER The leading dimension of the array T. LDT &gt;= max(1,N).</p>
<p>Q (input/output) DOUBLE PRECISION array, dimension (LDQ,N) On entry, if COMPQ = 'V', the matrix Q of Schur vectors. On exit, if COMPQ = 'V', Q has been postmultiplied by the orthogonal transformation matrix which reorders T; the leading M columns of Q form an orthonormal basis for the specified invariant subspace. If COMPQ = 'N', Q is not referenced.</p>
<p>LDQ (input) INTEGER The leading dimension of the array Q. LDQ &gt;= 1; and if COMPQ = 'V', LDQ &gt;= N.</p>
<p>WR (output) DOUBLE PRECISION array, dimension (N) WI (output) DOUBLE PRECISION array, dimension (N) The real and imaginary parts, respectively, of the reordered eigenvalues of T. The eigenvalues are stored in the same order as on the diagonal of T, with WR(i) = T(i,i) and, if T(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) &gt; 0 and WI(i+1) = -WI(i). Note that if a complex eigenvalue is sufficiently ill-conditioned, then its value may differ significantly from its value before reordering.</p>
<p>M (output) INTEGER The dimension of the specified invariant subspace. 0 &lt; = M &lt;= N.</p>
<p>S (output) DOUBLE PRECISION If JOB = 'E' or 'B', S is a lower bound on the reciprocal condition number for the selected cluster of eigenvalues. S cannot underestimate the true reciprocal condition number by more than a factor of sqrt(N). If M = 0 or N, S = 1. If JOB = 'N' or 'V', S is not referenced.</p>
<p>SEP (output) DOUBLE PRECISION If JOB = 'V' or 'B', SEP is the estimated reciprocal condition number of the specified invariant subspace. If M = 0 or N, SEP = norm(T). If JOB = 'N' or 'E', SEP is not referenced.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. If JOB = 'N', LWORK &gt;= max(1,N); if JOB = 'E', LWORK &gt;= max(1,M*(N-M)); if JOB = 'V' or 'B', LWORK &gt;= max(1,2*M*(N-M)).</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>IWORK (workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</p>
<p>LIWORK (input) INTEGER The dimension of the array IWORK. If JOB = 'N' or 'E', LIWORK &gt;= 1; if JOB = 'V' or 'B', LIWORK &gt;= max(1,M*(N-M)).</p>
<p>If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the IWORK array, returns this value as the first entry of the IWORK array, and no error message related to LIWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value = 1: reordering of T failed because some eigenvalues are too close to separate (the problem is very ill-conditioned); T may have been partially reordered, and WR and WI contain the eigenvalues in the same order as in T; S and SEP (if requested) are set to zero.</p>
<h1>Further Details</h1>
<p>DTRSEN first collects the selected eigenvalues by computing an orthogonal transformation Z to move them to the top left corner of T. In other words, the selected eigenvalues are the eigenvalues of T11 in: </p>
<pre class="fragment">          Z'*T*Z = ( T11 T12 ) n1
                   (  0  T22 ) n2
                      n1  n2
</pre><p>where N = n1+n2 and Z' means the transpose of Z. The first n1 columns of Z span the specified invariant subspace of T.</p>
<p>If T has been obtained from the real Schur factorization of a matrix A = Q*T*Q', then the reordered real Schur factorization of A is given by A = (Q*Z)*(Z'<em>T*Z)</em>(Q*Z)', and the first n1 columns of Q*Z span the corresponding invariant subspace of A.</p>
<p>The reciprocal condition number of the average of the eigenvalues of T11 may be returned in S. S lies between 0 (very badly conditioned) and 1 (very well conditioned). It is computed as follows. First we compute R so that </p>
<pre class="fragment">                   P = ( I  R ) n1
                       ( 0  0 ) n2
                         n1 n2
</pre><p>is the projector on the invariant subspace associated with T11. R is the solution of the Sylvester equation: </p>
<pre class="fragment">                  T11*R - R*T22 = T12.
</pre><p>Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote the two-norm of M. Then S is computed as the lower bound </p>
<pre class="fragment">                (1 + F-norm(R)**2)**(-1/2)
</pre><p>on the reciprocal of 2-norm(P), the true reciprocal condition number. S cannot underestimate 1 / 2-norm(P) by more than a factor of sqrt(N).</p>
<p>An approximate error bound for the computed average of the eigenvalues of T11 is </p>
<pre class="fragment">                   EPS * norm(T) / S
</pre><p>where EPS is the machine precision.</p>
<p>The reciprocal condition number of the right invariant subspace spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP. SEP is defined as the separation of T11 and T22: </p>
<pre class="fragment">               sep( T11, T22 ) = sigma-min( C )
</pre><p>where sigma-min(C) is the smallest singular value of the n1*n2-by-n1*n2 matrix</p>
<p>C = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )</p>
<p>I(m) is an m by m identity matrix, and kprod denotes the Kronecker product. We estimate sigma-min(C) by the reciprocal of an estimate of the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C) cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).</p>
<p>When SEP is small, small changes in T can cause large changes in the invariant subspace. An approximate bound on the maximum angular error in the computed right invariant subspace is </p>
<pre class="fragment">                EPS * norm(T) / SEP
</pre><p>=====================================================================</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_abf52b26732c3b34af0bdd6359c0645da_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa0225f4475c4669d9cc5fcd37de83df4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DTRSM </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>transa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRSM solves one of the matrix equations</p>
<p>op( A )*X = alpha*B, or X*op( A ) = alpha*B,</p>
<p>where alpha is a scalar, X and B are m by n matrices, A is a unit, or non-unit, upper or lower triangular matrix and op( A ) is one of</p>
<p>op( A ) = A or op( A ) = A'.</p>
<p>The matrix X is overwritten on B.</p>
<h1>Arguments</h1>
<p>SIDE - CHARACTER*1. On entry, SIDE specifies whether op( A ) appears on the left or right of X as follows:</p>
<p>SIDE = 'L' or 'l' op( A )*X = alpha*B.</p>
<p>SIDE = 'R' or 'r' X*op( A ) = alpha*B.</p>
<p>Unchanged on exit.</p>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the matrix A is an upper or lower triangular matrix as follows:</p>
<p>UPLO = 'U' or 'u' A is an upper triangular matrix.</p>
<p>UPLO = 'L' or 'l' A is a lower triangular matrix.</p>
<p>Unchanged on exit.</p>
<p>TRANSA - CHARACTER*1. On entry, TRANSA specifies the form of op( A ) to be used in the matrix multiplication as follows:</p>
<p>TRANSA = 'N' or 'n' op( A ) = A.</p>
<p>TRANSA = 'T' or 't' op( A ) = A'.</p>
<p>TRANSA = 'C' or 'c' op( A ) = A'.</p>
<p>Unchanged on exit.</p>
<p>DIAG - CHARACTER*1. On entry, DIAG specifies whether or not A is unit triangular as follows:</p>
<p>DIAG = 'U' or 'u' A is assumed to be unit triangular.</p>
<p>DIAG = 'N' or 'n' A is not assumed to be unit triangular.</p>
<p>Unchanged on exit.</p>
<p>M - INTEGER. On entry, M specifies the number of rows of B. M must be at least zero. Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the number of columns of B. N must be at least zero. Unchanged on exit.</p>
<p>ALPHA - DOUBLE PRECISION. On entry, ALPHA specifies the scalar alpha. When alpha is zero then A is not referenced and B need not be set before entry. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m when SIDE = 'L' or 'l' and is n when SIDE = 'R' or 'r'. Before entry with UPLO = 'U' or 'u', the leading k by k upper triangular part of the array A must contain the upper triangular matrix and the strictly lower triangular part of A is not referenced. Before entry with UPLO = 'L' or 'l', the leading k by k lower triangular part of the array A must contain the lower triangular matrix and the strictly upper triangular part of A is not referenced. Note that when DIAG = 'U' or 'u', the diagonal elements of A are not referenced either, but are assumed to be unity. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. When SIDE = 'L' or 'l' then LDA must be at least max( 1, m ), when SIDE = 'R' or 'r' then LDA must be at least max( 1, n ). Unchanged on exit.</p>
<p>B - DOUBLE PRECISION array of DIMENSION ( LDB, n ). Before entry, the leading m by n part of the array B must contain the right-hand side matrix B, and on exit is overwritten by the solution matrix X.</p>
<p>LDB - INTEGER. On entry, LDB specifies the first dimension of B as declared in the calling (sub) program. LDB must be at least max( 1, m ). Unchanged on exit.</p>
<p>Level 3 Blas routine.</p>
<p>&ndash; Written on 8-February-1989. Jack Dongarra, Argonne National Laboratory. Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical Algorithms Group Ltd.</p>
<p>.. External Functions .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aa0225f4475c4669d9cc5fcd37de83df4_icgraph.svg" width="304" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aaea4b53f1ad543a69e5a61289ef8418e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTRSNA </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>howmny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRSNA estimates reciprocal condition numbers for specified eigenvalues and/or right eigenvectors of a real upper quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q orthogonal).</p>
<p>T must be in Schur canonical form (as returned by DHSEQR), that is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block has its diagonal elements equal and its off-diagonal elements of opposite sign.</p>
<h1>Arguments</h1>
<p>JOB (input) CHARACTER*1 Specifies whether condition numbers are required for eigenvalues (S) or eigenvectors (SEP): = 'E': for eigenvalues only (S); = 'V': for eigenvectors only (SEP); = 'B': for both eigenvalues and eigenvectors (S and SEP).</p>
<p>HOWMNY (input) CHARACTER*1 = 'A': compute condition numbers for all eigenpairs; = 'S': compute condition numbers for selected eigenpairs specified by the array SELECT.</p>
<p>SELECT (input) LOGICAL array, dimension (N) If HOWMNY = 'S', SELECT specifies the eigenpairs for which condition numbers are required. To select condition numbers for the eigenpair corresponding to a real eigenvalue w(j), SELECT(j) must be set to .TRUE.. To select condition numbers corresponding to a complex conjugate pair of eigenvalues w(j) and w(j+1), either SELECT(j) or SELECT(j+1) or both, must be set to .TRUE.. If HOWMNY = 'A', SELECT is not referenced.</p>
<p>N (input) INTEGER The order of the matrix T. N &gt;= 0.</p>
<p>T (input) DOUBLE PRECISION array, dimension (LDT,N) The upper quasi-triangular matrix T, in Schur canonical form.</p>
<p>LDT (input) INTEGER The leading dimension of the array T. LDT &gt;= max(1,N).</p>
<p>VL (input) DOUBLE PRECISION array, dimension (LDVL,M) If JOB = 'E' or 'B', VL must contain left eigenvectors of T (or of any Q*T*Q**T with Q orthogonal), corresponding to the eigenpairs specified by HOWMNY and SELECT. The eigenvectors must be stored in consecutive columns of VL, as returned by DHSEIN or DTREVC. If JOB = 'V', VL is not referenced.</p>
<p>LDVL (input) INTEGER The leading dimension of the array VL. LDVL &gt;= 1; and if JOB = 'E' or 'B', LDVL &gt;= N.</p>
<p>VR (input) DOUBLE PRECISION array, dimension (LDVR,M) If JOB = 'E' or 'B', VR must contain right eigenvectors of T (or of any Q*T*Q**T with Q orthogonal), corresponding to the eigenpairs specified by HOWMNY and SELECT. The eigenvectors must be stored in consecutive columns of VR, as returned by DHSEIN or DTREVC. If JOB = 'V', VR is not referenced.</p>
<p>LDVR (input) INTEGER The leading dimension of the array VR. LDVR &gt;= 1; and if JOB = 'E' or 'B', LDVR &gt;= N.</p>
<p>S (output) DOUBLE PRECISION array, dimension (MM) If JOB = 'E' or 'B', the reciprocal condition numbers of the selected eigenvalues, stored in consecutive elements of the array. For a complex conjugate pair of eigenvalues two consecutive elements of S are set to the same value. Thus S(j), SEP(j), and the j-th columns of VL and VR all correspond to the same eigenpair (but not in general the j-th eigenpair, unless all eigenpairs are selected). If JOB = 'V', S is not referenced.</p>
<p>SEP (output) DOUBLE PRECISION array, dimension (MM) If JOB = 'V' or 'B', the estimated reciprocal condition numbers of the selected eigenvectors, stored in consecutive elements of the array. For a complex eigenvector two consecutive elements of SEP are set to the same value. If the eigenvalues cannot be reordered to compute SEP(j), SEP(j) is set to 0; this can only occur when the true value would be very small anyway. If JOB = 'E', SEP is not referenced.</p>
<p>MM (input) INTEGER The number of elements in the arrays S (if JOB = 'E' or 'B') and/or SEP (if JOB = 'V' or 'B'). MM &gt;= M.</p>
<p>M (output) INTEGER The number of elements of the arrays S and/or SEP actually used to store the estimated condition numbers. If HOWMNY = 'A', M is set to N.</p>
<p>WORK (workspace) DOUBLE PRECISION array, dimension (LDWORK,N+6) If JOB = 'E', WORK is not referenced.</p>
<p>LDWORK (input) INTEGER The leading dimension of the array WORK. LDWORK &gt;= 1; and if JOB = 'V' or 'B', LDWORK &gt;= N.</p>
<p>IWORK (workspace) INTEGER array, dimension (2*(N-1)) If JOB = 'E', IWORK is not referenced.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>The reciprocal of the condition number of an eigenvalue lambda is defined as </p>
<pre class="fragment">    S(lambda) = |v'*u| / (norm(u)*norm(v))
</pre><p>where u and v are the right and left eigenvectors of T corresponding to lambda; v' denotes the conjugate-transpose of v, and norm(u) denotes the Euclidean norm. These reciprocal condition numbers always lie between zero (very badly conditioned) and one (very well conditioned). If n = 1, S(lambda) is defined to be 1.</p>
<p>An approximate error bound for a computed eigenvalue W(i) is given by </p>
<pre class="fragment">                EPS * norm(T) / S(i)
</pre><p>where EPS is the machine precision.</p>
<p>The reciprocal of the condition number of the right eigenvector u corresponding to lambda is defined as follows. Suppose </p>
<pre class="fragment">        T = ( lambda  c  )
            (   0    T22 )
</pre><p>Then the reciprocal condition number is </p>
<pre class="fragment">    SEP( lambda, T22 ) = sigma-min( T22 - lambda*I )
</pre><p>where sigma-min denotes the smallest singular value. We approximate the smallest singular value by the reciprocal of an estimate of the one-norm of the inverse of T22 - lambda*I. If n = 1, SEP(1) is defined to be abs(T(1,1)).</p>
<p>An approximate error bound for a computed right eigenvector VR(i) is given by </p>
<pre class="fragment">                EPS * norm(T) / SEP(i)
</pre><p>=====================================================================</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aaea4b53f1ad543a69e5a61289ef8418e_icgraph.svg" width="312" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0d133d20ff03aade192008e23ec5c592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DTRSV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRSV solves one of the systems of equations</p>
<p>A*x = b, or A'*x = b,</p>
<p>where b and x are n element vectors and A is an n by n unit, or non-unit, upper or lower triangular matrix.</p>
<p>No test for singularity or near-singularity is included in this routine. Such tests must be performed before calling this routine.</p>
<h1>Arguments</h1>
<p>UPLO - CHARACTER*1. On entry, UPLO specifies whether the matrix is an upper or lower triangular matrix as follows:</p>
<p>UPLO = 'U' or 'u' A is an upper triangular matrix.</p>
<p>UPLO = 'L' or 'l' A is a lower triangular matrix.</p>
<p>Unchanged on exit.</p>
<p>TRANS - CHARACTER*1. On entry, TRANS specifies the equations to be solved as follows:</p>
<p>TRANS = 'N' or 'n' A*x = b.</p>
<p>TRANS = 'T' or 't' A'*x = b.</p>
<p>TRANS = 'C' or 'c' A'*x = b.</p>
<p>Unchanged on exit.</p>
<p>DIAG - CHARACTER*1. On entry, DIAG specifies whether or not A is unit triangular as follows:</p>
<p>DIAG = 'U' or 'u' A is assumed to be unit triangular.</p>
<p>DIAG = 'N' or 'n' A is not assumed to be unit triangular.</p>
<p>Unchanged on exit.</p>
<p>N - INTEGER. On entry, N specifies the order of the matrix A. N must be at least zero. Unchanged on exit.</p>
<p>A - DOUBLE PRECISION array of DIMENSION ( LDA, n ). Before entry with UPLO = 'U' or 'u', the leading n by n upper triangular part of the array A must contain the upper triangular matrix and the strictly lower triangular part of A is not referenced. Before entry with UPLO = 'L' or 'l', the leading n by n lower triangular part of the array A must contain the lower triangular matrix and the strictly upper triangular part of A is not referenced. Note that when DIAG = 'U' or 'u', the diagonal elements of A are not referenced either, but are assumed to be unity. Unchanged on exit.</p>
<p>LDA - INTEGER. On entry, LDA specifies the first dimension of A as declared in the calling (sub) program. LDA must be at least max( 1, n ). Unchanged on exit.</p>
<p>X - DOUBLE PRECISION array of dimension at least ( 1 + ( n - 1 )*abs( INCX ) ). Before entry, the incremented array X must contain the n element right-hand side vector b. On exit, X is overwritten with the solution vector x.</p>
<p>INCX - INTEGER. On entry, INCX specifies the increment for the elements of X. INCX must not be zero. Unchanged on exit.</p>
<p>Level 2 Blas routine.</p>
<p>&ndash; Written on 22-October-1986. Jack Dongarra, Argonne National Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.</p>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a0d133d20ff03aade192008e23ec5c592_icgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae1d6da95b336f6c9d2ddc31d2e2ec84b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTRSYL </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trana</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>tranb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isgn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRSYL solves the real Sylvester matrix equation:</p>
<p>op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C,</p>
<p>where op(A) = A or A**T, and A and B are both upper quasi- triangular. A is M-by-M and B is N-by-N; the right hand side C and the solution X are M-by-N; and scale is an output scale factor, set &lt;= 1 to avoid overflow in X.</p>
<p>A and B must be in Schur canonical form (as returned by DHSEQR), that is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block has its diagonal elements equal and its off-diagonal elements of opposite sign.</p>
<h1>Arguments</h1>
<p>TRANA (input) CHARACTER*1 Specifies the option op(A): = 'N': op(A) = A (No transpose) = 'T': op(A) = A**T (Transpose) = 'C': op(A) = A**H (Conjugate transpose = Transpose)</p>
<p>TRANB (input) CHARACTER*1 Specifies the option op(B): = 'N': op(B) = B (No transpose) = 'T': op(B) = B**T (Transpose) = 'C': op(B) = B**H (Conjugate transpose = Transpose)</p>
<p>ISGN (input) INTEGER Specifies the sign in the equation: = +1: solve op(A)*X + X*op(B) = scale*C = -1: solve op(A)*X - X*op(B) = scale*C</p>
<p>M (input) INTEGER The order of the matrix A, and the number of rows in the matrices X and C. M &gt;= 0.</p>
<p>N (input) INTEGER The order of the matrix B, and the number of columns in the matrices X and C. N &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,M) The upper quasi-triangular matrix A, in Schur canonical form.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>B (input) DOUBLE PRECISION array, dimension (LDB,N) The upper quasi-triangular matrix B, in Schur canonical form.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C (input/output) DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N right hand side matrix C. On exit, C is overwritten by the solution matrix X.</p>
<p>LDC (input) INTEGER The leading dimension of the array C. LDC &gt;= max(1,M)</p>
<p>SCALE (output) DOUBLE PRECISION The scale factor, scale, set &lt;= 1 to avoid overflow in X.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value = 1: A and B have common or very close eigenvalues; perturbed values were used to solve the equation (but the matrices A and B are unchanged). </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_ae1d6da95b336f6c9d2ddc31d2e2ec84b_icgraph.svg" width="307" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a14b67156c545443cecd4cb5dd39624d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTRTRI </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRTRI computes the inverse of a real upper or lower triangular matrix A.</p>
<p>This is the Level 3 BLAS version of the algorithm.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the triangular matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If DIAG = 'U', the diagonal elements of A are also not referenced and are assumed to be 1. On exit, the (triangular) inverse of the original matrix, in the same storage format.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, A(i,i) is exactly zero. The triangular matrix is singular and its inverse can not be computed. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a14b67156c545443cecd4cb5dd39624d4_icgraph.svg" width="302" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a72d8f23a9ecda29501fe484f920bd56d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTRTRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTRTRS solves a triangular system of the form</p>
<p>A * X = B or A**T * X = B,</p>
<p>where A is a triangular matrix of order N, and B is an N-by-NRHS matrix. A check is made to verify that A is nonsingular.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': A is upper triangular; = 'L': A is lower triangular.</p>
<p>TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A * X = B (No transpose) = 'T': A**T * X = B (Transpose) = 'C': A**H * X = B (Conjugate transpose = Transpose)</p>
<p>DIAG (input) CHARACTER*1 = 'N': A is non-unit triangular; = 'U': A is unit triangular.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The triangular matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If DIAG = 'U', the diagonal elements of A are also not referenced and are assumed to be 1.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, if INFO = 0, the solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the i-th diagonal element of A is zero, indicating that the matrix is singular and the solutions X have not been computed. </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a72d8f23a9ecda29501fe484f920bd56d_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a852a98b9e94d27a132dbfa1f5275504f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTZRQF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>This routine is deprecated and has been replaced by routine DTZRZF.</p>
<p>DTZRQF reduces the M-by-N ( M&lt;=N ) real upper trapezoidal matrix A to upper triangular form by means of orthogonal transformations.</p>
<p>The upper trapezoidal matrix A is factored as</p>
<p>A = ( R 0 ) * Z,</p>
<p>where Z is an N-by-N orthogonal matrix and R is an M-by-M upper triangular matrix.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= M.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the leading M-by-N upper trapezoidal part of the array A must contain the matrix to be factorized. On exit, the leading M-by-M upper triangular part of A contains the upper triangular matrix R, and elements M+1 to N of the first M rows of A, with the array TAU, represent the orthogonal matrix Z as a product of M elementary reflectors.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (M) The scalar factors of the elementary reflectors.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>The factorization is obtained by Householder's method. The kth transformation matrix, Z( k ), which is used to introduce zeros into the ( m - k + 1 )th row of A, is given in the form</p>
<p>Z( k ) = ( I 0 ), ( 0 T( k ) )</p>
<p>where</p>
<p>T( k ) = I - tau*u( k )*u( k )', u( k ) = ( 1 ), ( 0 ) ( z( k ) )</p>
<p>tau is a scalar and z( k ) is an ( n - m ) element vector. tau and z( k ) are chosen to annihilate the elements of the kth row of X.</p>
<p>The scalar tau is returned in the kth element of TAU and the vector u( k ) in the kth row of A, such that the elements of z( k ) are in a( k, m + 1 ), ..., a( k, n ). The elements of R are returned in the upper triangular part of A.</p>
<p>Z is given by</p>
<p>Z = Z( 1 ) * Z( 2 ) * ... * Z( m ). </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a852a98b9e94d27a132dbfa1f5275504f_icgraph.svg" width="310" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a36df44bdb427860560878e9640ed075f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DTZRZF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DTZRZF reduces the M-by-N ( M&lt;=N ) real upper trapezoidal matrix A to upper triangular form by means of orthogonal transformations.</p>
<p>The upper trapezoidal matrix A is factored as</p>
<p>A = ( R 0 ) * Z,</p>
<p>where Z is an N-by-N orthogonal matrix and R is an M-by-M upper triangular matrix.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= M.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the leading M-by-N upper trapezoidal part of the array A must contain the matrix to be factorized. On exit, the leading M-by-M upper triangular part of A contains the upper triangular matrix R, and elements M+1 to N of the first M rows of A, with the array TAU, represent the orthogonal matrix Z as a product of M elementary reflectors.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>TAU (output) DOUBLE PRECISION array, dimension (M) The scalar factors of the elementary reflectors.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= M*NB, where NB is the optimal blocksize.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value</p>
<h1>Further Details</h1>
<p>Based on contributions by A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA</p>
<p>The factorization is obtained by Householder's method. The kth transformation matrix, Z( k ), which is used to introduce zeros into the ( m - k + 1 )th row of A, is given in the form</p>
<p>Z( k ) = ( I 0 ), ( 0 T( k ) )</p>
<p>where</p>
<p>T( k ) = I - tau*u( k )*u( k )', u( k ) = ( 1 ), ( 0 ) ( z( k ) )</p>
<p>tau is a scalar and z( k ) is an ( n - m ) element vector. tau and z( k ) are chosen to annihilate the elements of the kth row of X.</p>
<p>The scalar tau is returned in the kth element of TAU and the vector u( k ) in the kth row of A, such that the elements of z( k ) are in a( k, m + 1 ), ..., a( k, n ). The elements of R are returned in the upper triangular part of A.</p>
<p>Z is given by</p>
<p>Z = Z( 1 ) * Z( 2 ) * ... * Z( m ). </p>
<hr/>
<p>.. Parameters .. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a36df44bdb427860560878e9640ed075f_icgraph.svg" width="304" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4c90070bfb99a22978e02642d093bdab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ** psi::compute_atom_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; Molecule &gt; &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes atom mappings during symmetry operations. Useful in generating <a class="el" href="structpsi_1_1SO.html">SO</a> information and Cartesian displacement SALCs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td><a class="el" href="classpsi_1_1Molecule.html" title="Molecule information class.">Molecule</a> to form mapping matrix from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer matrix of dimension natoms X nirreps. </dd></dl>

</div>
</div>
<a class="anchor" id="a61c7337031dbbfa63d72a81b93c80b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::delete_atom_map </td>
          <td>(</td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>atom_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; Molecule &gt; &amp;&#160;</td>
          <td class="paramname"><em>mol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees atom mapping for created for a molecule by compute_atom_map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_map</td><td>Map to free. </td></tr>
    <tr><td class="paramname">mol</td><td><a class="el" href="classpsi_1_1Molecule.html" title="Molecule information class.">Molecule</a> used to create atom_map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5277cf32f1d0defe02dde86b5dd36afd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int psi::edit_distance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Levenshtein distance between two strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td></td></tr>
    <tr><td class="paramname">s2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance as an unsigned integer </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a5277cf32f1d0defe02dde86b5dd36afd_icgraph.svg" width="307" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a606ca1816a4c81be0b012a273d2b645b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::generate_combinations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>combinations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate combinations of 0,1,...,(n-1) taken k at a time </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">k</td><td></td></tr>
    <tr><td class="paramname">combinations</td><td>a vector&lt;vector&lt;int&gt; &gt; that will store all the combinations </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a606ca1816a4c81be0b012a273d2b645b_cgraph.svg" width="507" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="add566862dea77a013c26ba269a9b9f6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::iwl_buf_rd_arr2 </td>
          <td>(</td>
          <td class="paramtype">struct iwlbuf *&#160;</td>
          <td class="paramname"><em>Buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>qlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ioff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>printflg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespacepsi.html#add566862dea77a013c26ba269a9b9f6d">iwl_buf_rd_arr2()</a></p>
<p>Read from an Integrals With Labels formatted PSI buffer. The buffer must have been initialized with <a class="el" href="group__IWL.html#gaf17e4eee1412d1540e2c3091fd526658">iwl_buf_init()</a>. The integrals and their labels are returned in the arrays ints, plist, qlist, rlist, and slist, and the size of these arrays is returned in 'size.'</p>
<p>Returns: 0 if end of file, otherwise 1</p>
<p>Revised 6/27/96 by CDS for new format </p>
<p>end loop through current buffer</p>
<p>read new buffers</p>
<p>end loop through current buffer</p>
<p>end loop over reading buffers</p>
<p>we must have reached the last buffer at this point </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_add566862dea77a013c26ba269a9b9f6d_cgraph.svg" width="472" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a351ad90d7b017659728bc4e7f1a5e242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::plugin_close </td>
          <td>(</td>
          <td class="paramtype">const plugin_info &amp;&#160;</td>
          <td class="paramname"><em>plugin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the plugin from memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plugin</td><td>A plugin_info struct that contains the plugin to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1171b74448d1f0cd7ac743ef20cf5685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpsi_1_1plugin__info__struct.html">plugin_info</a> psi::plugin_load </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>fullpathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a plugin from disk and calls its initialization routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plugin_path</td><td>Absolute or relative path and filename name to the plugin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A plugin_info structure containing function pointers to entry points in the plugin. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a1171b74448d1f0cd7ac743ef20cf5685_cgraph.svg" width="123" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a1171b74448d1f0cd7ac743ef20cf5685_icgraph.svg" width="123" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9cbfba5ae305624db512f9fe2a3e58a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::print_usage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print command-line usage information. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a9cbfba5ae305624db512f9fe2a3e58a0_icgraph.svg" width="272" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="af0d4683ce326e4e77eba2ef4892b2683"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::print_version </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>myout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print PSI version information that was set in configure.ac </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_af0d4683ce326e4e77eba2ef4892b2683_icgraph.svg" width="280" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a645227094af54ecf858eba192f85144a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::PSI_DBDSDC </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>irrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>compq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; Vector &gt;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; Vector &gt;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SharedMatrix&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SharedMatrix&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; Vector &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; IntVector &gt;&#160;</td>
          <td class="paramname"><em>iq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; Vector &gt;&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1shared__ptr.html">boost::shared_ptr</a>&lt; IntVector &gt;&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LAPACK PSI_DBDSDC, a wrapper to return C_DBDSDC using objects </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a645227094af54ecf858eba192f85144a_cgraph.svg" width="318" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a645227094af54ecf858eba192f85144a_icgraph.svg" width="147" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aae1243531ac7460a7b69504789f99bf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::psiclean </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespacepsi.html#aae1243531ac7460a7b69504789f99bf3">psiclean()</a>:</p>
<p>Remove all psio files in the event of a crash. Uses the "psi.clean" file </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_aae1243531ac7460a7b69504789f99bf3_cgraph.svg" width="331" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac6896b86eeac552e4c28f6dac7732d19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::read_options </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suppress_printing</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is called immediately before a module is run. Any options expected by that module must be added here</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>- the name of the module. </td></tr>
    <tr><td class="paramname">options</td><td>- the liboptions module used in the computations. </td></tr>
    <tr><td class="paramname">suppress_printing</td><td>- boolean to specify whether to print to output file [false] </td></tr>
  </table>
  </dd>
</dl>
<p>*- For experimental use only. Selects the iterative diagonalization</p>
<p>*- Selects the excited state the EOMEE properties are calculated</p>
<p>*- Maximum subspace dimension for linear equation solutions. -*/</p>
<p>*- Specifies the spin of the electrons modified by the QRHF_GENERAL</p>
<p>*- Perturbative treatment of spin-orbit splittings in dublett-pi</p>
<p>*- Is a somewhat complicated keyword to use. Allowed values are 0,</p>
<p>*- For experimental use only. Selects the iterative diagonalization</p>
<p>*- Selects the excited state the EOMEE properties are calculated</p>
<p>*- Maximum subspace dimension for linear equation solutions. -*/</p>
<p>*- Specifies the spin of the electrons modified by the QRHF_GENERAL</p>
<p>*- Perturbative treatment of spin-orbit splittings in dublett-pi</p>
<p>*- Is a somewhat complicated keyword to use. Allowed values are 0, </p>

</div>
</div>
<a class="anchor" id="a2c62ee3e6ebd249518cb533e988b9d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::str_to_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interprets a string as an double, throwing if it's unsuccesful. </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a2c62ee3e6ebd249518cb533e988b9d9c_cgraph.svg" width="136" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a2c62ee3e6ebd249518cb533e988b9d9c_icgraph.svg" width="339" height="219"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a89fe6317a550161d8b053d2d1686c02c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::str_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interprets a string as an integer, throwing if it's unsuccesful. </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a89fe6317a550161d8b053d2d1686c02c_cgraph.svg" width="112" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacepsi_a89fe6317a550161d8b053d2d1686c02c_icgraph.svg" width="315" height="219"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5f3a891c486a6de00fdb7e85ce849e96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * psi::strncpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="namespacepsi.html#a5f3a891c486a6de00fdb7e85ce849e96" title="Same as strncpy(), but make sure that dest ends in \0.">strncpy()</a>, but make sure that dest ends in \0. </p>
<p><a class="el" href="namespacepsi.html#a5f3a891c486a6de00fdb7e85ce849e96" title="Same as strncpy(), but make sure that dest ends in \0.">strncpy()</a>: Override default strncpy to ensure last byte is a string terminating character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>= destination string </td></tr>
    <tr><td class="paramname">source</td><td>= source string </td></tr>
    <tr><td class="paramname">n</td><td>= number of characters to copy</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: pointer to destination string </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacepsi_a5f3a891c486a6de00fdb7e85ce849e96_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7cbf84374d9759eaa86f809a20f0cee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::to_MB </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the size of a doubles array in Mb using the definition 1Mb = 1048576 bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="add629624c145fff88641b7b7b3bc9382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXT bool psi::check_only</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sanity check boolean </p>

</div>
</div>
<a class="anchor" id="a00a558f999450c5be8cf9cda2f4c6751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXT bool psi::clean_only</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>clean-up </p>

</div>
</div>
<a class="anchor" id="a72c093cae362342b3d80520c5b94fb4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string psi::FullPointGroupList[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;ATOM&quot;</span>, <span class="stringliteral">&quot;C_inf_v&quot;</span>, <span class="stringliteral">&quot;D_inf_h&quot;</span>, <span class="stringliteral">&quot;C1&quot;</span>, <span class="stringliteral">&quot;Cs&quot;</span>, <span class="stringliteral">&quot;Ci&quot;</span>, <span class="stringliteral">&quot;Cn&quot;</span>, <span class="stringliteral">&quot;Cnv&quot;</span>,</div>
<div class="line"> <span class="stringliteral">&quot;Cnh&quot;</span>, <span class="stringliteral">&quot;Sn&quot;</span>, <span class="stringliteral">&quot;Dn&quot;</span>, <span class="stringliteral">&quot;Dnd&quot;</span>, <span class="stringliteral">&quot;Dnh&quot;</span>, <span class="stringliteral">&quot;Td&quot;</span>, <span class="stringliteral">&quot;Oh&quot;</span>, <span class="stringliteral">&quot;Ih&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa327f1f5df8505d1e6e7a69bfe4c344c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXT std::string psi::infile_directory</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Directory location of the input file </p>

</div>
</div>
<a class="anchor" id="a614891df433e7f7d5cae8d3c84aadc42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXT bool psi::interactive_python</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interactive python session? </p>

</div>
</div>
<a class="anchor" id="a9f653ae7eee5a58671c9fb98acfde5d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* psi::labels[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot; E &quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;C2z&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;C2y&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;C2x&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot; i &quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Sxy&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Sxz&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Syz&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot; E &quot;</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac3c399241015be2f4d81d6cc06531ac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXT bool psi::messy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave psi temp file </p>

</div>
</div>
<a class="anchor" id="a8c94efed12faf73b3441abb7634a11f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpsi_1_1psio__address.html">psio_address</a> psi::PSIO_ZERO = { 0, 0 }</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenient address initialization struct </p>

</div>
</div>
<a class="anchor" id="adc8de8a28e0686b5933f00d847a83cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string psi::RotorTypeList[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;ASYMMETRIC_TOP&quot;</span>, <span class="stringliteral">&quot;SYMMETRIC_TOP&quot;</span>,</div>
<div class="line"> <span class="stringliteral">&quot;SPHERICAL_TOP&quot;</span>, <span class="stringliteral">&quot;LINEAR&quot;</span>, <span class="stringliteral">&quot;ATOM&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aefe0a6e64f9005f6c2f6f4f195bec003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXT bool psi::skip_input_preprocess</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>skip preprocessing the input file </p>

</div>
</div>
<a class="anchor" id="a8eeb423fdd687175fee5149ee448f27b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool psi::verbose</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verbosity </p>

</div>
</div>
<a class="anchor" id="ace7fd068af33dcf37525eb3cb195ab59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string psi::Z_to_element[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line"></div>
<div class="line"><span class="stringliteral">&quot;GHOST&quot;</span>, <span class="stringliteral">&quot;HYDROGEN&quot;</span>, <span class="stringliteral">&quot;HELIUM&quot;</span>,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="stringliteral">&quot;LITHIUM&quot;</span>, <span class="stringliteral">&quot;BERYLLIUM&quot;</span>, <span class="stringliteral">&quot;BORON&quot;</span>, <span class="stringliteral">&quot;CARBON&quot;</span>, <span class="stringliteral">&quot;NITROGEN&quot;</span>, <span class="stringliteral">&quot;OXYGEN&quot;</span>, <span class="stringliteral">&quot;FLUORINE&quot;</span>, <span class="stringliteral">&quot;NEON&quot;</span>,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="stringliteral">&quot;SODIUM&quot;</span>, <span class="stringliteral">&quot;MAGNESIUM&quot;</span>, <span class="stringliteral">&quot;ALUMINUM&quot;</span>, <span class="stringliteral">&quot;SILICON&quot;</span>, <span class="stringliteral">&quot;PHOSPHORUS&quot;</span>, <span class="stringliteral">&quot;SULFUR&quot;</span>, <span class="stringliteral">&quot;CHLORINE&quot;</span>, <span class="stringliteral">&quot;ARGON&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;POTASSIUM&quot;</span>, <span class="stringliteral">&quot;CALCIUM&quot;</span>, <span class="stringliteral">&quot;SCANDIUM&quot;</span>, <span class="stringliteral">&quot;TITANIUM&quot;</span>, <span class="stringliteral">&quot;VANADIUM&quot;</span>, <span class="stringliteral">&quot;CHROMIUM&quot;</span>, <span class="stringliteral">&quot;MANGANESE&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;IRON&quot;</span>, <span class="stringliteral">&quot;COBALT&quot;</span>, <span class="stringliteral">&quot;NICKEL&quot;</span>, <span class="stringliteral">&quot;COPPER&quot;</span>, <span class="stringliteral">&quot;ZINC&quot;</span>, <span class="stringliteral">&quot;GALLIUM&quot;</span>, <span class="stringliteral">&quot;GERMANIUM&quot;</span>, <span class="stringliteral">&quot;ARSENIC&quot;</span>, <span class="stringliteral">&quot;SELENIUM&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;BROMINE&quot;</span>, <span class="stringliteral">&quot;KRYPTON&quot;</span>,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="stringliteral">&quot;RUBIDIUM&quot;</span>, <span class="stringliteral">&quot;STRONTIUM&quot;</span>, <span class="stringliteral">&quot;YTTRIUM&quot;</span>, <span class="stringliteral">&quot;ZIRCONIUM&quot;</span>, <span class="stringliteral">&quot;NIOBIUM&quot;</span>, <span class="stringliteral">&quot;MOLYBDENUM&quot;</span>, <span class="stringliteral">&quot;TECHNETIUM&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;RUTHENIUM&quot;</span>, <span class="stringliteral">&quot;RHODIUM&quot;</span>, <span class="stringliteral">&quot;PALLADIUM&quot;</span>, <span class="stringliteral">&quot;SILVER&quot;</span>, <span class="stringliteral">&quot;CADMIUM&quot;</span>, <span class="stringliteral">&quot;INDIUM&quot;</span>, <span class="stringliteral">&quot;TIN&quot;</span>, <span class="stringliteral">&quot;ANTIMONY&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;TELLURIUM&quot;</span>, <span class="stringliteral">&quot;IODINE&quot;</span>, <span class="stringliteral">&quot;XENON&quot;</span>,</div>
<div class="line"></div>
<div class="line"><span class="stringliteral">&quot;CESIUM&quot;</span>, <span class="stringliteral">&quot;BARIUM&quot;</span>, <span class="stringliteral">&quot;LANTHANUM&quot;</span>, <span class="stringliteral">&quot;CERIUM&quot;</span>, <span class="stringliteral">&quot;PRASEODYMIUM&quot;</span>, <span class="stringliteral">&quot;NEODYMIUM&quot;</span>, <span class="stringliteral">&quot;PROMETHIUM&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;SAMARIUM&quot;</span>, <span class="stringliteral">&quot;EUROPIUM&quot;</span>, <span class="stringliteral">&quot;GADOLINIUM&quot;</span>, <span class="stringliteral">&quot;TERBIUM&quot;</span>, <span class="stringliteral">&quot;DYSPROSIUM&quot;</span>, <span class="stringliteral">&quot;HOLMIUM&quot;</span>, <span class="stringliteral">&quot;ERBIUM&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;THULIUM&quot;</span>, <span class="stringliteral">&quot;YTTERBIUM&quot;</span>, <span class="stringliteral">&quot;LUTETIUM&quot;</span>, <span class="stringliteral">&quot;HAFNIUM&quot;</span>, <span class="stringliteral">&quot;TANTALUM&quot;</span>, <span class="stringliteral">&quot;TUNGSTEN&quot;</span>, <span class="stringliteral">&quot;RHENIUM&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;OSMIUM&quot;</span>, <span class="stringliteral">&quot;IRIDIUM&quot;</span>, <span class="stringliteral">&quot;PLATINUM&quot;</span>, <span class="stringliteral">&quot;GOLD&quot;</span>, <span class="stringliteral">&quot;MERCURY&quot;</span>, <span class="stringliteral">&quot;THALLIUM&quot;</span>, <span class="stringliteral">&quot;LEAD&quot;</span>, <span class="stringliteral">&quot;BISMUTH&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;POLONIUM&quot;</span>, <span class="stringliteral">&quot;ASTATINE&quot;</span>, <span class="stringliteral">&quot;RADON&quot;</span>,</div>
<div class="line"></div>
<div class="line"><span class="stringliteral">&quot;FRANCIUM&quot;</span>, <span class="stringliteral">&quot;RADIUM&quot;</span>, <span class="stringliteral">&quot;ACTINIUM&quot;</span>, <span class="stringliteral">&quot;THORIUM&quot;</span>, <span class="stringliteral">&quot;PROTACTINIUM&quot;</span>, <span class="stringliteral">&quot;URANIUM&quot;</span>, <span class="stringliteral">&quot;NEPTUNIUM&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;PLUTONIUM&quot;</span>, <span class="stringliteral">&quot;AMERICIUM&quot;</span>, <span class="stringliteral">&quot;CURIUM&quot;</span>, <span class="stringliteral">&quot;BERKELIUM&quot;</span>, <span class="stringliteral">&quot;CALIFORNIUM&quot;</span>, <span class="stringliteral">&quot;EINSTEINIUM&quot;</span>, <span class="stringliteral">&quot;FERMIUM&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;MENDELEVIUM&quot;</span>, <span class="stringliteral">&quot;NOBELIUM&quot;</span>, <span class="stringliteral">&quot;LAWRENCIUM&quot;</span>, <span class="stringliteral">&quot;UNQ&quot;</span>, <span class="stringliteral">&quot;UNP&quot;</span>, <span class="stringliteral">&quot;UNH&quot;</span>, <span class="stringliteral">&quot;UNS&quot;</span>,</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
