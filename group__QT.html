<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>PSI: libqt: The Quantum-Trio Miscellaneous Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PSI
   &#160;<span id="projectnumber">4.0.0-beta5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">libqt: The Quantum-Trio Miscellaneous Library</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:3d__array_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="3d__array_8cc.html">3d_array.cc</a></td></tr>
<tr class="memdesc:3d__array_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines for 3d arrays. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:blas__intfc_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blas__intfc_8cc.html">blas_intfc.cc</a></td></tr>
<tr class="memdesc:blas__intfc_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The PSI3 BLAS1 interface routines. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:blas__intfc23_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blas__intfc23_8cc.html">blas_intfc23.cc</a></td></tr>
<tr class="memdesc:blas__intfc23_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to all BLAS routinesAutogenerated by Rob Parrish on 1/24/2011. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cc__excited_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cc__excited_8cc.html">cc_excited.cc</a></td></tr>
<tr class="memdesc:cc__excited_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a wavefunction is a CC-excited wavefunction type. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cc__wfn_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cc__wfn_8cc.html">cc_wfn.cc</a></td></tr>
<tr class="memdesc:cc__wfn_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if wavefunction is coupled-cluster type. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ci__wfn_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ci__wfn_8cc.html">ci_wfn.cc</a></td></tr>
<tr class="memdesc:ci__wfn_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if wavefunction is CI-type. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:david_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="david_8cc.html">david.cc</a></td></tr>
<tr class="memdesc:david_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-core Davidson-Liu diagonalization of symm matrices. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dirprd__block_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirprd__block_8cc.html">dirprd_block.cc</a></td></tr>
<tr class="memdesc:dirprd__block_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a direct product of two matrices. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dot__block_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dot__block_8cc.html">dot_block.cc</a></td></tr>
<tr class="memdesc:dot__block_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take dot product of two block matrices. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:fill__sym__matrix_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fill__sym__matrix_8cc.html">fill_sym_matrix.cc</a></td></tr>
<tr class="memdesc:fill__sym__matrix_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a symmetric matrix from a lower triangle. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:filter_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8cc.html">filter.cc</a></td></tr>
<tr class="memdesc:filter_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out unneeded frozen core/virt integrals. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:invert_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="invert_8cc.html">invert.cc</a></td></tr>
<tr class="memdesc:invert_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a small matrix. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lapack__intfc_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__intfc_8cc.html">lapack_intfc.cc</a></td></tr>
<tr class="memdesc:lapack__intfc_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to all LAPACK routinesAutogenerated by Rob Parrish on 1/23/2011. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lapack__intfc_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__intfc_8h.html">lapack_intfc.h</a></td></tr>
<tr class="memdesc:lapack__intfc_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to LAPACK routinesRollin A. King and T. Daniel Crawford August 2001 - January 2002. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mat__in_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mat__in_8cc.html">mat_in.cc</a></td></tr>
<tr class="memdesc:mat__in_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">read in a matrix from an input stream (deprecated) <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mat__print_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mat__print_8cc.html">mat_print.cc</a></td></tr>
<tr class="memdesc:mat__print_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a matrix to a file in a formatted style. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:newmm__rking_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="newmm__rking_8cc.html">newmm_rking.cc</a></td></tr>
<tr class="memdesc:newmm__rking_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication routine (deprecated) <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:normalize_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="normalize_8cc.html">normalize.cc</a></td></tr>
<tr class="memdesc:normalize_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a set of vectors. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:orient__fragment_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="orient__fragment_8cc.html">orient_fragment.cc</a></td></tr>
<tr class="memdesc:orient__fragment_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">function which places one fragment into the coordinate system of another <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pople_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pople_8cc.html">pople.cc</a></td></tr>
<tr class="memdesc:pople_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pople's method for solving linear equations. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:probabil_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="probabil_8cc.html">probabil.cc</a></td></tr>
<tr class="memdesc:probabil_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains some probability functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qt_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qt_8h.html">qt.h</a></td></tr>
<tr class="memdesc:qt_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header file for the Quantum Trio LibraryDavid Sherrill 1994. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ras__set_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ras__set_8cc.html">ras_set.cc</a></td></tr>
<tr class="memdesc:ras__set_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain orbital space and reordering for CI/MCSCF wavefunctions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:reorder__qt_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reorder__qt_8cc.html">reorder_qt.cc</a></td></tr>
<tr class="memdesc:reorder__qt_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the QT orbital reordering array between Pitzer and correlated order. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rootfind_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rootfind_8cc.html">rootfind.cc</a></td></tr>
<tr class="memdesc:rootfind_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple root finding methods<pre class="fragment"> (1) Bisection method
 (2) Newton's method
 (3) Secant method</pre><p>. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:schmidt_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="schmidt_8cc.html">schmidt.cc</a></td></tr>
<tr class="memdesc:schmidt_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalize a set of vectors. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lib_2libqt_2schmidt__add_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2libqt_2schmidt__add_8cc.html">lib/libqt/schmidt_add.cc</a></td></tr>
<tr class="memdesc:lib_2libqt_2schmidt__add_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalize vector and add to set. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:slaterdset_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slaterdset_8cc.html">slaterdset.cc</a></td></tr>
<tr class="memdesc:slaterdset_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions for importing/exporting sets of Slater determinants from the CI codesEdward Valeev, June 2002. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:slaterdset_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slaterdset_8h.html">slaterdset.h</a></td></tr>
<tr class="memdesc:slaterdset_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header file for SlaterDetSetsEdward Valeev, June 2002. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:solve__pep_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="solve__pep_8cc.html">solve_pep.cc</a></td></tr>
<tr class="memdesc:solve__pep_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a 2x2 pseudo-eigenvalue problem. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lib_2libqt_2sort_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2libqt_2sort_8cc.html">lib/libqt/sort.cc</a></td></tr>
<tr class="memdesc:lib_2libqt_2sort_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort eigenvalues and eigenvectors into ascending order. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:strncpy_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="strncpy_8cc.html">strncpy.cc</a></td></tr>
<tr class="memdesc:strncpy_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override strncpy to ensure strings are terminatedBy Edward Valeev. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:libqt_2timer_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libqt_2timer_8cc.html">libqt/timer.cc</a></td></tr>
<tr class="memdesc:libqt_2timer_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain user and system timings for blocks of codeTIMER.CC: These functions allow one to obtain user and system timings for arbitrary blocks of code. If a code block is called repeatedly during the course of program execution, the timer functions will report the block's cumulative execution time and the number of calls. In addition, one may time multiple code blocks simultaneously, and even ``overlap'' timers. Timing data is written to the file "timer.dat" at the end of timer execution, i.e., when <a class="el" href="group__QT.html#ga3c3713e536790b780749da4f5279e436">timer_done()</a> is called. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:v__3_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="v__3_8cc.html">v_3.cc</a></td></tr>
<tr class="memdesc:v__3_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple functions for 3-vectors <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zmat__point_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zmat__point_8cc.html">zmat_point.cc</a></td></tr>
<tr class="memdesc:zmat__point_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">xyz coordinates for three points and R, theta, and phi, returns the coordinates a fourth point; angles should enter function in degrees <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepsi"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepsi.html">psi</a></td></tr>
<tr class="memdesc:namespacepsi"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a set of vectors around an arbitrary axis Vectors are rows of input matrix. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga59a60b96011b32445e146d038e437c78"><td class="memItemLeft" align="right" valign="top">double ***&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga59a60b96011b32445e146d038e437c78">psi::init_3d_array</a> (int p, int q, int r)</td></tr>
<tr class="separator:ga59a60b96011b32445e146d038e437c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8cf84ee88f3deeb68a4aa21b2b967d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga7f8cf84ee88f3deeb68a4aa21b2b967d">psi::free_3d_array</a> (double ***A, int p, int q)</td></tr>
<tr class="separator:ga7f8cf84ee88f3deeb68a4aa21b2b967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ba35d35184dab8f9ad1eac331e4747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga33ba35d35184dab8f9ad1eac331e4747">psi::C_DSWAP</a> (unsigned long int length, double *x, int inc_x, double *y, int inc_y)</td></tr>
<tr class="separator:ga33ba35d35184dab8f9ad1eac331e4747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef01298916a61134e83eeb4c9649a0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gafef01298916a61134e83eeb4c9649a0d">psi::C_DAXPY</a> (unsigned long int length, double a, double *x, int inc_x, double *y, int inc_y)</td></tr>
<tr class="separator:gafef01298916a61134e83eeb4c9649a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada1f89a2db3689c3e7482ea755b49b27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gada1f89a2db3689c3e7482ea755b49b27">psi::C_DCOPY</a> (unsigned long int length, double *x, int inc_x, double *y, int inc_y)</td></tr>
<tr class="separator:gada1f89a2db3689c3e7482ea755b49b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed877a653f8542c11a21987ae0f1e160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaed877a653f8542c11a21987ae0f1e160">psi::C_DSCAL</a> (unsigned long int length, double alpha, double *vec, int inc)</td></tr>
<tr class="separator:gaed877a653f8542c11a21987ae0f1e160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb95a4ea160026291b1850b3571d5ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gafbb95a4ea160026291b1850b3571d5ed">psi::C_DROT</a> (unsigned long int length, double *x, int inc_x, double *y, int inc_y, double costheta, double sintheta)</td></tr>
<tr class="separator:gafbb95a4ea160026291b1850b3571d5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff0d5067135afa4228460272b6b4781"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gafff0d5067135afa4228460272b6b4781">psi::C_DDOT</a> (unsigned long int length, double *x, int inc_x, double *y, int inc_y)</td></tr>
<tr class="separator:gafff0d5067135afa4228460272b6b4781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1644e8ee3f7b6bb32137457a7dde7aa2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga1644e8ee3f7b6bb32137457a7dde7aa2">psi::C_DNRM2</a> (unsigned long int length, double *x, int inc_x)</td></tr>
<tr class="separator:ga1644e8ee3f7b6bb32137457a7dde7aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b975bb8c1f54920f23214df365d3021"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga4b975bb8c1f54920f23214df365d3021">psi::C_DASUM</a> (unsigned long int length, double *x, int inc_x)</td></tr>
<tr class="separator:ga4b975bb8c1f54920f23214df365d3021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d473748326ef68bd4af5fd4e9ff5e44"><td class="memItemLeft" align="right" valign="top">unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga3d473748326ef68bd4af5fd4e9ff5e44">psi::C_IDAMAX</a> (unsigned long int length, double *x, int inc_x)</td></tr>
<tr class="separator:ga3d473748326ef68bd4af5fd4e9ff5e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7dba6467743ab41c4e2efbb9bba5595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gac7dba6467743ab41c4e2efbb9bba5595">psi::cc_excited</a> (const char *wfn)</td></tr>
<tr class="separator:gac7dba6467743ab41c4e2efbb9bba5595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ed72ce0e58f61793f21acb5fe0c244"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad3ed72ce0e58f61793f21acb5fe0c244">psi::cc_excited</a> (std::string wfn)</td></tr>
<tr class="separator:gad3ed72ce0e58f61793f21acb5fe0c244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4348565874a4f55aa86efe4ef336cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad4348565874a4f55aa86efe4ef336cde">psi::cc_wfn</a> (const char *wfn)</td></tr>
<tr class="separator:gad4348565874a4f55aa86efe4ef336cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9287456500de60c9fa5b733b633340b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga9287456500de60c9fa5b733b633340b3">psi::cc_wfn</a> (std::string wfn)</td></tr>
<tr class="separator:ga9287456500de60c9fa5b733b633340b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5897677944b94d2ec0555dd9cdd0a8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaa5897677944b94d2ec0555dd9cdd0a8e">psi::ci_wfn</a> (char *wfn)</td></tr>
<tr class="separator:gaa5897677944b94d2ec0555dd9cdd0a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa457150c780cf1438b4b7f859e3205cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaa457150c780cf1438b4b7f859e3205cd">psi::ci_wfn</a> (std::string wfn)</td></tr>
<tr class="separator:gaa457150c780cf1438b4b7f859e3205cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c6345ae60fb29588e8d1064f8f53d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaf4c6345ae60fb29588e8d1064f8f53d1">psi::david</a> (double **A, int N, int M, double *eps, double **v, double cutoff, int print)</td></tr>
<tr class="separator:gaf4c6345ae60fb29588e8d1064f8f53d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67e10fae2a18289df311c94705919d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaf67e10fae2a18289df311c94705919d8">psi::dirprd_block</a> (double **A, double **B, int rows, int cols)</td></tr>
<tr class="separator:gaf67e10fae2a18289df311c94705919d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc510b7f8d584d53d58a2d7a92e71c4d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gabc510b7f8d584d53d58a2d7a92e71c4d">psi::dot_block</a> (double **A, double **B, int rows, int cols, double alpha)</td></tr>
<tr class="separator:gabc510b7f8d584d53d58a2d7a92e71c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcbafb11f8276be426b80299e25ff45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaedcbafb11f8276be426b80299e25ff45">psi::fill_sym_matrix</a> (double **A, int size)</td></tr>
<tr class="separator:gaedcbafb11f8276be426b80299e25ff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad18063cef37be3eef59d317e7a26e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga6ad18063cef37be3eef59d317e7a26e4">psi::filter</a> (double *input, double *output, int *ioff, int norbs, int nfzc, int nfzv)</td></tr>
<tr class="separator:ga6ad18063cef37be3eef59d317e7a26e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa00bb931504d4953c047ee58e7ba317"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaaa00bb931504d4953c047ee58e7ba317">psi::invert_matrix</a> (double **a, double **y, int N, FILE *outfile)</td></tr>
<tr class="separator:gaaa00bb931504d4953c047ee58e7ba317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff155bee61b99ac5017e11b8ffd407b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaff155bee61b99ac5017e11b8ffd407b7">psi::C_DGEEV</a> (int n, double **a, int lda, double *wr, double *wi, double **vl, int ldvl, double **vr, int ldvr, double *work, int lwork, int info)</td></tr>
<tr class="separator:gaff155bee61b99ac5017e11b8ffd407b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f4d27a7f03785e2090e82f51df475f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga61f4d27a7f03785e2090e82f51df475f">psi::C_DGESV</a> (int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)</td></tr>
<tr class="separator:ga61f4d27a7f03785e2090e82f51df475f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a32fab1a77d1ea47a9145a8e124ea9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga5a32fab1a77d1ea47a9145a8e124ea9c">psi::C_DGETRF</a> (int m, int n, double *a, int lda, int *ipiv)</td></tr>
<tr class="separator:ga5a32fab1a77d1ea47a9145a8e124ea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53680dc5cf2b74b21d23aed254e09eec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga53680dc5cf2b74b21d23aed254e09eec">psi::C_DPOTRF</a> (char uplo, int n, double *a, int lda)</td></tr>
<tr class="separator:ga53680dc5cf2b74b21d23aed254e09eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6c02fc0a629aea55fa3ea94885e2ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gacf6c02fc0a629aea55fa3ea94885e2ec">psi::C_DGETRI</a> (int n, double *a, int lda, int *ipiv, double *work, int lwork)</td></tr>
<tr class="separator:gacf6c02fc0a629aea55fa3ea94885e2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369ad7d6d71f540b359347b1b70b4e21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga369ad7d6d71f540b359347b1b70b4e21">psi::C_DPOTRI</a> (char uplo, int n, double *a, int lda)</td></tr>
<tr class="separator:ga369ad7d6d71f540b359347b1b70b4e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9140c52de648ece9bdf664b8770365ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga9140c52de648ece9bdf664b8770365ef">psi::C_DPOTRS</a> (char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)</td></tr>
<tr class="separator:ga9140c52de648ece9bdf664b8770365ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8cf22efdf98af11db327b33bde7f849"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaa8cf22efdf98af11db327b33bde7f849">psi::C_DGESVD</a> (char jobu, char jobvt, int m, int n, double *A, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork)</td></tr>
<tr class="separator:gaa8cf22efdf98af11db327b33bde7f849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f1317f08bd64d633f20935ba5d8547"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaf4f1317f08bd64d633f20935ba5d8547">psi::C_DSYEV</a> (char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)</td></tr>
<tr class="separator:gaf4f1317f08bd64d633f20935ba5d8547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc97b741ca6812939c071abd119cd070"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gacc97b741ca6812939c071abd119cd070">psi::mat_in</a> (FILE *fp, double **array, int width, int max_length, int *stat)</td></tr>
<tr class="separator:gacc97b741ca6812939c071abd119cd070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8e72c38144a8e2abfc051b870492d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga9e8e72c38144a8e2abfc051b870492d1">psi::mat_print</a> (double **matrix, int rows, int cols, FILE *outfile)</td></tr>
<tr class="separator:ga9e8e72c38144a8e2abfc051b870492d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5778ea82c6c597a45373797ea698dc1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga5778ea82c6c597a45373797ea698dc1c">psi::normalize</a> (double **A, int rows, int cols)</td></tr>
<tr class="separator:ga5778ea82c6c597a45373797ea698dc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc5435261bcef5693d54a4913e0864f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga7dc5435261bcef5693d54a4913e0864f">psi::pople</a> (double **A, double *x, int dimen, int, double tolerance, FILE *outfile, int print_lvl)</td></tr>
<tr class="separator:ga7dc5435261bcef5693d54a4913e0864f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6c5e50bb519f541ce97a049a11f36c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gabc6c5e50bb519f541ce97a049a11f36c">psi::combinations</a> (int n, int k)</td></tr>
<tr class="separator:gabc6c5e50bb519f541ce97a049a11f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad2ce5f70c7e5d9743c22ce05d647b4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga9ad2ce5f70c7e5d9743c22ce05d647b4">psi::factorial</a> (int n)</td></tr>
<tr class="separator:ga9ad2ce5f70c7e5d9743c22ce05d647b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd746c0469f6028198246aa188960c51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gabd746c0469f6028198246aa188960c51">psi::ras_set</a> (int nirreps, int nbfso, int freeze_core, int *orbspi, int *docc, int *socc, int *frdocc, int *fruocc, int **ras_opi, int *order, int ras_type)</td></tr>
<tr class="separator:gabd746c0469f6028198246aa188960c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0920198d52591837122f0c9f5e37b9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gac0920198d52591837122f0c9f5e37b9e">psi::ras_set2</a> (int nirreps, int nbfso, int delete_fzdocc, int delete_restrdocc, int *orbspi, int *docc, int *socc, int *frdocc, int *fruocc, int *restrdocc, int *restruocc, int **ras_opi, int *order, int ras_type, int hoffmann, Options &amp;options)</td></tr>
<tr class="separator:gac0920198d52591837122f0c9f5e37b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f8e6d4ea44ce054f9729f2ceda3107e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga0f8e6d4ea44ce054f9729f2ceda3107e">psi::reorder_qt</a> (int *docc_in, int *socc_in, int *frozen_docc_in, int *frozen_uocc_in, int *order, int *orbs_per_irrep, int nirreps)</td></tr>
<tr class="separator:ga0f8e6d4ea44ce054f9729f2ceda3107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87b453ce47998937967e1b4d0336fc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad87b453ce47998937967e1b4d0336fc9">psi::reorder_qt_uhf</a> (int *docc, int *socc, int *frozen_docc, int *frozen_uocc, int *order_alpha, int *order_beta, int *orbspi, int nirreps)</td></tr>
<tr class="separator:gad87b453ce47998937967e1b4d0336fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19cb5d0d6eea56f06ed5c5f70136af6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gae19cb5d0d6eea56f06ed5c5f70136af6">psi::bisect</a> (double(*function)(double), double low, double high, double tolerance, int maxiter, int printflag)</td></tr>
<tr class="separator:gae19cb5d0d6eea56f06ed5c5f70136af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40f9710ebd1018e9161a07f4d346358"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaa40f9710ebd1018e9161a07f4d346358">psi::newton</a> (double(*F)(double), double(*dF)(double), double x, double tolerance, int maxiter, int printflag)</td></tr>
<tr class="separator:gaa40f9710ebd1018e9161a07f4d346358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977f97f88a9d2b3e1df588b8b33c9b57"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga977f97f88a9d2b3e1df588b8b33c9b57">psi::secant</a> (double(*F)(double), double x0, double x1, double tolerance, int maxiter, int printflag)</td></tr>
<tr class="separator:ga977f97f88a9d2b3e1df588b8b33c9b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43680fa9286ea2dedee13fc24abd81f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga43680fa9286ea2dedee13fc24abd81f3">psi::schmidt</a> (double **A, int rows, int cols, FILE *outfile)</td></tr>
<tr class="separator:ga43680fa9286ea2dedee13fc24abd81f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58cc29b51212aa4d022ee0fbe39a3f90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga58cc29b51212aa4d022ee0fbe39a3f90">psi::schmidt_add</a> (double **A, int rows, int cols, double *v)</td></tr>
<tr class="separator:ga58cc29b51212aa4d022ee0fbe39a3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafada6de1652da33accacc15f68333d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gafada6de1652da33accacc15f68333d5b">psi::stringset_init</a> (StringSet *sset, int size, int nelec, int nfzc, short int *frozen_occ)</td></tr>
<tr class="separator:gafada6de1652da33accacc15f68333d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f8571e95ec167f1a11afdf7b216f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gae5f8571e95ec167f1a11afdf7b216f3a">psi::stringset_delete</a> (StringSet *sset)</td></tr>
<tr class="separator:gae5f8571e95ec167f1a11afdf7b216f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb5d78c936c34a1bff25de237c499f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga1eb5d78c936c34a1bff25de237c499f0">psi::stringset_add</a> (StringSet *sset, int index, unsigned char *Occ)</td></tr>
<tr class="separator:ga1eb5d78c936c34a1bff25de237c499f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad699d26dd571c528fa87f1dfb3182144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad699d26dd571c528fa87f1dfb3182144">psi::stringset_reindex</a> (StringSet *sset, short int *mo_map)</td></tr>
<tr class="separator:gad699d26dd571c528fa87f1dfb3182144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf365a9600d2d5b4a83eb37faa58b1d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gaf365a9600d2d5b4a83eb37faa58b1d34">psi::stringset_write</a> (ULI unit, const char *prefix, StringSet *sset)</td></tr>
<tr class="separator:gaf365a9600d2d5b4a83eb37faa58b1d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac15eb8e301802fa8f61e31f6a4b0b3c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gac15eb8e301802fa8f61e31f6a4b0b3c2">psi::stringset_read</a> (ULI unit, const char *prefix, StringSet **stringset)</td></tr>
<tr class="separator:gac15eb8e301802fa8f61e31f6a4b0b3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cbaa8b39c036ee7aaef4c9bd40e8361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga0cbaa8b39c036ee7aaef4c9bd40e8361">psi::slaterdetset_init</a> (SlaterDetSet *sdset, int size, StringSet *alphastrings, StringSet *betastrings)</td></tr>
<tr class="separator:ga0cbaa8b39c036ee7aaef4c9bd40e8361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0601e4d7e98acc68dcc937310497b820"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga0601e4d7e98acc68dcc937310497b820">psi::slaterdetset_delete</a> (SlaterDetSet *sdset)</td></tr>
<tr class="separator:ga0601e4d7e98acc68dcc937310497b820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf99ef26d644c66cc20b449c6aa12455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gabf99ef26d644c66cc20b449c6aa12455">psi::slaterdetset_delete_full</a> (SlaterDetSet *sdset)</td></tr>
<tr class="separator:gabf99ef26d644c66cc20b449c6aa12455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ceae3c7f3337f3c04648d58091336f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga63ceae3c7f3337f3c04648d58091336f">psi::slaterdetset_add</a> (SlaterDetSet *sdset, int index, int alphastring, int betastring)</td></tr>
<tr class="separator:ga63ceae3c7f3337f3c04648d58091336f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7821e5bc1ee8563d8284274163c9eb9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga7821e5bc1ee8563d8284274163c9eb9e">psi::slaterdetset_write</a> (ULI unit, const char *prefix, SlaterDetSet *sdset)</td></tr>
<tr class="separator:ga7821e5bc1ee8563d8284274163c9eb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2d65a1290e904986d93f3436848ab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga4a2d65a1290e904986d93f3436848ab0">psi::slaterdetset_read</a> (ULI unit, const char *prefix, SlaterDetSet **slaterdetset)</td></tr>
<tr class="separator:ga4a2d65a1290e904986d93f3436848ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92f6aaa81bb1d58628d4789be57d1d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad92f6aaa81bb1d58628d4789be57d1d4">psi::slaterdetvector_init</a> (SlaterDetVector *sdvector, SlaterDetSet *sdset)</td></tr>
<tr class="separator:gad92f6aaa81bb1d58628d4789be57d1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd2c106d795cdb373645726bbbc1ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga2bd2c106d795cdb373645726bbbc1ccd">psi::slaterdetvector_delete</a> (SlaterDetVector *sdvector)</td></tr>
<tr class="separator:ga2bd2c106d795cdb373645726bbbc1ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90db736f729453581b078f727856f432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga90db736f729453581b078f727856f432">psi::slaterdetvector_delete_full</a> (SlaterDetVector *sdvector)</td></tr>
<tr class="separator:ga90db736f729453581b078f727856f432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65981e9e946fca7adc3e44e6212da8ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga65981e9e946fca7adc3e44e6212da8ed">psi::slaterdetvector_add</a> (SlaterDetVector *sdvector, int index, double coeff)</td></tr>
<tr class="separator:ga65981e9e946fca7adc3e44e6212da8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609f6f82ffadb8fed1d312ce92635244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga609f6f82ffadb8fed1d312ce92635244">psi::slaterdetvector_set</a> (SlaterDetVector *sdvector, double *coeffs)</td></tr>
<tr class="separator:ga609f6f82ffadb8fed1d312ce92635244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46021bca516a5b4b429384151036ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gac46021bca516a5b4b429384151036ed8">psi::slaterdetvector_write</a> (ULI unit, const char *prefix, SlaterDetVector *vector)</td></tr>
<tr class="separator:gac46021bca516a5b4b429384151036ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab353180af2fc2bcd3e513d37a3425fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gab353180af2fc2bcd3e513d37a3425fbd">psi::slaterdetset_write_vect</a> (ULI unit, const char *prefix, double *coeffs, int size, int vectnum)</td></tr>
<tr class="separator:gab353180af2fc2bcd3e513d37a3425fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67eca5299660efcf885f7bd743b587f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga67eca5299660efcf885f7bd743b587f9">psi::slaterdetvector_read</a> (ULI unit, const char *prefix, SlaterDetVector **sdvector)</td></tr>
<tr class="separator:ga67eca5299660efcf885f7bd743b587f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0d9992fdf633f70982de16d3021933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga1c0d9992fdf633f70982de16d3021933">psi::slaterdetset_read_vect</a> (ULI unit, const char *prefix, double *coeffs, int size, int vectnum)</td></tr>
<tr class="separator:ga1c0d9992fdf633f70982de16d3021933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96d6244853b8d555cb6102d9cf3e3eb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga96d6244853b8d555cb6102d9cf3e3eb5">psi::solve_2x2_pep</a> (double **H, double S, double *evals, double **evecs)</td></tr>
<tr class="separator:ga96d6244853b8d555cb6102d9cf3e3eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82d2ef8f162aa6bdf8fe1a1d64ede27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gad82d2ef8f162aa6bdf8fe1a1d64ede27">psi::sort_vector</a> (double *A, int n)</td></tr>
<tr class="separator:gad82d2ef8f162aa6bdf8fe1a1d64ede27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177c6a6db04325eae4c5d5c6fb9bec02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga177c6a6db04325eae4c5d5c6fb9bec02">psi::timer_init</a> (void)</td></tr>
<tr class="separator:ga177c6a6db04325eae4c5d5c6fb9bec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c3713e536790b780749da4f5279e436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga3c3713e536790b780749da4f5279e436">psi::timer_done</a> (void)</td></tr>
<tr class="separator:ga3c3713e536790b780749da4f5279e436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ba9a6fa70806080a0e81eb75a32f73"><td class="memItemLeft" align="right" valign="top">struct timer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga86ba9a6fa70806080a0e81eb75a32f73">psi::timer_scan</a> (const char *key)</td></tr>
<tr class="separator:ga86ba9a6fa70806080a0e81eb75a32f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e23a17ad31a5648f238a8ddce4d41a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#ga76e23a17ad31a5648f238a8ddce4d41a">psi::timer_on</a> (const char *key)</td></tr>
<tr class="separator:ga76e23a17ad31a5648f238a8ddce4d41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1479e3f831fb539222f1ba2c5fa0452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QT.html#gae1479e3f831fb539222f1ba2c5fa0452">psi::timer_off</a> (const char *key)</td></tr>
<tr class="separator:gae1479e3f831fb539222f1ba2c5fa0452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae19cb5d0d6eea56f06ed5c5f70136af6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::bisect </td>
          <td>(</td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>printflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gae19cb5d0d6eea56f06ed5c5f70136af6">bisect()</a>: Finds the root of a function between two points to within a given tolerance. Iterations are limited to a given maximum, and a print flag specifies whether this function should print the results of each iteration to stdout. Note that the values of the function at the two endpoints of the interval must have <em>different</em> signs for the bisection method to work! This routine checks for this initially.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>= pointer to function we want to examine (must return double) </td></tr>
    <tr><td class="paramname">low</td><td>= lower bound of interval to search for root </td></tr>
    <tr><td class="paramname">high</td><td>= upper bound of interval </td></tr>
    <tr><td class="paramname">tolerance</td><td>= how small is the maximum allowable error </td></tr>
    <tr><td class="paramname">maxiter</td><td>= maximum number of iterations </td></tr>
    <tr><td class="paramname">printflag</td><td>= whether or not to print results for each iteration (1 or 0)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: the value of the root </p>

</div>
</div>
<a class="anchor" id="ga4b975bb8c1f54920f23214df365d3021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::C_DASUM </td>
          <td>(</td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the sum of the absolute value of this vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Number of elements in x. </td></tr>
    <tr><td class="paramname">x</td><td>A pointer to the beginning of the data in x. Must be of at least length (1+(N-1)*abs(inc_x). </td></tr>
    <tr><td class="paramname">inc_x</td><td>how many places to skip to get to next element in x</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of the absolute value </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga4b975bb8c1f54920f23214df365d3021_icgraph.svg" width="299" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gafef01298916a61134e83eeb4c9649a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DAXPY </td>
          <td>(</td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function performs y = a * x + y.</p>
<p>Steps every inc_x in x and every inc_y in y (normally both 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>length of arrays </td></tr>
    <tr><td class="paramname">a</td><td>scalar a to multiply vector x </td></tr>
    <tr><td class="paramname">x</td><td>vector x </td></tr>
    <tr><td class="paramname">inc_x</td><td>how many places to skip to get to next element in x </td></tr>
    <tr><td class="paramname">y</td><td>vector y </td></tr>
    <tr><td class="paramname">inc_y</td><td>how many places to skip to get to next element in y </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_gafef01298916a61134e83eeb4c9649a0d_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gada1f89a2db3689c3e7482ea755b49b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DCOPY </td>
          <td>(</td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function copies x into y.</p>
<p>Steps every inc_x in x and every inc_y in y (normally both 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>= length of array </td></tr>
    <tr><td class="paramname">x</td><td>= vector x </td></tr>
    <tr><td class="paramname">inc_x</td><td>= how many places to skip to get to next element in x </td></tr>
    <tr><td class="paramname">y</td><td>= vector y </td></tr>
    <tr><td class="paramname">inc_y</td><td>= how many places to skip to get to next element in y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafff0d5067135afa4228460272b6b4781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::C_DDOT </td>
          <td>(</td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the dot product of two vectors, x and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Number of elements in x and y. </td></tr>
    <tr><td class="paramname">x</td><td>A pointer to the beginning of the data in x. Must be of at least length (1+(N-1)*abs(inc_x). </td></tr>
    <tr><td class="paramname">inc_x</td><td>how many places to skip to get to next element in x </td></tr>
    <tr><td class="paramname">y</td><td>A pointer to the beginning of the data in y. </td></tr>
    <tr><td class="paramname">inc_y</td><td>how many places to skip to get to next element in y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_gafff0d5067135afa4228460272b6b4781_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaff155bee61b99ac5017e11b8ffd407b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGEEV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespacepsi.html#ab8816e166e757946ffc3ffda87ce7dc7">C_DGEEV()</a></p>
<p>This function computes the eigenvalues and the left and right right eigenvectors of a real, nonsymmetric matrix A. For symmetric matrices, refer to <a class="el" href="group__QT.html#gaf4f1317f08bd64d633f20935ba5d8547">C_DSYEV()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>= The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramname">a</td><td>= The n-by-n matrix A. As with all other lapack routines, must be allocated by contiguous memory (i.e., <a class="el" href="group__CIOMR.html#ga5342d96a20702d84857440badc8be2ec">block_matrix()</a>).</td></tr>
    <tr><td class="paramname">lda</td><td>= The leading dimension of matrix A. lda &gt;= max(1,n).</td></tr>
    <tr><td class="paramname">wr</td><td>= array of length n containing the real parts of computed eigenvalues.</td></tr>
    <tr><td class="paramname">wi</td><td>= array of length n containing the imaginary parts of computed eigenvalues.</td></tr>
    <tr><td class="paramname">vl</td><td>= matrix of dimensions ldvl*n. The columns store the left eigenvectors u(j). If the j-th eigenvalues is real, then u(j) = vl(:,j), the j-th column of vl. If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then u(j) = vl(:,j) + i*vl(:,j+1) and u(j+1) = vl(:,j) - i*vl(:,j+1). Note: this is the Fortran documentation, may need to change cols &lt;-&gt; rows.</td></tr>
    <tr><td class="paramname">ldvl</td><td>= The leading dimension of matrix vl.</td></tr>
    <tr><td class="paramname">vr</td><td>= matrix of dimensions ldvr*n. The columns store the right eigenvectors v(j). If the j-th eigenvalues is real, then v(j) = vr(:,j), the j-th column of vr. If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then v(j) = vr(:,j) + i*vr(:,j+1) and v(j+1) = vr(:,j) - i*vr(:,j+1). Note: this is the Fortran documentation, may need to change cols &lt;-&gt; rows.</td></tr>
    <tr><td class="paramname">ldvr</td><td>= The leading dimension of matrix vr.</td></tr>
    <tr><td class="paramname">work</td><td>= Array for scratch computations, of dimension lwork. On successful exit, work[0] returns the optimal value of lwork.</td></tr>
    <tr><td class="paramname">lwork</td><td>= The dimension of the array work. lwork &gt;= max(1,3*n), and if eigenvectors are required (default for this wrapper at present) then actually lwork &gt;= 4*n. For good performance, lwork must generally be larger. If lwork = -1, then a workspace query is assumed. The routine only calculates the optimal size of the work array, returns this value ans the first entry of the work array, and no error message related to lword is issued by xerbla.</td></tr>
    <tr><td class="paramname">info</td><td>= On output (returned by C_DGEEV), a status flag. info = 0 for successful exit, if info = -i, the ith argument had an illegal value. If info = i, the <a class="el" href="classpsi_1_1QR.html">QR</a> algorithm failed to compute all the eigenvalues, and no eigenvectors have been computed. Elements i+1:n of wr and wi contain eigenvalues which have converged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61f4d27a7f03785e2090e82f51df475f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGESV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGESV computes the solution to a real system of linear equations A * X = B, where A is an N-by-N matrix and X and B are N-by-NRHS matrices.</p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = P * L * U, where P is a permutation matrix, L is unit lower triangular, and U is upper triangular. The factored form of A is then used to solve the system of equations A * X = B.</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The number of linear equations, i.e., the order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the N-by-N coefficient matrix A. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>IPIV (output) INTEGER array, dimension (N) The pivot indices that define the permutation matrix P; row i of the matrix was interchanged with row IPIV(i).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the N-by-NRHS matrix of right hand side matrix B. On exit, if INFO = 0, the N-by-NRHS solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution could not be computed. </p>
<hr/>
<p>.. External Subroutines ..</p>
<p><a class="el" href="group__QT.html#ga61f4d27a7f03785e2090e82f51df475f">C_DGESV()</a></p>
<p>This function solves a system of linear equations A * X = B, where A is an n x n matrix and X and B are n x nrhs matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>= The number of linear equations, i.e., the order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramname">nrhs</td><td>= The number of right hand sides, i.e., the number of columns of the matrix B. nrhs &gt;= 0.</td></tr>
    <tr><td class="paramname">A</td><td>= On entry, the n-by-n coefficient matrix A. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
  </table>
  </dd>
</dl>
<p>lda = The leading dimension of the array A. lda &gt;= max(1,n).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>ipiv = An integer array of length n. The pivot indices that define the permutation matrix P; row i of the matrix was interchanged with row ipiv(i).</td></tr>
    <tr><td class="paramname">B</td><td>= On entry, the n-by-nrhs matrix of right hand side matrix B. On exit, if info = 0, the n-by-nrhs solution matrix X.</td></tr>
    <tr><td class="paramname">ldb</td><td>= The leading dimension of the array B. ldb &gt;= max(1,n).</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: int info. info = 0: successful exit. info &lt; 0: if info = -i, the i-th argument had an illegal value. info &gt; 0: if info = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution could not be computed. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga61f4d27a7f03785e2090e82f51df475f_icgraph.svg" width="320" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa8cf22efdf98af11db327b33bde7f849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGESVD </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gaa8cf22efdf98af11db327b33bde7f849">C_DGESVD()</a> This function computes the singular value decomposition (SVD) of a real mxn matrix A, ** optionally computing the left and/or right singular vectors. The SVD is written</p>
<p>A = U * S * transpose(V)</p>
<p>where S is an mxn matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A.</p>
<p>Note that the routine returns V^t, not V;</p>
<p>These arguments mimic their Fortran counterparts. See the LAPACK manual for additional information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jobu</td><td>= 'A' = all m columns of U are returned 'S' = the first min(m,n) columns of U are returned 'O' = the first min(m,n) columns of U are returned in the input matrix A 'N' = no columns of U are returned</td></tr>
    <tr><td class="paramname">jobvt</td><td>= 'A' = all n rows of VT are returned 'S' = the first min(m,n) rows of VT are returned 'O' = the first min(m,n) rows of VT are returned in the input matrix A 'N' = no rows of VT are returned</td></tr>
  </table>
  </dd>
</dl>
<p>Obviously jobu and jobvt cannot both be 'O'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>= The row dimension of the matrix A.</td></tr>
    <tr><td class="paramname">n</td><td>= The column dimension of the matrix A.</td></tr>
    <tr><td class="paramname">A</td><td>= On entry, the mxn matrix A with dimensions m by lda. On exit, if jobu='O' the first min(m,n) columns of A are overwritten with the left singular vectors; if jobvt='O' the first min(m,n) rows of A are overwritten with the right singular vectors; otherwise, the contents of A are destroyed.</td></tr>
    <tr><td class="paramname">lda</td><td>= The number of columns allocated for A.</td></tr>
    <tr><td class="paramname">s</td><td>= The singular values of A.</td></tr>
    <tr><td class="paramname">u</td><td>= The right singular vectors of A, returned as column of the matrix u if jobu='A'. If jobu='N' or 'O', u is not referenced.</td></tr>
    <tr><td class="paramname">ldu</td><td>= The number of columns allocated for u.</td></tr>
    <tr><td class="paramname">vt</td><td>= The left singular vectors of A, returned as rows of the matrix VT is jobvt='A'. If jobvt='N' or 'O', vt is not referenced.</td></tr>
    <tr><td class="paramname">ldvt</td><td>= The number of columns allocated for vt.</td></tr>
    <tr><td class="paramname">work</td><td>= Workspace array of length lwork.</td></tr>
    <tr><td class="paramname">lwork</td><td>= The length of the workspace array work, which should be at least as large as max(3*min(m,n)+max(m,n),5*min(m,n)). For good performance, lwork should generally be larger. If lwork=-1, a workspace query is assumed, and the value of work[0] upon return is the optimal size of the work array.</td></tr>
  </table>
  </dd>
</dl>
<p>Return value: int info. If info=0, successful exit. If info = -i, the i-th argument had an illegal value. If info &gt; 0, Related to failure in the convergence of the upper bidiagonal matrix B. See the LAPACK manual for additiona information.</p>
<p>Interface written by TDC, July 2001, updated April 2004 </p>

</div>
</div>
<a class="anchor" id="ga5a32fab1a77d1ea47a9145a8e124ea9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGETRF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<h1>Arguments</h1>
<p>M (input) INTEGER The number of rows of the matrix A. M &gt;= 0.</p>
<p>N (input) INTEGER The number of columns of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</p>
<p>IPIV (output) INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. </p>
<hr/>
<p>.. Parameters ..</p>
<p><a class="el" href="group__QT.html#ga5a32fab1a77d1ea47a9145a8e124ea9c">C_DGETRF()</a>: Compute an LU factorization of a general M-by-N matrix a using partial pivoting with row interchanges.</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if nrow &gt; ncol), and U is upper triangular (upper trapezoidal if nrow &lt; ncol).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nrow</td><td>= number of rows </td></tr>
    <tr><td class="paramname">ncol</td><td>= number of colums </td></tr>
    <tr><td class="paramname">a</td><td>= matrix to factorize </td></tr>
    <tr><td class="paramname">lda</td><td>= leading dimension of a, lda &gt;= max(1,ncol) </td></tr>
    <tr><td class="paramname">ipiv</td><td>= output integer array of the pivot indices; for 1 &lt;= i &lt;= min(nrow, ncol), col i of the matrix was interchanged with col ipiv(i).</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: int info. info = 0: successful exit. info &lt; 0: if info=-i, the ith-argument had an illegal vale. info&gt;0: if info=i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga5a32fab1a77d1ea47a9145a8e124ea9c_icgraph.svg" width="328" height="230"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gacf6c02fc0a629aea55fa3ea94885e2ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DGETRI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DGETRI computes the inverse of a matrix using the LU factorization computed by DGETRF.</p>
<p>This method inverts U and then computes inv(A) by solving the system inv(A)*L = inv(U) for inv(A).</p>
<h1>Arguments</h1>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the factors L and U from the factorization A = P*L*U as computed by DGETRF. On exit, if INFO = 0, the inverse of the original matrix A.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>IPIV (input) INTEGER array, dimension (N) The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the matrix was interchanged with row IPIV(i).</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO=0, then WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The dimension of the array WORK. LWORK &gt;= max(1,N). For optimal performance LWORK &gt;= N*NB, where NB is the optimal blocksize returned by ILAENV.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, U(i,i) is exactly zero; the matrix is singular and its inverse could not be computed. </p>
<hr/>
<p>.. Parameters ..</p>
<p><a class="el" href="group__QT.html#gacf6c02fc0a629aea55fa3ea94885e2ec">C_DGETRI()</a>: computes the inverse of a matrix using the LU factorization computed by DGETRF</p>
<p>This method inverts U and then computes inv(A) by solving the system inv(A)*L = inv(U) for inv(A).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>= order of the matrix a. n &gt;= 0. </td></tr>
    <tr><td class="paramname">a</td><td>= array of dimension (n,lda). On entry, the factors L and U from the factorization A = P*L*U as computed by DGETRF. On exit, if info=0, the inverse of hte original matrix A. </td></tr>
    <tr><td class="paramname">lda</td><td>= the leading dimension of the array a. lda &gt;= max(1,n). </td></tr>
    <tr><td class="paramname">ipiv</td><td>= The pivot indices from DGETRF. For 1&lt;=i&lt;=n, row i of the matrix was interchanged with row ipiv(i) </td></tr>
    <tr><td class="paramname">work</td><td>= workspace of dimension max(1,lwork). On exit, if info=0, then work(0) returns the optimal lwork. </td></tr>
    <tr><td class="paramname">lwork</td><td>= the dimension of the array work. lwork &gt;= max(1,n). For optimal performance, lwork &gt; n*nb, where nb is the optimal blocksize returned by ilaenv. If lwork=-1, then a workspace query is assumed; the routine only calculates the optimal size of the work array, returns this value as the first entry of the work array, and no error message related to lwork is issued by xerbla.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: int info. info=0: successful exit. info&lt;0: if info=-i, the i-th argument had an illegal value. info&gt;0: if info=i, U(i,i) is exactly zero; the matrix is singular and its inverse could not be computed. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gacf6c02fc0a629aea55fa3ea94885e2ec_icgraph.svg" width="323" height="179"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga1644e8ee3f7b6bb32137457a7dde7aa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::C_DNRM2 </td>
          <td>(</td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the square of the norm of this vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Number of elements in x. </td></tr>
    <tr><td class="paramname">x</td><td>A pointer to the beginning of the data in x. Must be of at least length (1+(N-1)*abs(inc_x). </td></tr>
    <tr><td class="paramname">inc_x</td><td>how many places to skip to get to next element in x</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the norm squared product </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga1644e8ee3f7b6bb32137457a7dde7aa2_icgraph.svg" width="608" height="192"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga53680dc5cf2b74b21d23aed254e09eec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPOTRF </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPOTRF computes the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization of a real symmetric positive definite matrix A.</p>
<p>The factorization has the form A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular.</p>
<p>This is the block version of the algorithm, calling Level 3 BLAS.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced.</p>
<p>On exit, if INFO = 0, the factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the leading minor of order i is not positive definite, and the factorization could not be completed. </p>
<hr/>
<p>.. Parameters ..</p>
<p><a class="el" href="group__QT.html#ga53680dc5cf2b74b21d23aed254e09eec">C_DPOTRF()</a>: Compute an <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization of a Hermitian positive definite N-by-N matrix A.</p>
<p>The factorization has the form A = U**T* U if uplo = 'U' or A = L*L**T if oplo = 'L'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uplo,:</td><td>uplo = 'U' upper triangle of A is stored. uplo = 'L' lower triangle of A is stored </td></tr>
    <tr><td class="paramname">n</td><td>= number of rows and columns </td></tr>
    <tr><td class="paramname">A</td><td>= matrix to factorize </td></tr>
    <tr><td class="paramname">lda</td><td>= leading dimension of a, lda &gt;= max(1,ncol)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: int info. info = 0: successful exit. info &lt; 0: if info=-i, the ith-argument had an illegal vale. info&gt;0: if info=i, the i-th minor is not positive definite </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_ga53680dc5cf2b74b21d23aed254e09eec_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga369ad7d6d71f540b359347b1b70b4e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPOTRI </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPOTRI computes the inverse of a real symmetric positive definite matrix A using the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T computed by DPOTRF.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA,N) On entry, the triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, as computed by DPOTRF. On exit, the upper or lower triangle of the (symmetric) inverse of A, overwriting the input factor U or L.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the (i,i) element of the factor U or L is zero, and the inverse could not be computed. </p>
<hr/>
<p>.. External Functions ..</p>
<p><a class="el" href="group__QT.html#ga369ad7d6d71f540b359347b1b70b4e21">C_DPOTRI()</a>: Compute inverse of a Hermitian positive deifinite matrix A AFTER a <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> decomposition is computed by C_DPORF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uplo,:</td><td>uplo = 'U' upper triangle of A is stored. uplo = 'L' lower triangle of A is stored </td></tr>
    <tr><td class="paramname">n</td><td>= number of rows and columns </td></tr>
    <tr><td class="paramname">A</td><td>= matrix to factorize </td></tr>
    <tr><td class="paramname">lda</td><td>= leading dimension of a, lda &gt;= max(1,ncol)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: int info. info = 0: successful exit. info &lt; 0: if info=-i, the ith-argument had an illegal vale. info&gt;0: if info=i, the i-th minor is no positive definite </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_ga369ad7d6d71f540b359347b1b70b4e21_icgraph.svg" width="100%" height="571"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9140c52de648ece9bdf664b8770365ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DPOTRS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DPOTRS solves a system of linear equations A*X = B with a symmetric positive definite matrix A using the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T computed by DPOTRF.</p>
<h1>Arguments</h1>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>NRHS (input) INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</p>
<p>A (input) DOUBLE PRECISION array, dimension (LDA,N) The triangular factor U or L from the <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> factorization A = U**T*U or A = L*L**T, as computed by DPOTRF.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</p>
<p>LDB (input) INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value </p>
<hr/>
<p>.. Parameters ..</p>
<p><a class="el" href="group__QT.html#ga9140c52de648ece9bdf664b8770365ef">C_DPOTRS()</a>: Solve a Hermitian positive definite matrix Ax = B AFTER a <a class="el" href="classpsi_1_1Cholesky.html">Cholesky</a> decomposition is computed for A by C_DPORF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uplo,:</td><td>uplo = 'U' upper triangle of A is stored. uplo = 'L' lower triangle of A is stored </td></tr>
    <tr><td class="paramname">n</td><td>= number of rows and columns of A </td></tr>
    <tr><td class="paramname">nrhs</td><td>= number of vectors to solve in B </td></tr>
    <tr><td class="paramname">A</td><td>= matrix to solve </td></tr>
    <tr><td class="paramname">lda</td><td>= leading dimension of a, lda &gt;= max(1,ncol) </td></tr>
    <tr><td class="paramname">B</td><td>= (input)forcing vector/(output)solution vector </td></tr>
    <tr><td class="paramname">ldb</td><td>= leading dimension of b, ldb &gt;= max(1,ncol)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: int info. info = 0: successful exit. info &lt; 0: if info=-i, the ith-argument had an illegal value. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga9140c52de648ece9bdf664b8770365ef_icgraph.svg" width="328" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gafbb95a4ea160026291b1850b3571d5ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DROT </td>
          <td>(</td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>costheta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sintheta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>*Calculates a plane Givens rotation for vectors x, y and angle theta. x = x*cos + y*sin, y = -x*sin + y*cos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>vector x </td></tr>
    <tr><td class="paramname">y</td><td>vector Y </td></tr>
    <tr><td class="paramname">length</td><td>length of x,y </td></tr>
    <tr><td class="paramname">inc_x</td><td>how many places to skip to get to the next element of x </td></tr>
    <tr><td class="paramname">inc_y</td><td>how many places to skip to get to the next element of y </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gafbb95a4ea160026291b1850b3571d5ed_icgraph.svg" width="334" height="296"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaed877a653f8542c11a21987ae0f1e160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSCAL </td>
          <td>(</td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function scales a vector by a real scalar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>length of array </td></tr>
    <tr><td class="paramname">alpha</td><td>scale factor </td></tr>
    <tr><td class="paramname">vec</td><td>vector to scale </td></tr>
    <tr><td class="paramname">inc</td><td>how many places to skip to get to next element in vec </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_gaed877a653f8542c11a21987ae0f1e160_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga33ba35d35184dab8f9ad1eac331e4747"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::C_DSWAP </td>
          <td>(</td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps a vector with another vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Specifies the number of elements in vectors x and y. </td></tr>
    <tr><td class="paramname">x</td><td>Array, DIMENSION at least (1 + (n-1)*abs(incx)). </td></tr>
    <tr><td class="paramname">inc_x</td><td>Specifies the increment for the elements of x. </td></tr>
    <tr><td class="paramname">y</td><td>Array, DIMENSION at least (1 + (n-1)*abs(incy)). </td></tr>
    <tr><td class="paramname">inc_y</td><td>Specifies the increment for the elements of y. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga33ba35d35184dab8f9ad1eac331e4747_icgraph.svg" width="352" height="214"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaf4f1317f08bd64d633f20935ba5d8547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::C_DSYEV </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>Purpose</h1>
<p>DSYEV computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A.</p>
<h1>Arguments</h1>
<p>JOBZ (input) CHARACTER*1 = 'N': Compute eigenvalues only; = 'V': Compute eigenvalues and eigenvectors.</p>
<p>UPLO (input) CHARACTER*1 = 'U': Upper triangle of A is stored; = 'L': Lower triangle of A is stored.</p>
<p>N (input) INTEGER The order of the matrix A. N &gt;= 0.</p>
<p>A (input/output) DOUBLE PRECISION array, dimension (LDA, N) On entry, the symmetric matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. On exit, if JOBZ = 'V', then if INFO = 0, A contains the orthonormal eigenvectors of the matrix A. If JOBZ = 'N', then on exit the lower triangle (if UPLO='L') or the upper triangle (if UPLO='U') of A, including the diagonal, is destroyed.</p>
<p>LDA (input) INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</p>
<p>W (output) DOUBLE PRECISION array, dimension (N) If INFO = 0, the eigenvalues in ascending order.</p>
<p>WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
<p>LWORK (input) INTEGER The length of the array WORK. LWORK &gt;= max(1,3*N-1). For optimal efficiency, LWORK &gt;= (NB+2)*N, where NB is the blocksize for DSYTRD returned by ILAENV.</p>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<p>C++ Return value: INFO (output) INTEGER = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = i, the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero. </p>
<hr/>
<p>.. Parameters ..</p>
<p><a class="el" href="group__QT.html#gaf4f1317f08bd64d633f20935ba5d8547">C_DSYEV()</a>: Computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A.</p>
<p>These arguments mimic their Fortran counterparts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jobz</td><td>= 'N' or 'n' = compute eigenvalues only; 'V' or 'v' = compute both eigenvalues and eigenvectors.</td></tr>
    <tr><td class="paramname">uplo</td><td>= 'U' or 'u' = A contains the upper triangular part of the matrix; 'L' or 'l' = A contains the lower triangular part of the matrix.</td></tr>
    <tr><td class="paramname">n</td><td>= The order of the matrix A.</td></tr>
    <tr><td class="paramname">A</td><td>= On entry, the two-dimensional array with dimensions n by lda. On exit, if jobz = 'V', the columns of the matrix contain the eigenvectors of A, but if jobz = 'N', the contents of the matrix are destroyed.</td></tr>
    <tr><td class="paramname">lda</td><td>= The second dimension of A (i.e., the number of columns allocated for A).</td></tr>
    <tr><td class="paramname">w</td><td>= The computed eigenvalues in ascending order.</td></tr>
    <tr><td class="paramname">work</td><td>= An array of length lwork. On exit, if the return value is 0, work[0] contains the optimal value of lwork.</td></tr>
    <tr><td class="paramname">lwork</td><td>= The length of the array work. A useful value of lwork seems to be 3*N.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 0 = successful exit &lt;0 = the value of the i-th argument to the function was illegal &gt;0 = the algorithm failed to converge.</p>
<p>Interface written by TDC, 10/2002 </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_gaf4f1317f08bd64d633f20935ba5d8547_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga3d473748326ef68bd4af5fd4e9ff5e44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long int psi::C_IDAMAX </td>
          <td>(</td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the index of the largest absolute value compoment of this vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Number of elements in x. </td></tr>
    <tr><td class="paramname">x</td><td>A pointer to the beginning of the data in x. Must be of at least length (1+(N-1)*abs(inc_x). </td></tr>
    <tr><td class="paramname">inc_x</td><td>how many places to skip to get to next element in x</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the largest absolute value </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga3d473748326ef68bd4af5fd4e9ff5e44_icgraph.svg" width="304" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gac7dba6467743ab41c4e2efbb9bba5595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::cc_excited </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gac7dba6467743ab41c4e2efbb9bba5595">cc_excited()</a>: This function takes a WFN string and returns 1 if the WFN is an excited-state method and 0 if the WFN is a ground-state method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*wfn</td><td>= wavefunction string</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 1 if an excited state method, else 0 </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gac7dba6467743ab41c4e2efbb9bba5595_icgraph.svg" width="283" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad3ed72ce0e58f61793f21acb5fe0c244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::cc_excited </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>wfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gac7dba6467743ab41c4e2efbb9bba5595">cc_excited()</a>: This function takes a WFN string and returns 1 if the WFN is an excited-state method and 0 if the WFN is a ground-state method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wfn</td><td>= wavefunction string</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 1 if an excited state method, else 0 </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gad3ed72ce0e58f61793f21acb5fe0c244_cgraph.svg" width="283" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad4348565874a4f55aa86efe4ef336cde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::cc_wfn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gad4348565874a4f55aa86efe4ef336cde">cc_wfn()</a>: Checks if the given wavefunction string is a coupled-cluster type and returns 1 if yes and 0 if no.</p>
<p>Note: "coupled-cluster type" means it is handled by PSI like the coupled-cluster codes, not necessarily that it is literally a coupled-cluster wavefunction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*wfn</td><td>= wavefunction string</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 1 if the WFN is a CC method, 0 otherwise </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gad4348565874a4f55aa86efe4ef336cde_icgraph.svg" width="240" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9287456500de60c9fa5b733b633340b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::cc_wfn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>wfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gad4348565874a4f55aa86efe4ef336cde">cc_wfn()</a>: Checks if the given wavefunction string is a coupled-cluster type and returns 1 if yes and 0 if no.</p>
<p>Note: "coupled-cluster type" means it is handled by PSI like the coupled-cluster codes, not necessarily that it is literally a coupled-cluster wavefunction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wfn</td><td>= wavefunction string</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 1 if the WFN is a CC method, 0 otherwise </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga9287456500de60c9fa5b733b633340b3_cgraph.svg" width="240" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa5897677944b94d2ec0555dd9cdd0a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::ci_wfn </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>wfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gaa5897677944b94d2ec0555dd9cdd0a8e">ci_wfn()</a>: Examine the wavefunction type and return 1 if a CI/MCSCF-type, otherwise 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*wfn</td><td>= wavefunction string</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 1 if a CI/MCSCF-type wavefunction, otherwise 0 </p>

</div>
</div>
<a class="anchor" id="gaa457150c780cf1438b4b7f859e3205cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::ci_wfn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>wfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gaa5897677944b94d2ec0555dd9cdd0a8e">ci_wfn()</a>: Examine the wavefunction type and return 1 if a CI/MCSCF-type, otherwise 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wfn</td><td>= wavefunction string</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 1 if a CI/MCSCF-type wavefunction, otherwise 0 </p>

</div>
</div>
<a class="anchor" id="gabc6c5e50bb519f541ce97a049a11f36c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::combinations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gabc6c5e50bb519f541ce97a049a11f36c">combinations()</a> : Calculates the number of ways to choose k objects from n objects, or "n choose k"</p>
<p>Parameters: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>= number of objects in total </td></tr>
    <tr><td class="paramname">k</td><td>= number of objects taken at a time</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: number of combinations of n objects taken k at a time ("n choose k") (returned as a double). </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gabc6c5e50bb519f541ce97a049a11f36c_cgraph.svg" width="278" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gabc6c5e50bb519f541ce97a049a11f36c_icgraph.svg" width="366" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaf4c6345ae60fb29588e8d1064f8f53d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::david </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>print</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gaf4c6345ae60fb29588e8d1064f8f53d1">david()</a>: Computes the lowest few eigenvalues and eigenvectors of a symmetric matrix, A, using the Davidson-Liu algorithm.</p>
<p>The matrix must be small enough to fit entirely in core. This algorithm is useful if one is interested in only a few roots of the matrix rather than the whole spectrum.</p>
<p>NB: This implementation will keep up to eight guess vectors for each root desired before collapsing to one vector per root. In addition, if smart_guess=1 (the default), guess vectors are constructed by diagonalization of a sub-matrix of A; otherwise, unit vectors are used.</p>
<p>TDC, July-August 2002</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>= matrix to diagonalize </td></tr>
    <tr><td class="paramname">N</td><td>= dimension of A </td></tr>
    <tr><td class="paramname">M</td><td>= number of roots desired </td></tr>
    <tr><td class="paramname">eps</td><td>= eigenvalues </td></tr>
    <tr><td class="paramname">v</td><td>= eigenvectors </td></tr>
    <tr><td class="paramname">cutoff</td><td>= tolerance for convergence of eigenvalues </td></tr>
    <tr><td class="paramname">print</td><td>= Boolean for printing additional information</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: number of converged roots </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gaf4c6345ae60fb29588e8d1064f8f53d1_cgraph.svg" width="440" height="392"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaf67e10fae2a18289df311c94705919d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::dirprd_block </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gaf67e10fae2a18289df311c94705919d8">dirprd_block()</a></p>
<p>This function takes two block matrices A and B and multiplies each element of B by the corresponding element of A</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>= block matrix A </td></tr>
    <tr><td class="paramname">B</td><td>= block matrix B </td></tr>
    <tr><td class="paramname">nrows</td><td>= number of rows of A and B </td></tr>
    <tr><td class="paramname">ncols</td><td>= number of columns of A and B</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="gabc510b7f8d584d53d58a2d7a92e71c4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::dot_block </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gabc510b7f8d584d53d58a2d7a92e71c4d">dot_block()</a>: Find dot product of two block matrices</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>= block matrix A </td></tr>
    <tr><td class="paramname">B</td><td>= block matrix B </td></tr>
    <tr><td class="paramname">nrows</td><td>= number of rows of A and B </td></tr>
    <tr><td class="paramname">ncols</td><td>= number of columns of A and B </td></tr>
    <tr><td class="paramname">alpha</td><td>= scale factor by which the dot product is multiplied</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: dot product </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gabc510b7f8d584d53d58a2d7a92e71c4d_cgraph.svg" width="278" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9ad2ce5f70c7e5d9743c22ce05d647b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::factorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga9ad2ce5f70c7e5d9743c22ce05d647b4">factorial()</a>: Returns n!</p>
<p>Parameters: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>= number to take factorial of</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: n factorial, as a double word (since n! can get very large). </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga9ad2ce5f70c7e5d9743c22ce05d647b4_icgraph.svg" width="507" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaedcbafb11f8276be426b80299e25ff45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::fill_sym_matrix </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gaedcbafb11f8276be426b80299e25ff45">fill_sym_matrix()</a>: Fills a symmetric matrix by placing the elements of the lower triangle into the upper triangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>= matrix to symmetrize </td></tr>
    <tr><td class="paramname">size</td><td>= number of rows or columns (assume square)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="ga6ad18063cef37be3eef59d317e7a26e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::filter </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ioff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfzc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfzv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga6ad18063cef37be3eef59d317e7a26e4">filter()</a>: Filter out undesired (frozen core/virt) integrals</p>
<p>Given a lower-triangle array of integrals in the full space of orbitals as well as numbers of frozen core and virtual orbitals, this function returns a list of integrals involving only active orbitals.</p>
<p>TDC, June 2001</p>
<p>Note: Based on the code written by CDS in the original iwl_rd_one_all_act() function in LIBIWL. </p>

</div>
</div>
<a class="anchor" id="ga7f8cf84ee88f3deeb68a4aa21b2b967d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::free_3d_array </td>
          <td>(</td>
          <td class="paramtype">double ***&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga7f8cf84ee88f3deeb68a4aa21b2b967d">free_3d_array()</a>: Free a (non-contiguous) 3D array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>= triple-star pointer to the 3D array </td></tr>
    <tr><td class="paramname">p</td><td>= size of first dimension </td></tr>
    <tr><td class="paramname">q</td><td>= size of second dimension</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="ga59a60b96011b32445e146d038e437c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double *** psi::init_3d_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>3d_array(): Initialize a (non-contiguous) 3D array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>= size of first dimension </td></tr>
    <tr><td class="paramname">q</td><td>= size of second dimension </td></tr>
    <tr><td class="paramname">r</td><td>= size of third dimension</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: triple-star pointer to 3D array </p>

</div>
</div>
<a class="anchor" id="gaaa00bb931504d4953c047ee58e7ba317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::invert_matrix </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>INVERT_MATRIX(): The function takes the inverse of a matrix using the C routines in Numerical Recipes in C.</p>
<p>Matt Leininger, Summer 1994</p>
<p>Parameters: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>= matrix to take the inverse of (is modified by <a class="el" href="group__QT.html#gaaa00bb931504d4953c047ee58e7ba317">invert_matrix()</a>) </td></tr>
    <tr><td class="paramname">y</td><td>= the inverse matrix </td></tr>
    <tr><td class="paramname">N</td><td>= the size of the matrices </td></tr>
    <tr><td class="paramname">outfile</td><td>= file for error messages</td></tr>
  </table>
  </dd>
</dl>
<p>Other variables: col and indx are temporary arrays d is 1 or -1</p>
<p>Returns: double (determinant) Note: The original matrix is modified by <a class="el" href="group__QT.html#gaaa00bb931504d4953c047ee58e7ba317">invert_matrix()</a> </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gaaa00bb931504d4953c047ee58e7ba317_cgraph.svg" width="304" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gaaa00bb931504d4953c047ee58e7ba317_icgraph.svg" width="352" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gacc97b741ca6812939c071abd119cd070"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::mat_in </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MAT_IN(): Function to read in a matrix. Simple version for now.</p>
<p>Parameters: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>= file pointer to input stream </td></tr>
    <tr><td class="paramname">array</td><td>= matrix to hold data </td></tr>
    <tr><td class="paramname">width</td><td>= number of columns to read </td></tr>
    <tr><td class="paramname">max_length</td><td>= maximum number of rows to read </td></tr>
    <tr><td class="paramname">stat</td><td>= pointer to int to hold status flag (0=read ok, 1=error)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: number of rows read Also modifies stat to = error code (0 = ok, 1 = error) </p>

</div>
</div>
<a class="anchor" id="ga9e8e72c38144a8e2abfc051b870492d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::mat_print </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga9e8e72c38144a8e2abfc051b870492d1">mat_print()</a>: Prints a matrix to a file in a formatted style</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>= matrix to print </td></tr>
    <tr><td class="paramname">rows</td><td>= number of rows </td></tr>
    <tr><td class="paramname">cols</td><td>= number of columns </td></tr>
    <tr><td class="paramname">outfile</td><td>= output file pointer for printing</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: Always returns zero... </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga9e8e72c38144a8e2abfc051b870492d1_icgraph.svg" width="304" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa40f9710ebd1018e9161a07f4d346358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::newton </td>
          <td>(</td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>dF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>printflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gaa40f9710ebd1018e9161a07f4d346358">newton()</a>: Find the root of a function by Newton's method. Iterations are limited to a maximum value. The algorithm stops when the difference between successive estimates of the root is less than the specified tolerance. An initial guess for the root must be given, as well as the function AND it's derivative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>= pointer to function we want to examine (must return double) </td></tr>
    <tr><td class="paramname">dF</td><td>= pointer to <em>derivative</em> of function F </td></tr>
    <tr><td class="paramname">x</td><td>= initial guess for root </td></tr>
    <tr><td class="paramname">tolerance</td><td>= how close successive guesses must get before convergence </td></tr>
    <tr><td class="paramname">maxiter</td><td>= maximum number of iterations </td></tr>
    <tr><td class="paramname">printflag</td><td>= whether or not to print results for each iteration (1 or 0)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: the value of the root </p>

</div>
</div>
<a class="anchor" id="ga5778ea82c6c597a45373797ea698dc1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::normalize </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga5778ea82c6c597a45373797ea698dc1c">normalize()</a>: Normalize a set of vectors</p>
<p>Assume we're normalizing the ROWS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>= matrix holding vectors to normalize </td></tr>
    <tr><td class="paramname">rows</td><td>= number of rows in A </td></tr>
    <tr><td class="paramname">cols</td><td>= number of columns in A</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none</p>
<p>David Sherrill, Feb 1994 </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga5778ea82c6c597a45373797ea698dc1c_cgraph.svg" width="251" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7dc5435261bcef5693d54a4913e0864f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::pople </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>print_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>POPLE(): Uses Pople's method to iteratively solve linear equations Ax = b</p>
<p>Matt Leininger, April 1998</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>= matrix </td></tr>
    <tr><td class="paramname">x</td><td>= initially has vector b, but returns vector x. </td></tr>
    <tr><td class="paramname">dimen</td><td>= dimension of vector x. </td></tr>
    <tr><td class="paramname">num_vecs</td><td>= number of vectors x to obtain. </td></tr>
    <tr><td class="paramname">tolerance</td><td>= cutoff threshold for norm of expansion vector.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 0 for success, 1 for failure </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga7dc5435261bcef5693d54a4913e0864f_cgraph.svg" width="411" height="392"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gabd746c0469f6028198246aa188960c51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::ras_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nirreps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nbfso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>freeze_core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>orbspi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>docc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>socc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>frdocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fruocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>ras_opi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ras_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gabd746c0469f6028198246aa188960c51">ras_set()</a>: Deprecated</p>
<p>This function sets up the number of orbitals per irrep for each of the RAS subspaces [frozen core, RAS I, RAS II, RAS III, RAS IV, frozen virts]. It also obtains the appropriate orbital reordering array. The reordering array takes a basis function in Pitzer ordering (orbitals grouped according to irrep) and gives the corresponding index in the RAS numbering scheme. Orbitals are numbered according to irrep within each of the subspaces.</p>
<p>Formerly, docc, socc, frdocc, and fruocc were read in this function. Now docc and socc will be left as-is if they are not present in input.</p>
<p>C. David Sherrill Center for Computational Quantum Chemistry University of Georgia, 25 June 1995</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nirreps</td><td>= num of irreps in computational point group </td></tr>
    <tr><td class="paramname">nbfso</td><td>= num of basis functions in symmetry orbitals (num MOs) </td></tr>
    <tr><td class="paramname">freeze_core</td><td>= 1 to remove frozen core orbitals from ras_opi </td></tr>
    <tr><td class="paramname">orbspi</td><td>= array giving num symmetry orbitals (or MOs) per irrep </td></tr>
    <tr><td class="paramname">docc</td><td>= array of doubly occupied orbitals per irrep </td></tr>
    <tr><td class="paramname">socc</td><td>= array of singly occupied orbitals per irrep </td></tr>
    <tr><td class="paramname">frdocc</td><td>= array of frozen core per irrep </td></tr>
    <tr><td class="paramname">fruocc</td><td>= array of frozen virtuals per irrep </td></tr>
    <tr><td class="paramname">ras_opi</td><td>= matrix giving num of orbitals per irrep per ras space, addressed as ras_opi[ras_space][irrep] </td></tr>
    <tr><td class="paramname">order</td><td>= array nbfso big which maps Pitzer to Correlated order </td></tr>
    <tr><td class="paramname">ras_type</td><td>= if 1, put docc and socc together in same RAS space (RAS I), as appropriate for DETCI. If 0, put socc in its own RAS space (RAS II), as appropriate for CC.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 1 for success, 0 otherwise </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gabd746c0469f6028198246aa188960c51_cgraph.svg" width="283" height="190"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gac0920198d52591837122f0c9f5e37b9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::ras_set2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nirreps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delete_fzdocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delete_restrdocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>orbspi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>docc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>socc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>frdocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fruocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>restrdocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>restruocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>ras_opi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ras_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hoffmann</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gac0920198d52591837122f0c9f5e37b9e">ras_set2()</a></p>
<p>NOTE!!!! : Codes need to be modified to provide a guess of the frozen docc and frozen uocc arrays now !!!! CDS-TODO: 9/2011</p>
<p>This function sets up the number of orbitals per irrep for each of the RAS subspaces [frozen core (FZC), restricted core (COR), RAS I, RAS II, RAS III, RAS IV, restricted virts (VIR), frozen virts (FZV)]. It also obtains the appropriate orbital reordering array. The reordering array takes a basis function in Pitzer ordering (orbitals grouped according to irrep) and gives the corresponding index in the RAS numbering scheme. Orbitals are numbered according to irrep within each of the subspaces.</p>
<p>Formerly, docc, socc, frdocc, and fruocc were read in this function. Now docc and socc will be left as-is if they are not present in input.</p>
<p>Assume we always want integrals (at least some of them...) involving restricted orbitals, but we may not need them for frozen orbitals unless perhaps it's a gradient. The frozen orbitals will never enter explicitly in DETCI, but restricted orbitals may or may not, depending on the type of computation (CI vs CAS vs CASPT2, etc). For conventional CI, FCI, MRCI, RASCI, CASSCF, restricted orbitals will not participate explicitly in DETCI. For CASPT2, perhaps they will. CLAG and DETCAS will still need to have some indices in the restricted (and possibly frozen) orbital subspaces?</p>
<p>C. David Sherrill</p>
<p>Updated June 2002 to distinguish between frozen and restricted spaces</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nirreps</td><td>= num of irreps in computational point group </td></tr>
    <tr><td class="paramname">nmo</td><td>= number of MO's </td></tr>
    <tr><td class="paramname">delete_fzdocc</td><td>= 1 to remove frozen core orbitals from ras_opi[0] </td></tr>
    <tr><td class="paramname">delete_restrdocc</td><td>= 1 to remove restricted core orbs from ras_opi[0] </td></tr>
    <tr><td class="paramname">orbspi</td><td>= array giving num symmetry orbitals (or MOs) per irrep </td></tr>
    <tr><td class="paramname">docc</td><td>= array of doubly occupied orbitals per irrep (guess should be provided) </td></tr>
    <tr><td class="paramname">socc</td><td>= array of singly occupied orbitals per irrep (guess should be provided) </td></tr>
    <tr><td class="paramname">frdocc</td><td>= array of frozen core per irrep before: (returned by function, allocate before call) now: allocate and fill with a guess </td></tr>
    <tr><td class="paramname">fruocc</td><td>= array of frozen virtuals per irrep before: (returned by function, allocate before call) now: allocate and fill with a guess </td></tr>
    <tr><td class="paramname">rstrdocc</td><td>= array of restricted core per irrep (returned by function, but allocate before call) </td></tr>
    <tr><td class="paramname">rstruocc</td><td>= array of restricted core per irrep (returned by function, but allocate before call) </td></tr>
    <tr><td class="paramname">ras_opi</td><td>= matrix giving num of orbitals per irrep per ras space, addressed as ras_opi[ras_space][irrep] (returned by function, but allocate before call) </td></tr>
    <tr><td class="paramname">order</td><td>= array nmo big which maps Pitzer to Correlated order (returned by function, but allocate before call) </td></tr>
    <tr><td class="paramname">ras_type</td><td>= if 1, put docc and socc together in same RAS space (RAS I), as appropriate for DETCI. If 0, put socc in its own RAS space (RAS II), as appropriate for CC. </td></tr>
    <tr><td class="paramname">hoffmann</td><td>= if &gt; 0, order orbitals according to Mark Hoffmann. hoffmann==1: ras1, ras2, ..., rasn, COR, FZC, VIR, FZV. hoffmann==2: VIR, ras1, ras2, ..., rasn, COR, FZC, FZV. Note odd placement of FZC in middle!</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 1 for success, 0 otherwise </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gac0920198d52591837122f0c9f5e37b9e_cgraph.svg" width="291" height="190"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga0f8e6d4ea44ce054f9729f2ceda3107e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::reorder_qt </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>docc_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>socc_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>frozen_docc_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>frozen_uocc_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>orbs_per_irrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nirreps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga0f8e6d4ea44ce054f9729f2ceda3107e">reorder_qt()</a></p>
<p>This function constructs a reordering array according to the "Quantum Trio" standard ordering, in which the orbitals are divided into the following sets: frozen core, then doubly occupied, then singly occupied, then virtuals, then deleted (frozen) virtuals. The reordering array takes a basis function in Pitzer ordering (orbitals grouped according to irrep) and gives the corresponding index in the Quantum Trio numbering scheme.</p>
<p>Should give the same reordering array as in the old libread30 routines.</p>
<p>C. David Sherrill Center for Computational Quantum Chemistry University of Georgia, 1995</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">docc_in</td><td>= doubly occupied orbitals per irrep </td></tr>
    <tr><td class="paramname">socc_in</td><td>= singly occupied orbitals per irrep </td></tr>
    <tr><td class="paramname">frozen_docc_in</td><td>= frozen occupied orbitals per irrep </td></tr>
    <tr><td class="paramname">frozen_uocc_in</td><td>= frozen unoccupied orbitals per irrep </td></tr>
    <tr><td class="paramname">order</td><td>= reordering array (Pitzer-&gt;QT order) </td></tr>
    <tr><td class="paramname">nirreps</td><td>= number of irreducible representations </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga0f8e6d4ea44ce054f9729f2ceda3107e_cgraph.svg" width="288" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga0f8e6d4ea44ce054f9729f2ceda3107e_icgraph.svg" width="512" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad87b453ce47998937967e1b4d0336fc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::reorder_qt_uhf </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>docc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>socc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>frozen_docc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>frozen_uocc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>order_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>order_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>orbspi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nirreps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gad87b453ce47998937967e1b4d0336fc9">reorder_qt_uhf()</a></p>
<p>Generalization of <a class="el" href="group__QT.html#ga0f8e6d4ea44ce054f9729f2ceda3107e">reorder_qt()</a> for UHF case</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">docc</td><td>= doubly occupied orbitals per irrep </td></tr>
    <tr><td class="paramname">socc</td><td>= singly occupied orbitals per irrep </td></tr>
    <tr><td class="paramname">frozen_docc</td><td>= frozen occupied orbitals per irrep </td></tr>
    <tr><td class="paramname">frozen_uocc</td><td>= frozen unoccupied orbitals per irrep </td></tr>
    <tr><td class="paramname">order_alpha</td><td>= reordering array for alpha (Pitzer-&gt;QT order) </td></tr>
    <tr><td class="paramname">order_beta</td><td>= reordering array for beta (Pitzer-&gt;QT order) </td></tr>
    <tr><td class="paramname">nirreps</td><td>= number of irreducible representations </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gad87b453ce47998937967e1b4d0336fc9_cgraph.svg" width="312" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gad87b453ce47998937967e1b4d0336fc9_icgraph.svg" width="536" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga43680fa9286ea2dedee13fc24abd81f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::schmidt </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SCHMIDT(): Gram-Schmidt orthogonalize a set of vectors</p>
<p>Assume we're orthogonalizing the ROWS, since in C a vector is usually a row more often than a column.</p>
<p>David Sherrill, Feb 1994</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>= matrix to orthogonalize (matrix of doubles) </td></tr>
    <tr><td class="paramname">rows</td><td>= rows of A </td></tr>
    <tr><td class="paramname">cols</td><td>= columns of A</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga43680fa9286ea2dedee13fc24abd81f3_cgraph.svg" width="254" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga43680fa9286ea2dedee13fc24abd81f3_icgraph.svg" width="291" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga58cc29b51212aa4d022ee0fbe39a3f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psi::schmidt_add </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SCHMIDT_ADD(): Assume A is a orthogonal matrix. This function Gram-Schmidt orthogonalizes a new vector v and adds it to matrix A. A must contain a free row pointer for a new row. Don't add orthogonalized v' if norm(v') &lt; NORM_TOL.</p>
<p>David Sherrill, Feb 1994</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>= matrix to add new vector to </td></tr>
    <tr><td class="paramname">rows</td><td>= current number of rows in A (A must have ptr for 'rows+1' row.) </td></tr>
    <tr><td class="paramname">cols</td><td>= columns in A  v = vector to add to A after it has been made orthogonal to rest of A</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 1 if a vector is added to A, 0 otherwise </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga58cc29b51212aa4d022ee0fbe39a3f90_cgraph.svg" width="283" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga58cc29b51212aa4d022ee0fbe39a3f90_icgraph.svg" width="262" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga977f97f88a9d2b3e1df588b8b33c9b57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double psi::secant </td>
          <td>(</td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>printflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga977f97f88a9d2b3e1df588b8b33c9b57">secant()</a>: Find the root of a function by the Secant Method. Iterations are limited to a maximum value. The algorithm stops when the relative difference between successive guesses is less than the specified tolerance. An initial TWO guesses for the root must be given, as well as the function itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>= pointer to function we want to examine (must return double) </td></tr>
    <tr><td class="paramname">x0</td><td>= 1st guess for root </td></tr>
    <tr><td class="paramname">x1</td><td>= 2nd guess for root </td></tr>
    <tr><td class="paramname">tolerance</td><td>= how close successive guesses must get before convergence </td></tr>
    <tr><td class="paramname">maxiter</td><td>= maximum number of iterations </td></tr>
    <tr><td class="paramname">printflag</td><td>= whether or not to print results for each iteration (1 or 0)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: the value of the root </p>

</div>
</div>
<a class="anchor" id="ga63ceae3c7f3337f3c04648d58091336f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetset_add </td>
          <td>(</td>
          <td class="paramtype">SlaterDetSet *&#160;</td>
          <td class="paramname"><em>sdset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alphastring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>betastring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga63ceae3c7f3337f3c04648d58091336f">slaterdetset_add()</a>: Add info for a particular Slater determinant to a <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdset</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> to add to </td></tr>
    <tr><td class="paramname">index</td><td>= location in the set to add to </td></tr>
    <tr><td class="paramname">alphastring</td><td>= alpha string ID for the new determinant </td></tr>
    <tr><td class="paramname">betastring</td><td>= beta string ID for the new determinant</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="ga0601e4d7e98acc68dcc937310497b820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetset_delete </td>
          <td>(</td>
          <td class="paramtype">SlaterDetSet *&#160;</td>
          <td class="paramname"><em>sdset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga0601e4d7e98acc68dcc937310497b820">slaterdetset_delete()</a>: Delete a Slater Determinant Set.</p>
<p>Does not free the members alphastrings and betastrings. See also: <a class="el" href="group__QT.html#gabf99ef26d644c66cc20b449c6aa12455">slaterdetset_delete_full()</a> which does this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdset</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> to be de-allocated</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="gabf99ef26d644c66cc20b449c6aa12455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetset_delete_full </td>
          <td>(</td>
          <td class="paramtype">SlaterDetSet *&#160;</td>
          <td class="paramname"><em>sdset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gabf99ef26d644c66cc20b449c6aa12455">slaterdetset_delete_full()</a>: De-allocate a Slater Determinant Set.</p>
<p>Frees memory including alpha and beta strings. See <a class="el" href="group__QT.html#ga0601e4d7e98acc68dcc937310497b820">slaterdetset_delete()</a> for a similar version which does not free the alpha and beta strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdset</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> to be de-allocated</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gabf99ef26d644c66cc20b449c6aa12455_cgraph.svg" width="379" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gabf99ef26d644c66cc20b449c6aa12455_icgraph.svg" width="374" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga0cbaa8b39c036ee7aaef4c9bd40e8361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetset_init </td>
          <td>(</td>
          <td class="paramtype">SlaterDetSet *&#160;</td>
          <td class="paramname"><em>sdset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringSet *&#160;</td>
          <td class="paramname"><em>alphastrings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringSet *&#160;</td>
          <td class="paramname"><em>betastrings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga0cbaa8b39c036ee7aaef4c9bd40e8361">slaterdetset_init()</a>: Initialize a Slater Determinant Set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdset</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> being initialized </td></tr>
    <tr><td class="paramname">size</td><td>= number of SlaterDets to be held </td></tr>
    <tr><td class="paramname">alphastrings</td><td>= pointer to <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> of alpha strings </td></tr>
    <tr><td class="paramname">betastrings</td><td>= pointer to <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> of beta strings</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga0cbaa8b39c036ee7aaef4c9bd40e8361_icgraph.svg" width="558" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga4a2d65a1290e904986d93f3436848ab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetset_read </td>
          <td>(</td>
          <td class="paramtype">ULI&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlaterDetSet **&#160;</td>
          <td class="paramname"><em>slaterdetset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga4a2d65a1290e904986d93f3436848ab0">slaterdetset_read()</a>: Read a Slater Determinant Set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>= file number of the <a class="el" href="classpsi_1_1PSIO.html">PSIO</a> file </td></tr>
    <tr><td class="paramname">prefix</td><td>= prefix string to come before libpsio entry keys </td></tr>
    <tr><td class="paramname">sdset</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> to read into</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_ga4a2d65a1290e904986d93f3436848ab0_cgraph.svg" width="100%" height="404"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga4a2d65a1290e904986d93f3436848ab0_icgraph.svg" width="371" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga1c0d9992fdf633f70982de16d3021933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetset_read_vect </td>
          <td>(</td>
          <td class="paramtype">ULI&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vectnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga1c0d9992fdf633f70982de16d3021933">slaterdetset_read_vect()</a>: Read in the coefficients for a single vector associated with a <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a>.</p>
<p>This function already assumes we've already called <a class="el" href="group__QT.html#ga4a2d65a1290e904986d93f3436848ab0">slaterdetset_read()</a> to read in the string and determinant information. This is only going to read in the coefficients. This has been split out because we might want to read several roots for a given determinant setup. This does not actually depend on the presence of a <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> object and is called a <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>= file number of the UNINITIALIZED <a class="el" href="classpsi_1_1PSIO.html">PSIO</a> file </td></tr>
    <tr><td class="paramname">prefix</td><td>= prefix string to come before libpsio entry keys </td></tr>
    <tr><td class="paramname">coeffs</td><td>= array to hold coefficients read </td></tr>
    <tr><td class="paramname">size</td><td>= number of elements in coeffs array </td></tr>
    <tr><td class="paramname">vectnum</td><td>= the vector number (for the <a class="el" href="classpsi_1_1PSIO.html">PSIO</a> key). Start from 0.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none</p>
<p>CDS 8/03 </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga1c0d9992fdf633f70982de16d3021933_cgraph.svg" width="528" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga1c0d9992fdf633f70982de16d3021933_icgraph.svg" width="403" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7821e5bc1ee8563d8284274163c9eb9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetset_write </td>
          <td>(</td>
          <td class="paramtype">ULI&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlaterDetSet *&#160;</td>
          <td class="paramname"><em>sdset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga7821e5bc1ee8563d8284274163c9eb9e">slaterdetset_write()</a>: Write a Slater Determinant Set to disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>= file number to write to </td></tr>
    <tr><td class="paramname">prefix</td><td>= prefix string to come before libpsio entry keys </td></tr>
    <tr><td class="paramname">sdset</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> to write</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga7821e5bc1ee8563d8284274163c9eb9e_cgraph.svg" width="536" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga7821e5bc1ee8563d8284274163c9eb9e_icgraph.svg" width="344" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gab353180af2fc2bcd3e513d37a3425fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetset_write_vect </td>
          <td>(</td>
          <td class="paramtype">ULI&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vectnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gab353180af2fc2bcd3e513d37a3425fbd">slaterdetset_write_vect()</a>: Write to disk the coefficients for a single vector associated with a set of Slater determinants.</p>
<p>This function already assumes we've already called <a class="el" href="group__QT.html#ga7821e5bc1ee8563d8284274163c9eb9e">slaterdetset_write()</a> to write out the string and determinant information. This is only going to write out the coefficients. This has been split out because we might want to write several roots for a given determinant setup. This does not actually dpend on the presence of a <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> object so it is called a <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>= file number of the UNINITIALIZED <a class="el" href="classpsi_1_1PSIO.html">PSIO</a> file </td></tr>
    <tr><td class="paramname">prefix</td><td>= prefix string to come before libpsio entry keys </td></tr>
    <tr><td class="paramname">coeffs</td><td>= array of coefficients to write </td></tr>
    <tr><td class="paramname">size</td><td>= number of elements in coeffs array </td></tr>
    <tr><td class="paramname">vectnum</td><td>= the vector number (to make a <a class="el" href="classpsi_1_1PSIO.html">PSIO</a> key). Start numbering from zero.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none</p>
<p>CDS 8/03 </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gab353180af2fc2bcd3e513d37a3425fbd_cgraph.svg" width="387" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gab353180af2fc2bcd3e513d37a3425fbd_icgraph.svg" width="376" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga65981e9e946fca7adc3e44e6212da8ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetvector_add </td>
          <td>(</td>
          <td class="paramtype">SlaterDetVector *&#160;</td>
          <td class="paramname"><em>sdvector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga65981e9e946fca7adc3e44e6212da8ed">slaterdetvector_add()</a>: Add a coefficient to a <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdvector</td><td>= Pointer to <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> to add to </td></tr>
    <tr><td class="paramname">index</td><td>= location in vector for writing the coefficient </td></tr>
    <tr><td class="paramname">coeff</td><td>= the coefficient to write to location index</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="ga2bd2c106d795cdb373645726bbbc1ccd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetvector_delete </td>
          <td>(</td>
          <td class="paramtype">SlaterDetVector *&#160;</td>
          <td class="paramname"><em>sdvector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga2bd2c106d795cdb373645726bbbc1ccd">slaterdetvector_delete()</a>: De-allocate a <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdvector</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> to de-allocate</td></tr>
  </table>
  </dd>
</dl>
<p>Note: does NOT fully free the associated <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a>. For that, see function <a class="el" href="group__QT.html#ga90db736f729453581b078f727856f432">slaterdetvector_delete_full()</a></p>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="ga90db736f729453581b078f727856f432"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetvector_delete_full </td>
          <td>(</td>
          <td class="paramtype">SlaterDetVector *&#160;</td>
          <td class="paramname"><em>sdvector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga90db736f729453581b078f727856f432">slaterdetvector_delete_full()</a>: De-allocate a <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> and its associated <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a>.</p>
<p>To keep the <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> itself, use similar function <a class="el" href="group__QT.html#ga2bd2c106d795cdb373645726bbbc1ccd">slaterdetvector_delete()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdvector</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> to delete</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga90db736f729453581b078f727856f432_cgraph.svg" width="560" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad92f6aaa81bb1d58628d4789be57d1d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetvector_init </td>
          <td>(</td>
          <td class="paramtype">SlaterDetVector *&#160;</td>
          <td class="paramname"><em>sdvector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlaterDetSet *&#160;</td>
          <td class="paramname"><em>sdset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gad92f6aaa81bb1d58628d4789be57d1d4">slaterdetvector_init()</a>: Initialize a vector of coefficients corresponding to a Slater Determinant set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdvector</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> to initialize (coeffs member will be allocated) </td></tr>
    <tr><td class="paramname">sdset</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetSet.html">SlaterDetSet</a> the vector is associated with</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gad92f6aaa81bb1d58628d4789be57d1d4_cgraph.svg" width="318" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gad92f6aaa81bb1d58628d4789be57d1d4_icgraph.svg" width="382" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga67eca5299660efcf885f7bd743b587f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetvector_read </td>
          <td>(</td>
          <td class="paramtype">ULI&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlaterDetVector **&#160;</td>
          <td class="paramname"><em>sdvector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga67eca5299660efcf885f7bd743b587f9">slaterdetvector_read()</a>: Read a <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> from disk</p>
<p>Use this if we only need to read a single vector. Otherwise, call <a class="el" href="group__QT.html#ga4a2d65a1290e904986d93f3436848ab0">slaterdetset_read()</a>; <a class="el" href="group__QT.html#ga1c0d9992fdf633f70982de16d3021933">slaterdetset_read_vect()</a>; to allow for multiple vectors per slaterdetset to be read from disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>= file number to read from </td></tr>
    <tr><td class="paramname">prefix</td><td>= prefix string to come before libpsio entry keys </td></tr>
    <tr><td class="paramname">sdvector</td><td>= pointer to hold pointer to <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> allocated by this function</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_ga67eca5299660efcf885f7bd743b587f9_cgraph.svg" width="100%" height="480"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga609f6f82ffadb8fed1d312ce92635244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetvector_set </td>
          <td>(</td>
          <td class="paramtype">SlaterDetVector *&#160;</td>
          <td class="paramname"><em>sdvector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga609f6f82ffadb8fed1d312ce92635244">slaterdetvector_set()</a>: Set a <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a>'s vector to a set of coefficients supplied by array coeffs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdvector</td><td>= pointer to <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> for writing coefficients </td></tr>
    <tr><td class="paramname">coeffs</td><td>= array of coefficients to write to sdvector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac46021bca516a5b4b429384151036ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::slaterdetvector_write </td>
          <td>(</td>
          <td class="paramtype">ULI&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlaterDetVector *&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gac46021bca516a5b4b429384151036ed8">slaterdetvector_write()</a>: Write a <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> to disk.</p>
<p>This writes a vector in the space of Slater determinants, along with the set of determinants itself, to a <a class="el" href="classpsi_1_1PSIO.html">PSIO</a> file.</p>
<p>Use this if we only need to write a single vector. Otherwise, call <a class="el" href="group__QT.html#ga7821e5bc1ee8563d8284274163c9eb9e">slaterdetset_write()</a>; <a class="el" href="group__QT.html#gab353180af2fc2bcd3e513d37a3425fbd">slaterdetset_write_vect()</a>; to allow for multiple vectors per slaterdetset to be written to disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>= file number of the UNINITIALIZED <a class="el" href="classpsi_1_1PSIO.html">PSIO</a> file </td></tr>
    <tr><td class="paramname">prefix</td><td>= prefix string to come before libpsio entry keys </td></tr>
    <tr><td class="paramname">vector</td><td>= <a class="el" href="structpsi_1_1SlaterDetVector.html">SlaterDetVector</a> to write to disk</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_gac46021bca516a5b4b429384151036ed8_cgraph.svg" width="100%" height="404"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga96d6244853b8d555cb6102d9cf3e3eb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::solve_2x2_pep </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>evals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>evecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga96d6244853b8d555cb6102d9cf3e3eb5">solve_2x2_pep()</a>: Solve a 2x2 pseudo-eigenvalue problem of the form [ H11 - E H12 - E*S ] [c1] [ H12 - E*S H22 - E ] [c2] = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td>= matrix to get eigenvalues of </td></tr>
    <tr><td class="paramname">S</td><td>= overlap between states 1 &amp; 2 </td></tr>
    <tr><td class="paramname">evals</td><td>= pointer to array to hold 2 eigenvalues </td></tr>
    <tr><td class="paramname">evecs</td><td>= matrix to hold 2 eigenvectors</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="gad82d2ef8f162aa6bdf8fe1a1d64ede27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::sort_vector </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gad82d2ef8f162aa6bdf8fe1a1d64ede27">sort_vector()</a>: Sort the elements of a vector into increasing order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>= array to sort </td></tr>
    <tr><td class="paramname">n</td><td>= length of array</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="ga1eb5d78c936c34a1bff25de237c499f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::stringset_add </td>
          <td>(</td>
          <td class="paramtype">StringSet *&#160;</td>
          <td class="paramname"><em>sset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>Occ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga1eb5d78c936c34a1bff25de237c499f0">stringset_add()</a>: Add a string (in Pitzer order, given by Occ) to the <a class="el" href="structpsi_1_1StringSet.html">StringSet</a>, writing to position index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sset</td><td>= <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> to add to </td></tr>
    <tr><td class="paramname">index</td><td>= location in <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> to add to </td></tr>
    <tr><td class="paramname">Occ</td><td>= orbital occupations (Pitzer order) of the string to add</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="gae5f8571e95ec167f1a11afdf7b216f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::stringset_delete </td>
          <td>(</td>
          <td class="paramtype">StringSet *&#160;</td>
          <td class="paramname"><em>sset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gae5f8571e95ec167f1a11afdf7b216f3a">stringset_delete()</a>: Delete a <a class="el" href="structpsi_1_1StringSet.html">StringSet</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sset</td><td>= pointer to <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> to delete</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gae5f8571e95ec167f1a11afdf7b216f3a_icgraph.svg" width="560" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gafada6de1652da33accacc15f68333d5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::stringset_init </td>
          <td>(</td>
          <td class="paramtype">StringSet *&#160;</td>
          <td class="paramname"><em>sset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nelec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfzc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int *&#160;</td>
          <td class="paramname"><em>frozen_occ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gafada6de1652da33accacc15f68333d5b">stringset_init()</a>: Initialize a set of alpha/beta strings</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sset</td><td>= pointer to <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> (contains occs in Pitzer order) </td></tr>
    <tr><td class="paramname">size</td><td>= number of strings </td></tr>
    <tr><td class="paramname">nelec</td><td>= number of electrons </td></tr>
    <tr><td class="paramname">nfzc</td><td>= number of frozen core orbitals </td></tr>
    <tr><td class="paramname">frozen_occ</td><td>= array of frozen occupied orbitals (Pitzer numbering!)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_gafada6de1652da33accacc15f68333d5b_icgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gac15eb8e301802fa8f61e31f6a4b0b3c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::stringset_read </td>
          <td>(</td>
          <td class="paramtype">ULI&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringSet **&#160;</td>
          <td class="paramname"><em>stringset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gac15eb8e301802fa8f61e31f6a4b0b3c2">stringset_read()</a>: Read a <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> from disk</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>= file number to read from </td></tr>
    <tr><td class="paramname">prefix</td><td>= prefix string to come before libpsio entry keys </td></tr>
    <tr><td class="paramname">stringset</td><td>= double pointer to <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> allocated by this function</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gac15eb8e301802fa8f61e31f6a4b0b3c2_cgraph.svg" width="480" height="106"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gac15eb8e301802fa8f61e31f6a4b0b3c2_icgraph.svg" width="550" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad699d26dd571c528fa87f1dfb3182144"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::stringset_reindex </td>
          <td>(</td>
          <td class="paramtype">StringSet *&#160;</td>
          <td class="paramname"><em>sset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int *&#160;</td>
          <td class="paramname"><em>mo_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gad699d26dd571c528fa87f1dfb3182144">stringset_reindex()</a>: Remap orbital occupations from one ordering to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sset</td><td>= pointer to <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> </td></tr>
    <tr><td class="paramname">mo_map</td><td>= mapping array from original orbital order to new order</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

</div>
</div>
<a class="anchor" id="gaf365a9600d2d5b4a83eb37faa58b1d34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::stringset_write </td>
          <td>(</td>
          <td class="paramtype">ULI&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringSet *&#160;</td>
          <td class="paramname"><em>sset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gaf365a9600d2d5b4a83eb37faa58b1d34">stringset_write()</a>: Write a stringset to a PSI file</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>= file number to write to </td></tr>
    <tr><td class="paramname">prefix</td><td>= prefix string to come before libpsio entry keys </td></tr>
    <tr><td class="paramname">sset</td><td>= pointer to <a class="el" href="structpsi_1_1StringSet.html">StringSet</a> to write</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: none </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gaf365a9600d2d5b4a83eb37faa58b1d34_cgraph.svg" width="336" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gaf365a9600d2d5b4a83eb37faa58b1d34_icgraph.svg" width="526" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga3c3713e536790b780749da4f5279e436"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::timer_done </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga3c3713e536790b780749da4f5279e436">timer_done()</a>: Close down all timers and write results to timer.dat </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga3c3713e536790b780749da4f5279e436_cgraph.svg" width="240" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga177c6a6db04325eae4c5d5c6fb9bec02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::timer_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga177c6a6db04325eae4c5d5c6fb9bec02">timer_init()</a>: Initialize the linked list of timers </p>

</div>
</div>
<a class="anchor" id="gae1479e3f831fb539222f1ba2c5fa0452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::timer_off </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#gae1479e3f831fb539222f1ba2c5fa0452">timer_off()</a>: Turn off the timer with the name given as an argument. Can be turned on and off, time will accumulate while on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>= Name of timer </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_gae1479e3f831fb539222f1ba2c5fa0452_cgraph.svg" width="270" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_gae1479e3f831fb539222f1ba2c5fa0452_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga76e23a17ad31a5648f238a8ddce4d41a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psi::timer_on </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga76e23a17ad31a5648f238a8ddce4d41a">timer_on()</a>: Turn on the timer with the name given as an argument. Can be turned on and off, time will accumulate while on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>= Name of timer </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__QT_ga76e23a17ad31a5648f238a8ddce4d41a_cgraph.svg" width="270" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_ga76e23a17ad31a5648f238a8ddce4d41a_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga86ba9a6fa70806080a0e81eb75a32f73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct timer* psi::timer_scan </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="group__QT.html#ga86ba9a6fa70806080a0e81eb75a32f73">timer_scan()</a>: Return a timer structure whose name matches that given by supplied string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>= name of timer to search for</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: the timer structure with the given name, else NULL </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__QT_ga86ba9a6fa70806080a0e81eb75a32f73_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
